{"version":3,"sources":["webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/cumsum_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/index.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/All.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/version.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl.js","webpack://profilecard/./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAW,mCAAmC,OAAO;AACjE;AACA,KAAK;AACL;AACA,oC;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACH;AACxC;AACP;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACO;AACP,WAAW,IAAI;AACf;AACA,IAAI,2DAAgB;AACpB,wCAAwC,qEAAkB;AAC1D;AACA;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACwB;AACoB;AACjF,gBAAgB,gFAA4B;AAC5C,uBAAuB,kFAA6B;AAC3D,YAAY;AACZ,CAAC;AACM,YAAY,qEAAgB,CAAC,sDAAG;AAChC;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP,wBAAwB,qEAAkB;AAC1C,oBAAoB,2EAAwB;AAC5C,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,6DAAM;AACzB,mBAAmB,aAAa;AAChC,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACiB;AACxB;AACR;AACE;AACR;AACvB;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,QAAQ;AACnB;AACA;AACA;AACA,mBAAmB,mDAAQ,EAAE,UAAU,IAAI,WAAW;AACtD;AACA,gCAAgC,wDAAK;AACrC,6BAA6B,UAAU,IAAI,mBAAmB,mBAAmB,EAAE;AACnF,uBAAuB,iDAAO,EAAE,UAAU,sCAAsC,WAAW;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC/D,6BAA6B,UAAU,cAAc,mBAAmB,QAAQ,EAAE;AAClF;AACA;AACA;AACA,SAAS,uEAAoB;AAC7B;AACA;AACA,uBAAuB,mDAAQ,EAAE,UAAU,IAAI,WAAW;AAC1D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAiB;AACtC,0CAA0C,gFAA4B;AACtE;AACA;AACA,qDAAqD,QAAQ,MAAM,MAAM;AACzE;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACe;AACG;AACxD,iBAAiB,wEAAqB;AACtC,aAAa,2EAAuB,CAAC,uDAAI;AACzC;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACzC;AACP,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACpD;AACP,oBAAoB,yEAAsB,QAAQ,qEAAkB;AACpE;AACA;AACA;AACA;AACA,yBAAyB,qEAAkB;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,sFAAmC;AACnD;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACgB;AACG;AACxD,gBAAgB,wEAAqB;AACrC,YAAY,2EAAuB,CAAC,sDAAG;AACvC;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACc;AACG;AACxD,kBAAkB,wEAAqB;AACvC,cAAc,2EAAuB,CAAC,wDAAK;AAC3C;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACc;AACG;AACxD,kBAAkB,wEAAqB;AACvC,cAAc,2EAAuB,CAAC,wDAAK;AAC3C;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AACxC;AACP,mBAAmB,6DAAM;AACzB,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACoB;AACX;AAClD,oBAAoB,gFAA4B;AAChD,gBAAgB,qEAAgB,CAAC,0DAAO;AACxC;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AAC1C;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA,YAAY;AACZ;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACuB;AACX;AAClD,iBAAiB,gFAA4B;AAC7C,aAAa,qEAAgB,CAAC,uDAAI;AAClC;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA,mBAAmB,2EAAwB;AAC3C;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACgB;AACG;AACxD,gBAAgB,wEAAqB;AACrC,YAAY,2EAAuB,CAAC,sDAAG;AACvC;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP,iBAAiB,8EAA2B,QAAQ,qEAAkB;AACtE,mBAAmB,iBAAiB;AACpC;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACoB;AACX;AAClD,oBAAoB,gFAA4B;AAChD,gBAAgB,qEAAgB,CAAC,0DAAO;AACxC;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACoB;AACX;AAClD,oBAAoB,gFAA4B;AAChD,gBAAgB,qEAAgB,CAAC,0DAAO;AACxC;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACmB;AACoB;AACjF,qBAAqB,gFAA4B;AACjD,4BAA4B,kFAA6B;AAChE;AACA;AACA;AACA;AACA,CAAC;AACM,iBAAiB,qEAAgB,CAAC,2DAAQ;AAC1C;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACH;AACL;AACnC;AACP,qBAAqB,yEAAsB;AAC3C,WAAW,uDAAY;AACvB;AACO;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf,IAAI,2DAAgB;AACpB;AACA;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACmB;AACX;AAClD,qBAAqB,gFAA4B;AACjD,iBAAiB,qEAAgB,CAAC,2DAAQ;AAC1C;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6E;AAC9B;AACP;AACjC;AACP,oCAAoC,yFAAsC;AAC1E,qBAAqB,iEAAU;AAC/B,oBAAoB,2EAAwB,CAAC,qEAAkB;AAC/D,uBAAuB,qEAAkB;AACzC,mBAAmB,oBAAoB;AACvC;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACO;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,iBAAiB;AAC5B,IAAI,2DAAgB;AACpB;AACA,iBAAiB,sEAAmB;AACpC,wBAAwB,kFAA+B;AACvD;AACA;AACA;AACA;AACA,oBAAoB,qDAAS,EAAE,UAAU,IAAI,mBAAmB,oBAAoB,EAAE;AACtF;AACA,wBAAwB,gFAA6B;AACrD;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA,sBAAsB,oFAAiC;AACvD;AACA;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAwB;AACvC;AACA;AACA,mBAAmB,2EAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACc;AACG;AACxD,kBAAkB,wEAAqB;AACvC,cAAc,2EAAuB,CAAC,wDAAK;AAC3C;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsF;AACvC;AACxC;AACP,wBAAwB,8EAA2B;AACnD,mBAAmB,qEAAkB;AACrC,qBAAqB,sEAAmB;AACxC;AACA,2BAA2B,+EAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sFAAmC;AAC3C;AACA,kBAAkB,6DAAM;AACxB,mBAAmB,6DAAM;AACzB,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,eAAe,sFAAmC;AAClD;AACA;AACA;AACO;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,cAAc;AACzB,IAAI,2DAAgB;AACpB,4BAA4B,8EAA2B;AACvD,IAAI,+EAA4B;AAChC;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACU;AACX;AAClD,8BAA8B,gFAA4B;AACjE;AACA;AACA,CAAC;AACM,0BAA0B,qEAAgB,CAAC,oEAAiB;AAC5D;AACP,gBAAgB,oEAAiB;AACjC;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AACxC;AACP,mBAAmB,6DAAM;AACzB,mBAAmB,iBAAiB;AACpC;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACwB;AACoB;AACjF,gBAAgB,gFAA4B;AAC5C,uBAAuB,kFAA6B;AAC3D,YAAY;AACZ,CAAC;AACM,YAAY,qEAAgB,CAAC,sDAAG;AAChC;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AAC/C;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,mBAAmB,6DAAM;AACzB,mBAAmB,0BAA0B;AAC7C;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP;AACA;AACA;AACA,wBAAwB,8EAA2B;AACnD,2BAA2B,8EAA2B;AACtD,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAM;AACd,QAAQ,6DAAM;AACd;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACH;AACE;AAC1C;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,IAAI,2DAAgB;AACpB;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,mBAAmB,8DAAa;AAChC;AACA,YAAY;AACZ;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA,kBAAkB,qEAAkB;AACpC,qBAAqB,sEAAmB;AACxC,uBAAuB,sEAAmB;AAC1C,mBAAmB,8EAA2B,QAAQ,qEAAkB;AACxE,mBAAmB,WAAW;AAC9B,oBAAoB,kEAAe;AACnC;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,yBAAyB,kEAAe;AACxC;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACpD;AACP;AACA,kBAAkB,sEAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAY;AACxC;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAY;AACzC;AACA,uBAAuB,iBAAiB;AACxC,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACN;AACmC;AACjC;AACS;AACX;AACI;AACA;AACW;AACP;AACN;AACa;AACf;AACK;AACG;AACA;AACE;AACV;AACU;AACR;AACO;AACL;AACA;AACwB;AACL;AACvB;AACO;AACA;AACU;AACN;AACnD,kC;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC3D;AACA;AACA;AACO;AACP;AACA,yBAAyB,0FAAuC;AAChE;AACA,8BAA8B,sEAAmB;AACjD,2BAA2B,qEAAkB;AAC7C,uBAAuB,8EAA2B;AAClD;AACA;AACA,yBAAyB,sEAAmB;AAC5C,yBAAyB,sEAAmB;AAC5C,+BAA+B,gFAA6B;AAC5D,+BAA+B,gFAA6B;AAC5D;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C,4BAA4B,kEAAe;AAC3C;AACA;AACA,+BAA+B,kEAAe;AAC9C;AACA;AACA,+BAA+B,kEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACZ;AACR;AACM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB,kBAAkB;AACnC,mBAAmB,OAAO;AAC1B;AACA,YAAY,2DAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,eAAe,OAAO;AACtB;AACA;AACA,8BAA8B,mDAAI,EAAE,UAAU,OAAO,+BAA+B,qBAAqB,EAAE;AAC3G;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAI,EAAE,UAAU,OAAO,+BAA+B,qBAAqB,EAAE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAO,EAAE,UAAU,qCAAqC,uBAAuB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B,0FAAuC;AACnE,2BAA2B,qEAAkB;AAC7C;AACA,8BAA8B,sEAAmB;AACjD,+BAA+B,8EAA2B;AAC1D,+BAA+B,8EAA2B;AAC1D,+BAA+B,gFAA6B;AAC5D,+BAA+B,gFAA6B;AAC5D,sBAAsB,sFAAmC;AACzD,sBAAsB,sFAAmC;AACzD;AACA,yBAAyB,sEAAmB;AAC5C;AACA,yBAAyB,sEAAmB;AAC5C;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD,4BAA4B,kEAAe;AAC3C;AACA;AACA,+BAA+B,kEAAe;AAC9C;AACA;AACA,+BAA+B,kEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACO;AACP;AACA,0BAA0B,8EAA2B;AACrD,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,aAAa,yBAAyB;AACtC,eAAe,IAAI;AACnB,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAkB;AACxC;AACA,0BAA0B,yEAAsB;AAChD,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,aAAa,yBAAyB;AACtC,eAAe,IAAI;AACnB,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACA;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,yDAAO,EAAE,UAAU,aAAa,WAAW;AAC1D;AACA,mBAAmB,2EAAwB,CAAC,qEAAkB;AAC9D;AACA;AACA,sC;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA,oCAAoC,SAAS,QAAQ,SAAS,cAAc;AAC5E,SAAS;AACT;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,SAAS;AACT;AACA;AACA;AACA,UAAU;;AAEV,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA,mCAAmC,SAAS,QAAQ,SAAS,cAAc;AAC3E,SAAS;AACT;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,SAAS;AACT;AACA;AACA;AACA,UAAU;;AAEV,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;;AAEA,uBAAuB,OAAO,YAAY;AAC1C,wBAAwB;AACxB;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACA;AACS;AAC/C;AACP;AACA;AACA;AACA;AACA,QAAQ,8DAAW,sCAAsC;AACzD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC,uBAAuB,0DAAW;AAClC;AACA;AACA;AACA;AACA,mCAAmC,mEAAiB;AACpD;AACA,UAAU,eAAe,gBAAgB,eAAe,GAAG,cAAc;AACzE,YAAY;AACZ,UAAU,eAAe,gBAAgB,eAAe,GAAG,cAAc;AACzE,YAAY;AACZ,UAAU,eAAe,gBAAgB,eAAe,GAAG,cAAc;AACzE,YAAY;AACZ,UAAU,eAAe,gBAAgB,eAAe,GAAG,cAAc;AACzE,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB,YAAY;AACZ,UAAU,MAAM;AAChB,YAAY;AACZ,UAAU,MAAM;AAChB,YAAY;AACZ,UAAU,MAAM;AAChB,YAAY,kBAAkB;AAC9B;AACA;AACA,yDAAyD;AACzD;AACA,2BAA2B,0DAAW;AACtC,2BAA2B,0DAAW;AACtC,2BAA2B,0DAAW;AACtC,2BAA2B,0DAAW;AACtC;AACA;AACA,sDAAsD,kBAAkB;AACxE,sDAAsD,kBAAkB;AACxE,sDAAsD,kBAAkB;AACxE,sDAAsD,kBAAkB,IAAI;AAC5E;AACA,0BAA0B,kBAAkB;AAC5C,uCAAuC,kBAAkB;AACzD,uCAAuC,kBAAkB;AACzD,qDAAqD,kBAAkB;AACvE;AACA,qCAAqC,mBAAmB;AACxD,4CAA4C,gBAAgB;AAC5D,iDAAiD,0BAA0B;AAC3E,OAAO;AACP;AACA,0BAA0B,mBAAmB;AAC7C,iCAAiC,gBAAgB;AACjD,sCAAsC,0BAA0B;AAChE;AACA,QAAQ;AACR;AACA,UAAU,MAAM;AAChB,4BAA4B,iBAAiB,KAAK;AAClD,4BAA4B,iBAAiB,KAAK;AAClD,UAAU;AACV,yCAAyC,UAAU,cAAc,UAAU;AAC3E,sBAAsB,UAAU,cAAc,UAAU,MAAM;AAC9D;AACA;AACA,2BAA2B;;AAE3B,uBAAuB,OAAO,YAAY;AAC1C;AACA,YAAY;AACZ,6BAA6B;AAC7B;AACA;AACA,mBAAmB,OAAO;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO,IAAI,QAAQ;AACpD,0CAA0C,cAAc;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,oBAAoB,eAAe;AACnC,gDAAgD,aAAa;;AAE7D,oCAAoC,mBAAmB;AACvD;AACA;AACA;;AAEA,0BAA0B,QAAQ;AAClC,mBAAmB,cAAc;AACjC,kDAAkD,YAAY;;AAE9D,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,IAAI,OAAO,IAAI,QAAQ;AACjE,0CAA0C,cAAc;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC,oBAAoB,cAAc;AAClC,gDAAgD,YAAY;;AAE5D,oCAAoC,kBAAkB;AACtD;AACA;AACA;;AAEA,0BAA0B,QAAQ;AAClC,sBAAsB,eAAe;AACrC,kDAAkD,aAAa;;AAE/D,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC,wBAAwB,cAAc;AACtC,oDAAoD,YAAY;;AAEhE,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;AACiH;AACxF;AACU;AACa;AACf;AACa;AACX;AACa;AACxB;AACJ;AACc;AAChB;AACmB;AACrB;AACG;AACS;AACT;AACK;AACa;AACf;AACF;AAC3C,kBAAkB,yEAAsB;AACjC;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX,oBAAoB;AACpB;AACA,YAAY,0DAAG,0BAA0B,0DAAG;AAC5C;AACA;AACA;AACO,+BAA+B,gEAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAG;AAChB;AACA;AACA;AACA,uBAAuB,6DAAe,CAAC,0DAAG;AAC1C,8CAA8C,0DAAG;AACjD,6BAA6B,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAc;AAChD;AACA,2BAA2B,8DAAW,OAAO,6DAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAA4D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAoB,QAAQ,+CAAc;AACxE;AACA;AACA,8BAA8B,wDAAc,QAAQ,+CAAc;AAClE;AACA,wDAAwD,uBAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,qBAAqB,sFAAmC;AACxD;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAA4D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAoB,QAAQ,+CAAc;AACxE;AACA;AACA,8BAA8B,wDAAc,QAAQ,+CAAc;AAClE;AACA,wDAAwD,uBAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAG;AAChB,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAG;AACxC;AACA;AACA;AACA,4EAA4E,uDAAyB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sFAAmC;AACtD;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oEAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAM;AACrB;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA,iBAAiB,yDAA2B;AAC5C,oBAAoB,0DAAG;AACvB,6CAA6C,IAAI;AACjD;AACA,6EAA6E;AAC7E;AACA,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,qBAAqB,qEAAkB;AACvC,YAAY,0DAAG;AACf;AACA;AACA;AACA,qEAAqE,uDAAyB;AAC9F;AACA;AACA;AACA;AACA,uCAAuC,0DAAG;AAC1C,qDAAqD,qDAAuB;AAC5E;AACA,gBAAgB,8EAAwB;AACxC,gBAAgB,kEAAkB;AAClC,uDAAuD,oCAAoC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+DAAY;AACxD;AACA,0CAA0C,+DAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA,8BAA8B,2DAAQ;AACtC,wEAAwE,4CAA4C;AACpH,6BAA6B,OAAO,IAAI,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA,gBAAgB,UAAU,2DAAQ;AAClC;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA;AACA,sBAAsB,2DAAQ;AAC9B;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAmD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAG;AAChB;AACA;AACA;AACA,8BAA8B,6DAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAgB;AAC9C;AACA;AACA,YAAY,0DAAG;AACf,yCAAyC,6CAAY;AACrD;AACA,4BAA4B,wDAAc,UAAU,6CAAY;AAChE;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAa;AACzB,kDAAkD,oEAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,SAAS;AACxB,eAAe,6DAAM;AACrB;AACA;AACA,4BAA4B,uDAAa;AACzC;AACA;AACA;AACA,4BAA4B,mDAAW;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAsB;AAClC,eAAe,oDAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAsB,iBAAiB,oDAAsB;AACzE;AACA,4BAA4B,sEAAoB;AAChD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,0BAA0B,qDAAuB;AACjD;AACA;AACA,0BAA0B,iFAAyB;AACnD;AACA;AACA,0BAA0B,oEAAmB;AAC7C;AACA;AACA,oDAAoD,kCAAkC;AACtF,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0DAA4B;AACrE,+BAA+B,uDAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAkB;AAC9B;AACA;AACA;AACA,gBAAgB,8EAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qEAAkB;AACtC,wBAAwB,0DAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,4BAA4B;AAC5B,oBAAoB,uDAAwB;AAC5C;AACA,mBAAmB,wDAAyB;AAC5C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAqB;AAC7B;AACA;AACA;AACA,oCAAoC,kEAAkE;AACtG;AACA,aAAa,0DAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAG;AAChB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2DAAI;AAC3C,qBAAqB,0DAAG;AACxB;AACA;AACA,sCAAsC,0DAAG;AACzC,oBAAoB,0DAAG;AACvB,yDAAyD,6DAAM;AAC/D,oBAAoB,0DAAG;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAiD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAQ;AAC5B;AACA;AACA;AACA,uBAAuB,wEAA0C;AACjE;AACA;AACA;AACA,8BAA8B,qDAAuB;AACrD;AACA;AACA;AACA;AACA,kCAAkC,6EAA+C;AACjF,8BAA8B,iFAAyB;AACvD;AACA;AACA;AACA,wBAAwB,oEAAmB;AAC3C;AACA;AACA;AACA;AACA,oBAAoB,0DAAmB;AACvC;AACA;AACA;AACA,oBAAoB,0DAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;;;;;;;ACl3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AAClB;AACE;AACrD,IAAI,wEAAqB;AACzB,IAAI,sEAAe,oBAAoB,4DAAgB;AACvD;AACA;AACwB;AACxB;AACyC;AAClC,eAAe,eAAe;AACrC,gC;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP;AACA;AACA;AACA,QAAQ,0FAAuC;AAC/C,QAAQ,0FAAuC;AAC/C;AACA;AACA,YAAY,0FAAuC;AACnD;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,wBAAwB;AACxB,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP;AACA;AACA;AACA;AACA,QAAQ,0FAAuC;AAC/C,QAAQ,0FAAuC;AAC/C;AACA;AACA,YAAY,0FAAuC;AACnD;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,yDAAyD,gBAAgB;;AAEzE;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACrD;AACA;AACA;AACA;AACO;AACP,gDAAgD;AAChD,gDAAgD;AAChD;AACO;AACP;AACA;AACA,2BAA2B,0FAAuC;AAClE;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP;AACA;AACA;AACO,qDAAqD;AACrD;AACP;AACA;AACA,2BAA2B,0FAAuC;AAClE;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACd;AACS;AAC/C;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,0FAAuC;AAClE;AACA;AACA;AACA,8BAA8B,qEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAiB;AAC/C;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAW;AAChD;AACA;AACA,iBAAiB,mBAAmB,WAAW;AAC/C;AACA,iBAAiB,mBAAmB,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP;AACA;AACA;AACA,2BAA2B,+EAA4B;AACvD,sDAAsD,EAAE;AACxD;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,sCAAsC,WAAW,2BAA2B;AAC5E,uBAAuB,oBAAoB;AAC3C;AACA,2CAA2C,WAAW;AACtD,iCAAiC,EAAE,UAAU,MAAM,GAAG;AACtD;AACA;AACA;AACA,4CAA4C,UAAU,UAAU,UAAU,GAAG;AAC7E;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACR;AACS;AAC/C;AACP;AACA;AACA;AACA;AACA,2BAA2B,+EAA4B;AACvD;AACA;AACA,sBAAsB,mEAAiB;AACvC,uBAAuB,0DAAW;AAClC;AACA,sDAAsD,EAAE;AACxD;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,KAAK,WAAW;AAC7D;AACA,oBAAoB,YAAY,UAAU,oBAAoB;AAC9D,SAAS;AACT,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,KAAK,WAAW,OAAO,QAAQ,MAAM,eAAe;AAC1E;AACA,kBAAkB,EAAE,GAAG,0CAA0C;AACjE,mBAAmB,8CAA8C;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU,GAAG,0CAA0C;AACvE,iBAAiB,8CAA8C,GAAG;AAClE;AACA,uBAAuB,8BAA8B;AACrD,UAAU;AACV;;AAEA;AACA,UAAU,MAAM;AAChB,sCAAsC,OAAO;;AAE7C,UAAU,iBAAiB,KAAK,iBAAiB;AACjD,cAAc,iBAAiB,KAAK,gBAAgB;AACpD,gCAAgC,OAAO;AACvC;;AAEA,UAAU,iBAAiB,KAAK,iBAAiB;AACjD,cAAc,iBAAiB,KAAK,gBAAgB;AACpD,gCAAgC,OAAO;AACvC;;AAEA,UAAU,iBAAiB,KAAK,iBAAiB;AACjD,cAAc,iBAAiB,KAAK,gBAAgB;AACpD,cAAc,iBAAiB,KAAK,gBAAgB;AACpD,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,EAAE,KAAK,MAAM;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6C;;;;;;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,OAAO,oBAAoB;AAClD,0BAA0B,QAAQ,oBAAoB;AACtD,iCAAiC,aAAa,KAAK;;AAEnD,kCAAkC,kBAAkB;AACpD;AACA;;AAEA,4BAA4B,QAAQ,mBAAmB;AACvD,mCAAmC,YAAY,KAAK;;AAEpD,oCAAoC,iBAAiB;AACrD;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO,IAAI,QAAQ;;AAEpD;AACA;AACA;AACA,0BAA0B,WAAW;;AAErC,wCAAwC,OAAO,YAAY,OAAO;AAClE;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ,cAAc;AAC9C,gDAAgD,aAAa;;AAE7D,oCAAoC,mBAAmB;AACvD;AACA;AACA;;AAEA,yBAAyB,aAAa;;AAEtC,0BAA0B,QAAQ,aAAa;AAC/C,kDAAkD,YAAY;;AAE9D,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;;AAEA,2BAA2B,YAAY;;AAEvC,4BAA4B,QAAQ,sBAAsB;;AAE1D,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,OAAO,oBAAoB;AAClD,0BAA0B,QAAQ,mBAAmB;AACrD,iCAAiC,YAAY,KAAK;;AAElD,kCAAkC,iBAAiB;AACnD;AACA;;AAEA,4BAA4B,QAAQ,oBAAoB;AACxD,mCAAmC,aAAa,KAAK;;AAErD,oCAAoC,kBAAkB;AACtD;AACA;;AAEA,8BAA8B,QAAQ,mBAAmB;AACzD,qCAAqC,YAAY,KAAK;;AAEtD,sCAAsC,iBAAiB;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,IAAI,OAAO,IAAI,QAAQ;;AAEjE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ,aAAa;AAC7C,gDAAgD,YAAY;;AAE5D,oCAAoC,kBAAkB;AACtD;AACA;AACA;;AAEA,yBAAyB,YAAY;;AAErC,0BAA0B,QAAQ,cAAc;AAChD,kDAAkD,aAAa;;AAE/D,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;;AAEA,2BAA2B,aAAa;;AAExC,4BAA4B,QAAQ,aAAa;AACjD,oDAAoD,YAAY;;AAEhE,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;;AAEA,6BAA6B,YAAY;;AAEzC,8BAA8B,QAAQ,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;;AAEnC;;AAEA;AACA,uBAAuB,OAAO,oBAAoB;AAClD,0BAA0B,QAAQ,oBAAoB;AACtD,iCAAiC,aAAa,KAAK;;AAEnD,kCAAkC,kBAAkB;AACpD;AACA;;AAEA,4BAA4B,QAAQ,mBAAmB;AACvD,mCAAmC,YAAY,KAAK;;AAEpD,oCAAoC,iBAAiB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO,IAAI,QAAQ;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,QAAQ,cAAc;AAC9C,gDAAgD,aAAa;;AAE7D,oCAAoC,mBAAmB;AACvD;AACA;AACA;;AAEA,yBAAyB,aAAa;;AAEtC,0BAA0B,QAAQ,aAAa;AAC/C,kDAAkD,YAAY;;AAE9D,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;;AAEA,2BAA2B,YAAY;;AAEvC;AACA,4BAA4B,QAAQ,YAAY;AAChD,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kEAAkE;AAClE;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER,oCAAoC,aAAa,IAAI,YAAY;AACjE,iCAAiC,OAAO,IAAI,QAAQ;;AAEpD;AACA;AACA;AACA,0BAA0B,WAAW;;AAErC;AACA,2BAA2B,OAAO,YAAY,OAAO;AACrD;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ,cAAc;AAC9C,qCAAqC;;AAErC,gCAAgC,kBAAkB;AAClD;AACA;;AAEA,0BAA0B,QAAQ,aAAa;AAC/C,uCAAuC;;AAEvC,kCAAkC,iBAAiB;AACnD;AACA;;AAEA,4BAA4B,QAAQ,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;;AAEhD,oBAAoB,eAAe;AACnC;AACA,0CAA0C,sBAAsB;AAChE,mCAAmC,sBAAsB;AACzD,eAAe;AACf;AACA,kCAAkC,sBAAsB;AACxD,mCAAmC,sBAAsB;AACzD;;AAEA,aAAa,YAAY,8BAA8B;AACvD;AACA,+BAA+B,sBAAsB;AACrD,+BAA+B,sBAAsB;AACrD;;AAEA,oBAAoB,eAAe;AACnC;AACA,wCAAwC,sBAAsB;AAC9D,wCAAwC,sBAAsB;AAC9D;AACA;AACA,eAAe;AACf;AACA,gCAAgC,sBAAsB;AACtD,gCAAgC,sBAAsB;AACtD;AACA;AACA;;AAEA,aAAa,YAAY,8BAA8B;AACvD;AACA,+BAA+B,sBAAsB;AACrD,+BAA+B,sBAAsB;AACrD,+BAA+B,sBAAsB;AACrD;;AAEA,oBAAoB,eAAe;AACnC;AACA,wCAAwC,sBAAsB;AAC9D,wCAAwC,sBAAsB;AAC9D,wCAAwC,sBAAsB;AAC9D;AACA;AACA,eAAe;AACf;AACA,gCAAgC,sBAAsB;AACtD,gCAAgC,sBAAsB;AACtD,gCAAgC,sBAAsB;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,IAAI,aAAa,IAAI,YAAY;AACjF,iCAAiC,SAAS,IAAI,OAAO,IAAI,QAAQ;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,aAAa;AAC7C,qCAAqC;;AAErC,gCAAgC,iBAAiB;AACjD;AACA;;AAEA,0BAA0B,QAAQ,cAAc;AAChD,uCAAuC;;AAEvC,kCAAkC,kBAAkB;AACpD;AACA;;AAEA,4BAA4B,QAAQ,aAAa;AACjD,yCAAyC;;AAEzC,oCAAoC,iBAAiB;AACrD;AACA;;AAEA,8BAA8B,QAAQ,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA,4CAA4C,sBAAsB;AAClE,qCAAqC,sBAAsB;AAC3D,eAAe,YAAY,8BAA8B;AACzD;AACA,4CAA4C,sBAAsB;AAClE,4CAA4C,sBAAsB;AAClE;AACA;AACA,qCAAqC,sBAAsB;AAC3D,qCAAqC,sBAAsB;AAC3D;AACA;AACA,eAAe,YAAY,8BAA8B;AACzD;AACA,4CAA4C,sBAAsB;AAClE,4CAA4C,sBAAsB;AAClE,4CAA4C,sBAAsB;AAClE;AACA;AACA,qCAAqC,sBAAsB;AAC3D,qCAAqC,sBAAsB;AAC3D,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;AC/SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kEAAkE;AAClE;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER,oCAAoC,aAAa,IAAI,YAAY;AACjE,iCAAiC,OAAO,IAAI,QAAQ;;AAEpD;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,cAAc;AAC9C,qCAAqC;;AAErC,gCAAgC,SAAS;AACzC;AACA;;AAEA,0BAA0B,QAAQ,aAAa;AAC/C,uCAAuC;;AAEvC,kCAAkC,SAAS;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,cAAc;AACrD,uBAAuB,kBAAkB;AACzC,2BAA2B,iBAAiB;AAC5C;AACA,wBAAwB,EAAE,GAAG,MAAM;AACnC,mBAAmB,EAAE,GAAG,EAAE;AAC1B,mBAAmB,EAAE,GAAG,EAAE,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,gCAAgC,uBAAuB;AACvD;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS,kCAAkC,SAAS;AACzF,2BAA2B,EAAE,GAAG,EAAE;;AAElC;AACA;AACA,uCAAuC,SAAS;AAChD,6BAA6B,EAAE,GAAG,EAAE;AACpC;AACA,iBAAiB;AACjB,2BAA2B,EAAE,GAAG,EAAE;AAClC;;AAEA;AACA,qCAAqC,SAAS,kCAAkC,SAAS;AACzF;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;;AAEA,sBAAsB,EAAE,GAAG,EAAE,8BAA8B,EAAE,GAAG,EAAE;AAClE,iBAAiB;AACjB,sBAAsB,EAAE,GAAG,EAAE,uBAAuB,EAAE,GAAG,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS,sBAAsB,SAAS;AAC7E,2BAA2B,EAAE,GAAG,EAAE;AAClC,iBAAiB;AACjB,2BAA2B,EAAE,GAAG,EAAE;AAClC;;AAEA,oBAAoB,EAAE,GAAG,EAAE,YAAY,EAAE,GAAG;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAsB;AACtD;AACA;AACA;AACA;AACA,oCAAoC,YAAY,KAAK;;AAErD,uCAAuC,SAAS;AAChD,kDAAkD,SAAS;AAC3D,6BAA6B,EAAE,GAAG,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD,oDAAoD,SAAS;AAC7D,+BAA+B,EAAE,GAAG,EAAE;AACtC,qBAAqB;AACrB,+BAA+B,EAAE,GAAG,EAAE;AACtC;AACA;AACA;AACA;AACA,sBAAsB,EAAE,GAAG,MAAM;AACjC,6BAA6B,EAAE,GAAG,EAAE,cAAc,EAAE,GAAG,MAAM;AAC7D;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC,uCAAuC,SAAS;AAChD,kDAAkD,SAAS;AAC3D,6BAA6B,EAAE,GAAG,MAAM;AACxC;;AAEA,sBAAsB,EAAE,GAAG,MAAM,YAAY,EAAE,GAAG;AAClD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA,mEAAmE,EAAE,GAAG,EAAE;AAC1E,qCAAqC,EAAE,GAAG,MAAM;AAChD,uEAAuE,EAAE,EAAE,OAAO;AAClF;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iDAAiD,SAAS;AAC1D,2BAA2B,EAAE,GAAG,EAAE;AAClC,iBAAiB;AACjB,2BAA2B,EAAE,GAAG,EAAE;AAClC;;AAEA,6CAA6C,SAAS;AACtD,2BAA2B,EAAE,GAAG,MAAM;AACtC,iBAAiB;AACjB,2BAA2B,EAAE,GAAG,MAAM;AACtC;;AAEA,oBAAoB,EAAE,GAAG,EAAE;AAC3B,2BAA2B,EAAE,GAAG,EAAE,cAAc,EAAE,GAAG,MAAM;AAC3D;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mDAAmD,SAAS;AAC5D;AACA;AACA,sBAAsB,EAAE,GAAG,MAAM,iBAAiB,EAAE,GAAG,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C,2BAA2B,EAAE,GAAG,EAAE;AAClC,iBAAiB;AACjB,2BAA2B,EAAE,GAAG,EAAE;AAClC;;AAEA,kCAAkC;AAClC,iDAAiD,SAAS;AAC1D,2BAA2B,EAAE,GAAG,MAAM;AACtC,iBAAiB;AACjB,2BAA2B,EAAE,GAAG,MAAM;AACtC;;AAEA,oBAAoB,EAAE,GAAG,EAAE;AAC3B,2BAA2B,EAAE,GAAG,EAAE,cAAc,EAAE,GAAG,MAAM;AAC3D;AACA;AACA;AACA,sBAAsB,EAAE,GAAG,MAAM;AACjC,6BAA6B,EAAE,GAAG,EAAE,cAAc,EAAE,GAAG,MAAM;AAC7D;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,0BAA0B,EAAE,GAAG,EAAE,UAAU,EAAE,IAAI,EAAE;AACnD,gBAAgB,EAAE,GAAG,EAAE,iBAAiB,EAAE,GAAG,EAAE,cAAc,EAAE,GAAG,EAAE;AACpE;AACA;AACA;AACA,4BAA4B,EAAE,GAAG,MAAM,UAAU,EAAE,IAAI,MAAM;AAC7D,kBAAkB,EAAE,GAAG,MAAM;AAC7B,8BAA8B,EAAE,GAAG,MAAM,cAAc,EAAE,GAAG,MAAM,KAAK;AACvE;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,2BAA2B,iBAAiB;AAC5C,4CAA4C,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,GAAG;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA,kEAAkE;AAClE;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER,oCAAoC,aAAa,IAAI,YAAY;AACjE,iCAAiC,OAAO,IAAI,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAU;;AAEV;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qD;;;;;;;;;;;;;;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB,QAAQ,eAAe;AAC/F;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;;AAEA,+BAA+B;AAC/B,8BAA8B;;AAE9B,uBAAuB;AACvB,mCAAmC,iBAAiB;AACpD,4BAA4B,mBAAmB;AAC/C;AACA;AACA,uBAAuB;AACvB,mCAAmC,gBAAgB;AACnD,4BAA4B,mBAAmB;AAC/C;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;ACnHsD;AAC/C;AACP;AACA;AACA;AACA;AACA,gDAAgD,0BAA0B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA,UAAU,mEAAiB,OAAO;AAClC,oBAAoB;AACpB,sBAAsB;AACtB;AACA,cAAc,UAAU;AACxB,sBAAsB;AACtB,YAAY,8BAA8B;AAC1C,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA,kBAAkB,KAAK,MAAM,KAAK;AAClC;AACA;AACA,kBAAkB,KAAK,MAAM,KAAK,MAAM,KAAK;AAC7C;AACA;AACA,kBAAkB,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK;AACxD;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA,kBAAkB,KAAK;AACvB;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA,sC;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACE;AACO;AACtD;AACP;AACA;AACA;AACA;AACA,gCAAgC,0DAAmB;AACnD,yBAAyB,2DAAgB;AACzC,qBAAqB,iEAAkB;AACvC;AACA;AACA;AACA,UAAU,qFAA8C;AACxD;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY,IAAI,YAAY;AAC7C,wCAAwC,YAAY;;AAEpD;;AAEA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;;AAEA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACE;AACO;AACtD;AACP;AACA;AACA;AACA;AACA,gCAAgC,0DAAmB;AACnD,yBAAyB,2DAAgB;AACzC,qBAAqB,iEAAkB;AACvC;AACA;AACA;AACA,UAAU,qFAA8C;AACxD;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY,IAAI,YAAY;AAC7C,wCAAwC,YAAY;;AAEpD;;AAEA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;;AAEA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;;AAEhB,uBAAuB;AACvB,+BAA+B,UAAU;AACzC,uBAAuB;AACvB,+BAA+B,UAAU;AACzC,mCAAmC,UAAU;AAC7C,UAAU;AACV;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,kHAAkH;AACjI,eAAe,6BAA6B;AAC5C;AACA,oCAAoC,aAAa,IAAI,YAAY;AACjE,iCAAiC,OAAO,IAAI,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO,cAAc;AAC5C,iCAAiC;;AAEjC,kCAAkC,SAAS;AAC3C,2BAA2B,OAAO,aAAa;AAC/C,qCAAqC;;AAErC,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACU;AACpB;AACnC;AACP;AACA;AACA,2BAA2B,4DAAqB;AAChD,qBAAqB,iEAAkB;AACvC;AACA;AACA,QAAQ,uEAAoB;;AAE5B;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACU;AACpB;AACnC;AACP;AACA;AACA;AACA;AACA,2BAA2B,4DAAqB;AAChD,qBAAqB,iEAAkB;AACvC;AACA;AACA,QAAQ,uEAAoB;;AAE5B;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA,mD;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACE;AAC/C;AACP;AACA;AACA,qBAAqB,iEAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAA8B;;AAEtC;AACA;;AAEA;AACA;;AAEA;;AAEA,8BAA8B;AAC9B,kCAAkC,MAAM;AACxC,iDAAiD,MAAM,MAAM,OAAO;AACpE,wBAAwB,eAAe;;AAEvC;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA,UAAU,YAAY,UAAU,OAAO;AACvC;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACE;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qBAAqB,iEAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC,6BAA6B,UAAU;AACvC;AACA;AACA;AACA,gCAAgC,IAAI,KAAK,eAAe;AACxD,gCAAgC;AAChC,kCAAkC,IAAI,KAAK,eAAe;AAC1D,kCAAkC;;AAElC;AACA;;AAEA;;AAEA,gCAAgC;AAChC,oCAAoC,MAAM;AAC1C,kDAAkD,MAAM,MAAM,OAAO;AACrE,yBAAyB,eAAe;;AAExC;AACA,yBAAyB,QAAQ;AACjC,eAAe;AACf,yBAAyB,QAAQ;AACjC,eAAe;AACf,yBAAyB,QAAQ;AACjC,eAAe;AACf,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAA8B;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV,UAAU,YAAY,KAAK;AAC3B;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6DAA6D,QAAQ,cAAc,QAAQ;AAC3F,+CAA+C,SAAS;AACxD;AACA;AACA,yDAAyD;AACzD;AACA;AACA,yDAAyD;AACzD;AACA;AACA,kFAAkF,UAAU;AAC5F;AACA;AACA,yCAAyC;;AAEzC;AACA,UAAU;AACV;;AAEA;AACA,kDAAkD,SAAS;AAC3D;AACA;;AAEA;;AAEA,uBAAuB,OAAO,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACuK;AAChO,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAqB;AAC7B;AACA;AACA,aAAa,kEAAqB;AAClC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAsB;AACvE;AACA,uDAAuD,mEAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8EAAiC;AAC5C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAoB;AACzB;AACA;AACA;AACA,uDAAuD,+EAAkC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uDAAuD,0EAA6B;AACpF;AACA,kDAAkD,gEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,8CAA8C,UAAU;AACxD;AACA,CAAC;AACD,uC;;;;;;;;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,WAAW;AACpC;AACA,uCAAuC,WAAW;AAClD;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC;AACA;AACA;AACA,UAAU,MAAM;AAChB,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;AC9CsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAiB;AAC7C,sBAAsB,mEAAiB;AACvC;AACA;AACA,UAAU,YAAY,aAAa,YAAY,GAAG,aAAa;AAC/D;AACA,YAAY,MAAM;AAClB;AACA,yBAAyB,OAAO,eAAe;AAC/C;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACe;AACtB;AACJ;AACI;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAG;AAC7B;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA;AACA,gBAAgB,4DAA8B;AAC9C,gBAAgB,qDAAuB;AACvC;AACA,oBAAoB,4DAA8B;AAClD;AACA,qBAAqB,0DAAG;AACxB;AACA;AACA;AACA;AACA,gBAAgB,qDAAuB;AACvC;AACA,oBAAoB,4DAA8B;AAClD;AACA,qBAAqB,0DAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAuB;AACvC;AACA;AACA;AACA,qBAAqB,qDAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAA6B;AACzD,2BAA2B,0DAA4B;AACvD,2BAA2B,0DAA4B;AACvD;AACA,YAAY,uDAAyB;AACrC;AACA;AACA,eAAe,0DAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAuB;AAC/B,QAAQ,qDAAuB;AAC/B,QAAQ,qDAAuB;AAC/B,QAAQ,qDAAuB;AAC/B,QAAQ,qDAAuB;AAC/B,QAAQ,qDAAuB;AAC/B;AACA;AACA;AACA;AACA,eAAe,mEAAqC;AACpD;AACA;AACA;AACA,eAAe,mEAAqC;AACpD;AACA;AACA;AACA,eAAe,yEAA2C;AAC1D;AACA;AACA;AACA,QAAQ,iEAAmC;AAC3C;AACA;AACA;AACA,QAAQ,mEAAqC;AAC7C;AACA;AACA;AACA,eAAe,yEAA2C;AAC1D;AACA;AACA;AACA,eAAe,kEAAoC;AACnD;AACA;AACA;AACA;AACA,YAAY,0EAA4C;AACxD;AACA;AACA,QAAQ,qDAAuB;AAC/B;AACA;AACA,wDAAwD,wFAA0D;AAClH;AACA;AACA,eAAe,uEAAyC;AACxD;AACA;AACA,eAAe,wEAA0C;AACzD;AACA;AACA;AACA,uBAAuB,sEAAwC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAG;AACpB;AACA;AACA,+DAA+D,0DAAG;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,wDAAwD,8EAAgD;AACxG;AACA;AACA;AACA;AACA,+BAA+B,6DAA+B;AAC9D,6BAA6B,2DAA6B;AAC1D,wBAAwB,sDAAwB;AAChD,QAAQ,qDAAuB;AAC/B,QAAQ,qDAAuB;AAC/B,QAAQ,oDAAsB;AAC9B;AACA,YAAY,wDAA0B;AACtC;AACA;AACA;AACA,uCAAuC,0EAA4C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAA0B;AACtC;AACA,QAAQ,qDAAuB;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,yEAA2C;AAC9D;AACA;AACA,mBAAmB,kEAAoC;AACvD;AACA;AACA;AACA;AACA,eAAe,qDAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAA6C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6EAA+C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAA0B;AACtC;AACA,QAAQ,4DAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAuB;AAC/B;AACA;AACA;AACA,QAAQ,qDAAuB;AAC/B;AACA;AACA;AACA;AACA,gBAAgB,4DAA8B,UAAU,0DAAG;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mEAAgB;AAC9B;AACA;AACA,yCAAyC,0DAAG;AAC5C,wCAAwC,0DAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,sEAAwC;AAChD;AACA,YAAY,4DAA8B;AAC1C;AACA;AACA;AACA;AACA,YAAY,sEAAwC;AACpD;AACA,gBAAgB,4DAA8B;AAC9C;AACA;AACA;AACA,YAAY,0EAA4C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAwC;AAChD;AACA,YAAY,4DAA8B;AAC1C;AACA;AACA,QAAQ,qDAAuB;AAC/B,QAAQ,qDAAuB;AAC/B;AACA;AACA;AACA,QAAQ,qDAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACG;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAA0B;AAC7C;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAgB;AAC7B;AACA,4CAA4C,OAAO,OAAO,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAgB;AAC7B;AACA,wCAAwC,UAAU,OAAO,UAAU;AACnE;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,GAAG,SAAS,GAAG,UAAU;AACzD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACb;AACI;AACpC;AACP,iBAAiB,iEAAkB;AACnC,kCAAkC;AAClC;AACA,MAAM,eAAe;AACrB,MAAM,eAAe;AACrB,MAAM,eAAe;;AAErB;AACA;AACA;AACA,KAAK;AACL,WAAW,2DAA6B;AACxC;AACO;AACP;AACA;AACA,WAAW,iEAAmC;AAC9C;AACO;AACP;AACA;AACA,WAAW,gEAAkC;AAC7C;AACA;AACA,IAAI,4DAA8B;AAClC,oBAAoB,sDAAwB;AAC5C;AACA,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B;AACA;AACO;AACP;AACA;AACO;AACP,4BAA4B,+EAAiD;AAC7E;AACA;AACO;AACP;AACA;AACO;AACP,4BAA4B,+EAAiD;AAC7E;AACA;AACO;AACP;AACA;AACO;AACP,4BAA4B,+EAAiD;AAC7E;AACA;AACO;AACP;AACA;AACO;AACP,4BAA4B,6EAA+C;AAC3E;AACA;AACO;AACP;AACA;AACO;AACP,4BAA4B,6EAA+C;AAC3E;AACA;AACO;AACP,wBAAwB;AACxB,2BAA2B;AAC3B,qCAAqC;AACrC,IAAI,qDAAuB;AAC3B,oBAAoB,2EAA6C;AACjE;AACA,QAAQ,2EAA6C;AACrD;AACO;AACP,IAAI,qDAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B;AACO;AACP,IAAI,qDAAuB;AAC3B;AACA,QAAQ,qDAAuB;AAC/B;AACA;AACA,QAAQ,qDAAuB;AAC/B;AACA,IAAI,qDAAuB;AAC3B;AACO;AACP;AACA;AACA,IAAI,qDAAuB;AAC3B;AACA;AACA;AACA;AACA,IAAI,qDAAuB;AAC3B;AACA;AACA,IAAI,qDAAuB;AAC3B,IAAI,qDAAuB;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,+EAAiD;AACpE;AACA,0CAA0C,yEAA2C;AACrF,IAAI,qDAAuB;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA,4CAA4C,4EAA8C;AAC1F;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,qDAAuB;AAC3B;AACA;AACA,sC;;;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,mHAAmH;AAClI,eAAe,YAAY;AAC3B;AACA,qBAAqB,iEAAkB;AACvC;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC,6BAA6B,UAAU;AACvC;AACA,gCAAgC;AAChC,yBAAyB;;AAEzB,4BAA4B,eAAe,YAAY,eAAe;AACtE,0CAA0C,SAAS,OAAO,aAAa,KAAK;AAC5E,6BAA6B,eAAe,YAAY,iBAAiB;;AAEzE,sBAAsB,mBAAmB;;AAEzC,qDAAqD,SAAS,OAAO,YAAY,MAAM,KAAK;AAC5F,+BAA+B,cAAc,0BAA0B,iBAAiB,OAAO,WAAW;;AAE1G,wBAAwB,mBAAmB;;AAE3C,2CAA2C,WAAW;;AAEtD,sBAAsB,eAAe;AACrC;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,UAAU;;AAEV,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;AACS;AAChC,iC;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AACZ;AACa;AACpB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wFAAqC;AAC5D,wBAAwB;AACxB,wBAAwB,4DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wFAAqC;AAC5D,wBAAwB,yEAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,0FAAuC;AAC3C,SAAS,0DAAG;AACZ;AACA,wCAAwC,yFAAsC;AAC9E,uBAAuB,qEAAkB;AACzC,oBAAoB,yDAAO,EAAE,UAAU,IAAI,mBAAmB,sBAAsB,EAAE;AACtF;AACA;AACA;AACA,yBAAyB,yDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AAChD,qCAAqC;AAC9B;AACP,wBAAwB,wDAAc;AACtC;AACA,YAAY;AACZ;AACA,+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACN;AACa;AAClB;AACsB;AACZ;AACZ;AACK;AACS;AACI;AACtD,wDAAwD;AACxD;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,mDAAmD;AACpF,aAAa,kBAAkB;AAC/B,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAG;AAC1C;AACA;AACA,0BAA0B,qEAAoB;AAC9C;AACA;AACA,0BAA0B,wDAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,sGAAsG;AACxI,aAAa,kBAAkB;AAC/B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAe;AACnD,iFAAiF,iEAAU;AAC3F,aAAa;AACb,kCAAkC,yDAAO,EAAE,UAAU,aAAa,yBAAyB;AAC3F;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAG;AAC1C;AACA;AACA;AACA,0BAA0B,uEAAqB;AAC/C;AACA;AACA,0BAA0B,0DAAe;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,uDAAsB;AACzC;AACA,eAAe,gDAAe;AAC9B;AACA;AACA;AACA,mBAAmB,qDAAoB;AACvC;AACA,eAAe,8CAAa;AAC5B;AACA;AACA;AACA,mBAAmB,oDAAmB;AACtC;AACA,eAAe,6CAAY;AAC3B;AACA;AACA;AACA,mBAAmB,sDAAqB;AACxC;AACA,eAAe,+CAAc;AAC7B;AACA;AACA;AACA,mBAAmB,wDAAY;AAC/B;AACA,eAAe,iDAAK;AACpB;AACA;AACA;AACA,mBAAmB,gEAAgB;AACnC;AACA,eAAe,yDAAS;AACxB;AACA,kCAAkC,WAAW;AAC7C;AACA,8C;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACX;AACI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wFAAqC;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,4BAA4B;AAC/C,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA,oBAAoB,kDAAW,EAAE,qDAAqD;AACtF,oBAAoB,kDAAW,EAAE,qDAAqD;AACtF;AACA;AACA,0BAA0B,sDAAa,EAAE,qDAAqD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACJ;AAClD;AACP,0BAA0B,wDAAW;AACrC,WAAW,wDAAW;AACtB;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAW;AACvC,WAAW,wDAAW;AACtB,wBAAwB,qEAAoB;AAC5C;AACA;AACA,YAAY;AACZ;AACA,mC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmE;AACnE,OAAO,6wBAA6wB,GAAG,qEAAM;AACjW;AAC5b,kC;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACS;AACV;AACa;AAC7D,2BAA2B;AACpB;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA,0BAA0B,sEAAgB;AAC1C;AACA;AACA;AACA,QAAQ,0DAAG;AACX,sBAAsB,qEAAoB;AAC1C;AACA;AACA,sBAAsB,wDAAc;AACpC;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AAClB;AACnD,aAAa,2DAAiB;AAC9B;AACA;AACA;AACA;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AAClB;AACnD,cAAc,2DAAiB;AAC/B;AACA,kCAAkC;AAC3B,cAAc,iFAAe,EAAE,mBAAmB;AAClD;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AAC0B;AACR;AAC9D,0BAA0B;AACnB,sBAAsB,kFAAgB;AAC7C;AACA;AACA;AACA,mBAAmB,4DAAM;AACzB,CAAC;AACM;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACpB;AACa;AACjB;AAC/B;AACP,WAAW,kBAAkB;AAC7B;AACA;AACA,eAAe,mDAAQ,EAAE,UAAU,gBAAgB,WAAW;AAC9D;AACA;AACA,yBAAyB,0DAAG;AAC5B;AACA,+BAA+B,8CAA8C;AAC7E,gCAAgC,2CAA2C;AAC3E,qBAAqB,yCAAyC;AAC9D;AACA,+DAA+D,iEAAU;AACzE;AACA;AACA,wBAAwB,0DAAG;AAC3B;AACA,YAAY,+DAAiB;AAC7B,YAAY,kDAAW;AACvB;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AAChB;AACZ;AACI;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,iBAAiB;AAC5B;AACA,qBAAqB,sEAAmB;AACxC;AACA,yBAAyB,kFAA+B;AACxD;AACA;AACA,oBAAoB,qDAAS,EAAE,UAAU,IAAI,mBAAmB,qBAAqB,EAAE;AACvF,eAAe,gFAA6B;AAC5C;AACA,IAAI,0FAAuC;AAC3C,oCAAoC,yFAAsC;AAC1E,mBAAmB,qEAAkB;AACrC,gBAAgB,iDAAO,EAAE,UAAU,eAAe,mBAAmB,sBAAsB,EAAE;AAC7F,oBAAoB,4DAAM;AAC1B;AACA;AACA,yBAAyB,oFAAiC;AAC1D,cAAc,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACrF;AACA;AACA,cAAc,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AAChB;AACZ;AACI;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,iBAAiB;AAC5B;AACA,qBAAqB,sEAAmB;AACxC;AACA,yBAAyB,kFAA+B;AACxD;AACA;AACA,oBAAoB,qDAAS,EAAE,UAAU,IAAI,mBAAmB,qBAAqB,EAAE;AACvF,eAAe,gFAA6B;AAC5C;AACA,IAAI,0FAAuC;AAC3C,oCAAoC,yFAAsC;AAC1E,mBAAmB,qEAAkB;AACrC,gBAAgB,iDAAO,EAAE,UAAU,eAAe,mBAAmB,sBAAsB,EAAE;AAC7F,oBAAoB,4DAAM;AAC1B;AACA;AACA,yBAAyB,oFAAiC;AAC1D,cAAc,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACrF;AACA;AACA,cAAc,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmE;AACL;AACtB;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,eAAe,sEAAmB;AAClC,yBAAyB,kFAA+B;AACxD;AACA;AACA;AACA,aAAa,qDAAS,EAAE,UAAU,IAAI,mBAAmB,qBAAqB,EAAE;AAChF;AACA,eAAe,gFAA6B;AAC5C;AACA,IAAI,0FAAuC;AAC3C,gBAAgB,0EAAe;AAC/B;AACA;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmE;AACL;AACtB;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,eAAe,sEAAmB;AAClC,yBAAyB,kFAA+B;AACxD;AACA;AACA;AACA,aAAa,qDAAS,EAAE,UAAU,IAAI,mBAAmB,qBAAqB,EAAE;AAChF;AACA,eAAe,gFAA6B;AAC5C;AACA,IAAI,0FAAuC;AAC3C,gBAAgB,0EAAe;AAC/B;AACA;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AAClB;AACnD,aAAa,2DAAiB;AAC9B;AACA;AACA;AACA;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AAClB;AACnD,cAAc,2DAAiB,sCAAsC;AAC9D,cAAc,iFAAe,EAAE,mBAAmB;AAClD;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AAClB;AACnD,aAAa,2DAAiB;AAC9B;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACmF;AACjI,cAAc,sFAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6FAA+B;AACnC;AACA;AACO,cAAc,kFAAgB,EAAE,kDAAkD;AAClF;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AAClB;AACnD,cAAc,2DAAiB;AAC/B;AACA,2CAA2C;AACpC,cAAc,iFAAe,EAAE,mBAAmB;AAClD;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACxB;AACK;AACX;AAC/B;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,IAAI,6DAAgB;AACpB,WAAW,4CAA4C;AACvD;AACA,IAAI,8DAAW,CAAC,8FAA2C;AAC3D,uBAAuB,QAAQ,kBAAkB,UAAU;AAC3D,qBAAqB,iFAA8B;AACnD;AACA,QAAQ,mEAAgB;AACxB,eAAe,mDAAQ,EAAE,UAAU,IAAI,WAAW;AAClD;AACA,+BAA+B,oDAAa;AAC5C;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AACpB;AACrC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,wDAAwD;AACnE;AACA,qBAAqB,iFAA8B;AACnD,+BAA+B,oDAAa;AAC5C;AACA;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACA;AAC7D;AACP,WAAW,yBAAyB;AACpC,WAAW,YAAY;AACvB;AACA,WAAW,4CAA4C;AACvD;AACA,qBAAqB,iFAA8B;AACnD,uCAAuC,4EAAwB;AAC/D;AACA;AACO;AACP,gBAAgB,gEAAa;AAC7B;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACE;AACnB;AAC1C;AACP,WAAW,yBAAyB;AACpC,WAAW,YAAY;AACvB;AACA,IAAI,6DAAgB;AACpB,WAAW,2BAA2B;AACtC,qBAAqB,iFAA8B;AACnD,uCAAuC,4EAAwB;AAC/D;AACA;AACO;AACP,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACC;AAC9C;AACP,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,WAAW,yBAAyB;AACpC,WAAW,kEAAe,EAAE,wCAAwC;AACpE;AACO;AACP,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACyB;AACvB;AACrB;AACF;AACR;AACY;AACxC;AACA;AACA;AACO;AACA,0BAA0B,2HAA2H;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAkB;AACxC,sBAAsB,qEAAkB;AACxC;AACA,IAAI,8DAAW;AACf;AACA,gCAAgC,WAAW,SAAS,WAAW;AAC/D;AACA;AACA,IAAI,8DAAW,sEAAsE,YAAY;AACjG,WAAW,YAAY,2BAA2B,QAAQ;AAC1D,WAAW,QAAQ,kBAAkB,WAAW;AAChD,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAO,EAAE,UAAU,OAAO,mBAAmB,kBAAkB,EAAE;AACjF,gBAAgB,iDAAO,EAAE,UAAU,OAAO,mBAAmB,kBAAkB,EAAE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8FAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAS,EAAE,UAAU,SAAS,mBAAmB,kBAAkB,EAAE;AACxF;AACA;AACA;AACA,mBAAmB,qDAAS,EAAE,UAAU,SAAS,mBAAmB,kBAAkB,EAAE;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAO;AAC5B,yBAAyB,UAAU;AACnC;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAO;AAC5B,yBAAyB,UAAU;AACnC;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,wBAAwB,mDAAQ,EAAE,UAAU,uBAAuB,WAAW;AAC9E,cAAc,yCAAG,EAAE,UAAU,aAAa,mBAAmB,uBAAuB,EAAE;AACtF;AACA;AACA;AACA,sBAAsB,iEAAU;AAChC,4BAA4B,mEAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,yEAAsB;AAChG;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,kBAAkB,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACd;AACa;AAC1D,oBAAoB,yBAAyB;AACpD,WAAW,mCAAmC;AAC9C,IAAI,8DAAW;AACf;AACA,IAAI,8DAAW;AACf;AACA,IAAI,8DAAW;AACf;AACA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAG;AACvB,YAAY,yEAAsB;AAClC,YAAY,4DAAgB;AAC5B;AACA;AACA;AACO;AACP,gBAAgB,iEAAc;AAC9B;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2E;AACvC;AACJ;AACQ;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,oBAAoB;AAC/B,IAAI,8DAAW;AACf;AACA;AACA,qBAAqB,2EAAwB;AAC7C,qBAAqB,2EAAwB;AAC7C,6BAA6B,mFAAgC;AAC7D,6BAA6B,mFAAgC;AAC7D,sBAAsB,4EAAyB;AAC/C;AACA,iCAAiC,iDAAO,EAAE,UAAU,IAAI,mBAAmB,kBAAkB,EAAE;AAC/F,mCAAmC,qDAAS,EAAE,UAAU,0BAA0B,mBAAmB,iBAAiB,EAAE;AACxH,kCAAkC,iDAAO;AACzC,iBAAiB,4BAA4B;AAC7C;AACA,gBAAgB;AAChB,KAAK;AACL,mBAAmB,6CAAK;AACxB,iBAAiB,2BAA2B;AAC5C;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,iEAAc;AAC9B;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACQ;AAClD;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA,oBAAoB,qEAAe;AACnC;AACA;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACO;AACf;AACE;AACA;AACR;AACY;AACnC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,QAAQ;AACnB;AACA;AACA;AACA,mBAAmB,mDAAQ,EAAE,UAAU,IAAI,WAAW;AACtD;AACA;AACA,4BAA4B,wDAAQ;AACpC,6BAA6B,UAAU,IAAI,mBAAmB,mBAAmB,EAAE;AACnF,uBAAuB,iDAAO,EAAE,UAAU,kCAAkC,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC/D,6BAA6B,UAAU,cAAc,mBAAmB,QAAQ,EAAE;AAClF;AACA;AACA;AACA,SAAS,uEAAoB;AAC7B;AACA;AACA,uBAAuB,mDAAQ,EAAE,UAAU,IAAI,WAAW;AAC1D,gBAAgB;AAChB;AACA;AACA,eAAe,sDAAG;AAClB;AACA;AACA,mEAAmE,8EAA2B;AAC9F,8BAA8B;AAC9B,uBAAuB,mDAAQ,EAAE,gCAAgC;AACjE;AACA;AACA;AACA,qDAAqD,QAAQ,MAAM,MAAM;AACzE;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AAChB;AACrD,6BAA6B;AACtB,aAAa,iFAAe,EAAE,wDAAwD,6DAAW,EAAE;AACnG;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACf;AACa;AAChD;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,6BAA6B;AACxC;AACA,QAAQ,0DAAG;AACX,sBAAsB,+DAAiB;AACvC;AACA;AACA,sBAAsB,kDAAW;AACjC;AACA;AACA;AACA;AACO;AACP,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACV;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;AACA,2BAA2B,mDAAQ,EAAE,UAAU,UAAU,WAAW;AACpE;AACA;AACA,2BAA2B,mDAAQ,EAAE,UAAU,UAAU,WAAW;AACpE;AACA;AACA,kCAAkC;AAClC;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA,wBAAwB,+DAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmE;AACxB;AACL;AAC/B;AACP,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,kBAAkB,sEAAmB;AACrC,qBAAqB,+EAA4B;AACjD,QAAQ,qEAAkB;AAC1B;AACA;AACA;AACA,uCAAuC,qEAAkB;AACzD;AACA,eAAe,mDAAQ,EAAE,UAAU,gBAAgB,WAAW;AAC9D;AACA;AACA,IAAI,sFAAmC;AACvC,WAAW,wDAAU;AACrB;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AAClB;AACa;AACJ;AACnB;AACN;AACA;AACM;AAC7B;AACP;AACA;AACA,wCAAwC,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC9E,wCAAwC,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC9E;AACA;AACA,uBAAuB,iDAAO,EAAE,UAAU,yCAAyC,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,wBAAwB,mEAAa;AACrC,8BAA8B,+EAA4B;AAC1D;AACA;AACA;AACA;AACA,wBAAwB,0DAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA,4BAA4B,mEAAmB;AAC/C;AACA;AACA,WAAW,sBAAsB;AACjC,wBAAwB,sDAAa;AACrC;AACA;AACA,2BAA2B,iDAAO,EAAE,UAAU,YAAY,UAAU,kBAAkB,WAAW;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAA4B;AACjD,sCAAsC,iDAAO;AAC7C,iBAAiB,IAAI;AACrB,gBAAgB,aAAa,qEAAkB,wBAAwB;AACvE;AACA,KAAK;AACL,YAAY;AACZ;AACA,uC;;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACtB;AACqB;AAC7B;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,YAAY;AACvB,WAAW,uDAAuD;AAClE,wBAAwB,uFAAoC;AAC5D,qBAAqB,iFAA8B;AACnD;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAc,EAAE,+BAA+B;AAC7D;AACA,aAAa,0DAAG;AAChB,cAAc,8DAAgB,EAAE,+BAA+B;AAC/D;AACA;AACA,4BAA4B,oDAAa;AACzC;AACA;AACA,wBAAwB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,2BAA2B,EAAE;AACpG;AACA;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2E;AACb;AACvD;AACP,WAAW,yBAAyB;AACpC,WAAW,QAAQ;AACnB,WAAW,yDAAyD;AACpE,wBAAwB,uFAAoC;AAC5D,qBAAqB,iFAA8B;AACnD,wBAAwB,sEAAsB;AAC9C;AACA;AACO;AACP,gBAAgB,uEAAoB;AACpC;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACb;AACtD;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,wDAAwD;AACnE,wBAAwB,uFAAoC;AAC5D,qBAAqB,iFAA8B;AACnD,wBAAwB,qEAAqB;AAC7C;AACA;AACO;AACP,gBAAgB,sEAAmB;AACnC;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACS;AACuB;AACvB;AACf;AACsC;AAC5C;AACF;AACpC;AACA;AACA;AACO,yBAAyB,kHAAkH;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0EAA2B;AACrD;AACA,sCAAsC,0DAAG;AACzC,SAAS,0DAAG;AACZ;AACA;AACA;AACA,0BAA0B,iDAAO;AACjC,qBAAqB,IAAI;AACzB;AACA,oBAAoB;AACpB,SAAS;AACT,+BAA+B,iDAAO;AACtC,qBAAqB,YAAY;AACjC;AACA,oBAAoB;AACpB,SAAS;AACT,uBAAuB,kEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,cAAc,iDAAO,EAAE,UAAU,YAAY,mBAAmB,2BAA2B,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAW,CAAC,sDAAwB,2DAA2D,eAAe,MAAM,gBAAgB;AAC5I,+BAA+B,iDAAO;AACtC,qBAAqB,YAAY;AACjC;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,8BAA8B,kEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,8DAAW;AACnB;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAQ,EAAE,UAAU,mBAAmB,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,kHAAkH;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yEAAyE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAO,EAAE,UAAU,IAAI,mBAAmB,0BAA0B,EAAE;AAC5F,kBAAkB,iDAAO;AACzB,iBAAiB,YAAY;AAC7B;AACA,gBAAgB,uBAAuB,qEAAkB;AACzD,KAAK;AACL;AACA;AACA,8BAA8B,mEAAmB;AACjD;AACA,2BAA2B,iDAAO;AAClC,iBAAiB,YAAY;AAC7B;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC,8FAA4B;AACrE,8BAA8B,mEAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,yEAAsB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACjB;AACrC;AACP,WAAW,yBAAyB;AACpC,WAAW,YAAY;AACvB,WAAW,0BAA0B;AACrC,qBAAqB,iFAA8B;AACnD,wBAAwB,oDAAa;AACrC;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6E;AACf;AACvD;AACP,WAAW,yBAAyB;AACpC,WAAW,QAAQ;AACnB,WAAW,4BAA4B;AACvC,qBAAqB,iFAA8B;AACnD,wBAAwB,sEAAsB;AAC9C;AACA;AACO;AACP,gBAAgB,yEAAsB;AACtC;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4E;AACf;AACtD;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,2BAA2B;AACtC,qBAAqB,iFAA8B;AACnD,wBAAwB,qEAAqB;AAC7C;AACA;AACO;AACP,gBAAgB,wEAAqB;AACrC;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACkD;AAC9F,YAAY,qFAAuB;AACnC;AACA;AACO,YAAY,iFAAe,EAAE,iBAAiB;AAC9C;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AACrE;AACA;AACA;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACQ;AACvD;AACP,WAAW,yBAAyB;AACpC,WAAW,uBAAuB;AAClC,WAAW,uCAAuC;AAClD,wBAAwB,sEAAoB;AAC5C;AACA;AACO;AACP,gBAAgB,gEAAa;AAC7B;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACf;AACR;AACE;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,2BAA2B;AACtC;AACA,wBAAwB,kFAA+B;AACvD;AACA;AACA,oBAAoB,qDAAS,EAAE,UAAU,IAAI,mBAAmB,oBAAoB,EAAE;AACtF;AACA,yBAAyB,gFAA6B;AACtD;AACA,0EAA0E,mBAAmB;AAC7F,4BAA4B,KAAK;AACjC;AACA;AACA,iBAAiB,mDAAQ,EAAE,UAAU,eAAe,WAAW;AAC/D;AACA;AACA,mBAAmB,qCAAqC;AACxD,4BAA4B,sDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAa;AACzC;AACA;AACA;AACA;AACA;AACA,mCAAmC,sFAAmC;AACtE,wCAAwC,qDAAS,EAAE,UAAU,YAAY,mBAAmB,2BAA2B,EAAE;AACzH;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC0B;AACzE;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,wBAAwB,qEAAe;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAqB;AAC5C;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACO;AACP,gBAAgB,gEAAa;AAC7B;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACC;AACrD;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,wBAAwB;AACnC,IAAI,8DAAW,4EAA4E,UAAU;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAmB;AAC3C;AACA;AACO;AACP,gBAAgB,+DAAY;AAC5B;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuF;AACxB;AACa;AACrE;AACP,WAAW,yBAAyB;AACpC,WAAW,YAAY;AACvB,WAAW,2CAA2C;AACtD;AACA;AACA;AACA;AACA,IAAI,8DAAW,CAAC,8FAA2C;AAC3D,0BAA0B,QAAQ,kBAAkB,WAAW;AAC/D,qBAAqB,iFAA8B;AACnD;AACA,QAAQ,0DAAG;AACX;AACA,sBAAsB,oFAA4B;AAClD;AACA;AACA,sBAAsB,uEAAsB;AAC5C;AACA;AACA;AACO;AACP,gBAAgB,wEAAqB;AACrC;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0F;AACT;AAC1E;AACP,WAAW,yBAAyB;AACpC,WAAW,QAAQ;AACnB,WAAW,wDAAwD;AACnE,qBAAqB,iFAA8B;AACnD,wBAAwB,yFAA+B;AACvD;AACA;AACO;AACP,gBAAgB,sFAAmC;AACnD;AACA;AACA;AACA,+D;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyF;AACT;AACzE;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,uDAAuD;AAClE,qBAAqB,iFAA8B;AACnD,wBAAwB,wFAA8B;AACtD;AACA;AACO;AACP,gBAAgB,qFAAkC;AAClD;AACA;AACA;AACA,8D;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACT;AACN;AAC7B;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA,kBAAkB,qEAAkB;AACpC,iBAAiB,iDAAO,EAAE,UAAU,IAAI,mBAAmB,iBAAiB,EAAE;AAC9E,wBAAwB,kDAAW;AACnC;AACA,gBAAgB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,kBAAkB,EAAE;AACnF;AACA;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AACb;AAChB;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,YAAY;AACvB,WAAW,0BAA0B;AACrC,qBAAqB,qFAAkC;AACvD;AACA,wBAAwB,4DAAiB;AACzC;AACA,wBAAwB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,2BAA2B,EAAE;AACpG;AACA;AACA;AACO;AACP,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACyB;AACrE,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,iFAAe,EAAE,8CAA8C;AACpE;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACH;AACa;AAC/D,uDAAuD;AACvD;AACA;AACA;AACA;AACO;AACP,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,oBAAoB,0DAAG;AACvB,YAAY,uEAAqB;AACjC,YAAY,0DAAe;AAC3B;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACwB;AACtE;AACA;AACA;AACA,oCAAoC;AAC7B,cAAc,kFAAgB,EAAE,iEAAiE;AACjG;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACW;AACrE;AACA;AACA;AACA;AACA,cAAc,qEAAkB;AAChC,eAAe,sEAAmB;AAClC,eAAe,sEAAmB;AAClC,eAAe,sEAAmB;AAClC,eAAe,sEAAmB;AAClC,eAAe,sEAAmB;;AAElC;AACA;AACA;AACA;AACA;AACO,YAAY,iFAAe,EAAE,iBAAiB;AAC9C;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACyB;AACjB;AAC7C,2BAA2B;AAC3B,YAAY,iFAAe,EAAE,sDAAsD,4DAAU,EAAE;AAC/F;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACrB;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAW,iEAAiE,iBAAiB,IAAI,UAAU;AACnH;AACA;AACA;AACA,WAAW,iDAAO,EAAE,UAAU,WAAW,mBAAmB,kBAAkB,EAAE;AAChF;AACO;AACP,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AACf;AACtD,mCAAmC;AAC5B,cAAc,iFAAe,EAAE,0DAA0D,8DAAY,EAAE;AACvG;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACP;AAC9B;AACP,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,WAAW,kDAAO;AAClB;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACL;AACJ;AACA;AAC7B;AACP;AACA,sBAAsB,qEAAkB;AACxC;AACA;AACA;AACA,oBAAoB,iDAAO,EAAE,UAAU,IAAI,mBAAmB,qCAAqC,EAAE;AACrG;AACA,4BAA4B,gDAAU;AACtC,4BAA4B,gDAAU;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAO,EAAE,UAAU,iCAAiC,WAAW;AACzF;AACA;AACA,kCAAkC,iDAAO,EAAE,UAAU,mBAAmB,mBAAmB,iBAAiB,EAAE;AAC9G;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACT;AACnC;AACP,WAAW,iBAAiB;AAC5B,WAAW,eAAe;AAC1B,SAAS,QAAQ;AACjB,qBAAqB,kEAAe;AACpC;AACA;AACA,uBAAuB,yEAAsB,QAAQ,qEAAkB;AACvE;AACA;AACA;AACA;AACA,4BAA4B,kDAAW;AACvC;AACA;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACQ;AACvD;AACP,gBAAgB,gEAAa;AAC7B;AACA,kBAAkB,kBAAkB;AACpC,eAAe,QAAQ;AACvB;AACA,4BAA4B,sEAAoB;AAChD;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AACf;AACtD,+BAA+B;AACxB,cAAc,iFAAe,EAAE,0DAA0D,8DAAY,EAAE;AACvG;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB,kFAAgB,EAAE,sEAAsE;AACzG;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACO;AACR;AAC4B;AACa;AAC7E;AACP,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,SAAS,SAAS;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0DAAmB;AAC3E;AACA,oBAAoB,0DAAG;AACvB,YAAY,6FAAuB;AACnC,YAAY,gFAAiB;AAC7B;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACjD;AACP;AACA;AACA,qBAAqB,iEAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM,MAAM,OAAO;;AAE1E,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACjD;AACP;AACA;AACA;AACA;AACA,qBAAqB,iEAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,QAAQ;AAC9B,wBAAwB,QAAQ;AAChC;AACA;;AAEA;AACA,8BAA8B,MAAM,MAAM,OAAO;AACjD,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6E;AACjC;AACsC;AACjB;AAC7B;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,0CAA0C;AACrD,WAAW,mFAAmF;AAC9F,wBAAwB,uFAAoC;AAC5D,qBAAqB,iFAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa,0DAAG;AAChB,cAAc,8DAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6CAA6C,8FAA4B;AACzE,4BAA4B,oDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,yEAAsB;AAChG;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,2BAA2B,EAAE;AACpG;AACA;AACA;AACA;AACO;AACP,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsF;AACvB;AACa;AACM;AAC3E;AACP,WAAW,yBAAyB;AACpC,WAAW,0CAA0C;AACrD,WAAW,uEAAuE;AAClF;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAW,CAAC,8FAA2C;AAC3D,0BAA0B,QAAQ,kBAAkB,WAAW;AAC/D,qBAAqB,iFAA8B;AACnD,oCAAoC,0DAAG;AACvC;AACA;AACA;AACA,QAAQ,8FAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,yEAAsB;AAC5F;AACA;AACA;AACA;AACA;AACA,sBAAsB,oFAA4B;AAClD;AACA;AACA,sBAAsB,uEAAsB;AAC5C;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,uEAAoB;AACpC;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AAClB;AACf;AAC7B;AACP,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA,yDAAyD,kFAA+B;AACxF,2BAA2B,iDAAO,EAAE,UAAU,aAAa,mBAAmB,gCAAgC,EAAE;AAChH,qBAAqB,iDAAO;AAC5B,iBAAiB,YAAY;AAC7B;AACA,gBAAgB,UAAU,qEAAkB;AAC5C,KAAK;AACL,wBAAwB,2DAAe;AACvC;AACA,qBAAqB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,qBAAqB,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACvB;AACW;AACrB;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,kBAAkB;AAC7B,uBAAuB,sEAAmB;AAC1C,sBAAsB,qGAAkD;AACxE,wBAAwB,qEAAkB;AAC1C;AACA,qBAAqB,iDAAO;AAC5B,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,iDAAO;AAChC,iBAAiB,aAAa;AAC9B;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAe;AACtC;AACA;AACA;AACA,wBAAwB,sDAAa;AACrC;AACA;AACA,qBAAqB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,+BAA+B,EAAE;AACrG;AACA;AACA;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACsB;AACd;AACxD,qCAAqC;AACrC;AACA;AACA;AACO,gBAAgB,kFAAgB;AACvC;AACA;AACA,mBAAmB,gEAAc;AACjC;AACA,CAAC;AACM;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACiB;AACtE,4CAA4C;AAC5C;AACA;AACA;AACO,qBAAqB,kFAAgB;AAC5C;AACA;AACA;AACA,CAAC;AACM;AACP,gBAAgB,+DAAY;AAC5B;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACR;AAC9B;AACP,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,WAAW,kDAAO;AAClB;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AAC1C;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA,YAAY;AACZ;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACP;AAC/B;AACP,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB;AACA,WAAW,mDAAQ,EAAE,UAAU,uCAAuC,WAAW;AACjF;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACoB;AACrE,wDAAwD;AACjD,iBAAiB,iFAAe,EAAE,sCAAsC;AACxE;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AACrE,uCAAuC;AAChC,cAAc,iFAAe,EAAE,mCAAmC;AAClE;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AACrE,uCAAuC;AAChC,cAAc,iFAAe,EAAE,mCAAmC;AAClE;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACT;AACa;AAC9C;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,iCAAiC;AAC5C,oBAAoB,0DAAG;AACvB,YAAY,6DAAgB;AAC5B,YAAY,gDAAU;AACtB;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACC;AAC1C;AACP,WAAW,yBAAyB;AACpC,WAAW,WAAW;AACtB,WAAW,iCAAiC;AAC5C,wBAAwB,yDAAc;AACtC;AACA;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACX;AACa;AACxD,+CAA+C;AAC/C;AACP;AACA;AACA;AACO;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,QAAQ;AACnB,yDAAyD,yEAAsB;AAC/E,oBAAoB,0DAAG;AACvB,YAAY,uEAAqB;AACjC,YAAY,0DAAe;AAC3B;AACA;AACA;AACA;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACyB;AACjB;AACrD,kCAAkC;AAClC;AACA;AACA;AACO,aAAa,kFAAgB;AACpC;AACA;AACA,mBAAmB,6DAAW;AAC9B;AACA,CAAC;AACM;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACoB;AAC/D,yCAAyC;AACzC;AACP;AACA;AACO,kBAAkB,kFAAgB,EAAE,2EAA2E;AAC/G;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACQ;AAClD;AACP,WAAW,iBAAiB;AAC5B,WAAW,mBAAmB;AAC9B;AACA,oBAAoB,qEAAe;AACnC;AACA;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACyB;AACjB;AACpD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO,YAAY,iFAAe,EAAE,6DAA6D,4DAAU,EAAE;AACtG;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AACrE,mCAAmC;AAC5B,cAAc,iFAAe,EAAE,mBAAmB;AAClD;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACmB;AACtE,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACO,mBAAmB,kFAAgB;AAC1C;AACA;AACA;AACA,CAAC;AACM;AACP,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACkB;AACrE,+CAA+C;AACxC,mBAAmB,iFAAe,EAAE,yBAAyB;AAC7D;AACP,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACoB;AACtE,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,kFAAgB,EAAE,2EAA2E;AAC/G;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACe;AACP;AACf;AAC8B;AAC5D;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,6BAA6B;AACxC;AACA,qBAAqB,sEAAmB;AACxC;AACA,yBAAyB,kFAA+B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA,mCAAmC,iEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAa;AACpC;AACA,eAAe,gFAA6B;AAC5C;AACA,IAAI,0FAAuC;AAC3C,uCAAuC,yFAAsC;AAC7E;AACA;AACA;AACA,mBAAmB,oFAAiC;AACpD;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAU,SAAS,qEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACxB;AACK;AACX;AAC/B;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,IAAI,6DAAgB;AACpB,WAAW,4CAA4C;AACvD;AACA,IAAI,8DAAW,CAAC,8FAA2C;AAC3D,uBAAuB,QAAQ,kBAAkB,UAAU;AAC3D,qBAAqB,iFAA8B;AACnD;AACA,QAAQ,mEAAgB;AACxB,eAAe,mDAAQ,EAAE,UAAU,IAAI,WAAW;AAClD;AACA,+BAA+B,oDAAa;AAC5C;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AACpB;AACrC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,wDAAwD;AACnE;AACA,qBAAqB,iFAA8B;AACnD,+BAA+B,oDAAa;AAC5C;AACA;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACA;AACxB;AACrC;AACP,WAAW,yBAAyB;AACpC,WAAW,YAAY;AACvB;AACA,WAAW,4CAA4C;AACvD;AACA,qBAAqB,iFAA8B;AACnD,0CAA0C,oDAAa;AACvD;AACA,uCAAuC,4EAAwB;AAC/D;AACA;AACA;AACA;AACO;AACP,gBAAgB,gEAAa;AAC7B;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACE;AACxB;AACK;AAC1C;AACP,WAAW,yBAAyB;AACpC,WAAW,oBAAoB;AAC/B;AACA,IAAI,6DAAgB;AACpB,WAAW,4CAA4C;AACvD,qBAAqB,iFAA8B;AACnD;AACA,wCAAwC,oDAAa;AACrD;AACA,uCAAuC,4EAAwB;AAC/D;AACA;AACA;AACA;AACO;AACP,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACC;AACM;AAC1D;AACP,gBAAgB,oEAAiB;AACjC;AACA,kBAAkB,yBAAyB;AAC3C,eAAe,IAAI;AACnB,eAAe,gDAAgD;AAC/D;AACA,QAAQ,8DAAW,oFAAoF,eAAe;AACtH;AACA,QAAQ,8DAAW,CAAC,8FAA2C;AAC/D,2BAA2B,QAAQ,kBAAkB,UAAU;AAC/D,yBAAyB,iFAA8B;AACvD,kCAAkC,8EAAqB;AACvD;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACrC;AACP,sBAAsB,oDAAa;AACnC;AACA,kBAAkB,oDAAa;AAC/B;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACG;AACH;AACtC;AACP,mBAAmB,qEAAkB;AACrC,kBAAkB,qEAAkB;AACpC;AACA,0BAA0B,yDAAO,EAAE,UAAU,IAAI,UAAU,6BAA6B,WAAW;AACnG,oBAAoB,4DAAM;AAC1B,2BAA2B,yDAAO,EAAE,UAAU,aAAa,UAAU,kBAAkB,WAAW;AAClG;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACI;AACmC;AACjB;AACd;AACxD,gBAAgB,4DAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mEAAwB;AAC5B;AACA;AACO,gBAAgB,kFAAgB;AACvC;AACA;AACA,mBAAmB,gEAAc;AACjC,CAAC;AACM;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AAC1B;AAC4B;AAC5D;AACP,gBAAgB,uDAAI;AACpB;AACA,kBAAkB,yBAAyB;AAC3C,eAAe,IAAI;AACnB,eAAe,iBAAiB;AAChC;AACA;AACA,yBAAyB,sEAAmB;AAC5C;AACA,6BAA6B,kFAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA,wCAAwC,iEAAgB;AACxD;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAa;AACzC;AACA;AACA,mBAAmB,gFAA6B;AAChD;AACA,QAAQ,0FAAuC;AAC/C,4CAA4C,yFAAsC;AAClF;AACA;AACA;AACA,uBAAuB,oFAAiC;AACxD;AACA,oBAAoB,oDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACG;AACH;AACtC;AACP,mBAAmB,qEAAkB;AACrC,kBAAkB,qEAAkB;AACpC;AACA,0BAA0B,yDAAO,EAAE,UAAU,IAAI,UAAU,6BAA6B,WAAW;AACnG,oBAAoB,4DAAM;AAC1B,2BAA2B,yDAAO,EAAE,UAAU,aAAa,UAAU,kBAAkB,WAAW;AAClG;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AAChB;AACZ;AACI;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,iBAAiB;AAC5B;AACA,qBAAqB,sEAAmB;AACxC;AACA,yBAAyB,kFAA+B;AACxD;AACA;AACA,oBAAoB,qDAAS,EAAE,UAAU,IAAI,mBAAmB,qBAAqB,EAAE;AACvF,eAAe,gFAA6B;AAC5C;AACA,IAAI,0FAAuC;AAC3C,oCAAoC,yFAAsC;AAC1E,mBAAmB,qEAAkB;AACrC,gBAAgB,iDAAO,EAAE,UAAU,eAAe,mBAAmB,sBAAsB,EAAE;AAC7F,oBAAoB,4DAAM;AAC1B;AACA;AACA,yBAAyB,oFAAiC;AAC1D,cAAc,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACrF;AACA;AACA,cAAc,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACI;AACmC;AACjB;AACd;AACxD,gBAAgB,4DAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mEAAwB;AAC5B;AACA;AACO,gBAAgB,kFAAgB;AACvC;AACA;AACA,mBAAmB,gEAAc;AACjC,CAAC;AACM;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACF;AACa;AAC3D,8BAA8B,yBAAyB;AAC9D,WAAW,IAAI;AACf,WAAW,iBAAiB;AAC5B,oBAAoB,0DAAG;AACvB,YAAY,0EAAsB;AAClC,YAAY,6DAAgB;AAC5B;AACA;AACA;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACe;AACW;AACtE;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,IAAI,mEAAiB;AACrB;AACA;AACO,YAAY,kFAAgB;AACnC;AACA;AACA,CAAC;AACM;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACI;AACpB;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,SAAS;AACpB,WAAW,+BAA+B;AAC1C;AACA;AACA,QAAQ,iDAAO,EAAE,UAAU,SAAS,mBAAmB,+BAA+B,EAAE;AACxF;AACA;AACA,wBAAwB,gEAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,8DAAW;AAC3B;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACJ;AACC;AACf;AACa;AACS;AACpC;AACpC,0BAA0B;AACnB;AACP,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,kBAAkB,0EAAuB;AACzC;AACA;AACA;AACA,gCAAgC,yEAAsB,CAAC,wEAA0C;AACjG,gCAAgC,yEAAsB,CAAC,wEAA0C;AACjG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAO,EAAE,UAAU,iCAAiC,WAAW;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qEAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX,sBAAsB,uEAAqB;AAC3C;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA;AACA;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACG;AACJ;AACa;AAC7D,uBAAuB;AACvB;AACA;AACO;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA;AACA,sCAAsC,gEAAU;AAChD;AACA;AACA;AACA,QAAQ,0DAAG;AACX,sBAAsB,qEAAoB;AAC1C;AACA;AACA,sBAAsB,wDAAc;AACpC;AACA;AACA;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwF;AACxF,gCAAgC,uFAAoC;AAC7D;AACP,IAAI,oEAAiB;AACrB;AACA,WAAW,yBAAyB;AACpC,WAAW,gBAAgB;AAC3B,WAAW,8CAA8C;AACzD;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACO;AACP,gBAAgB,sEAAmB;AACnC;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwF;AACxF,gCAAgC,uFAAoC;AAC7D;AACP,IAAI,oEAAiB;AACrB;AACA,WAAW,yBAAyB;AACpC,WAAW,gBAAgB;AAC3B,WAAW,kEAAkE;AAC7E;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,sEAAmB;AACnC;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwF;AACxF,gCAAgC,uFAAoC;AAC7D;AACP,IAAI,oEAAiB;AACrB;AACA,WAAW,yBAAyB;AACpC,WAAW,gBAAgB;AAC3B,WAAW,4DAA4D;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,sEAAmB;AACnC;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACqB;AACtE,wCAAwC;AACjC,iBAAiB,kFAAgB,EAAE,sCAAsC;AACzE;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACP;AACV;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,UAAU;AACrB,WAAW,2BAA2B;AACtC,wBAAwB,qEAAkB;AAC1C,wBAAwB,sDAAa;AACrC,qBAAqB,iDAAO,EAAE,UAAU,aAAa,mBAAmB,uBAAuB,EAAE;AACjG;AACA;AACA;AACA,gBAAgB,iDAAO,EAAE,UAAU,YAAY,mBAAmB,kBAAkB,EAAE;AACtF;AACA;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACb;AACN;AACA;AACA;AACU;AACjC;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA,yBAAyB,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC/D,4BAA4B,UAAU,cAAc,WAAW;AAC/D,yBAAyB,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC/D,kBAAkB,qDAAS,EAAE,UAAU,cAAc,WAAW;AAChE,uBAAuB,iDAAO,EAAE,UAAU,mBAAmB,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI,EAAE,SAAS,2CAA2C,WAAW;AACpF;AACA;AACO;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACjB;AACQ;AACnC;AACP,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB;AACA,eAAe,uDAAU,EAAE,UAAU,mBAAmB,mBAAmB,YAAY,EAAE;AACzF;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B,QAAQ,8DAAW;AACnB,KAAK;AACL;AACA;AACA,0BAA0B,uDAAU,EAAE,UAAU,WAAW,mBAAmB,YAAY,EAAE;AAC5F;AACA;AACA,KAAK;AACL,mBAAmB,+CAAM,EAAE,2CAA2C,OAAO,EAAE;AAC/E;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACX;AACa;AAC9C;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,0BAA0B;AACrC,oBAAoB,0DAAG;AACvB,YAAY,6DAAgB;AAC5B,YAAY,gDAAU;AACtB;AACA;AACO;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACe;AACW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,mEAAiB;AACrB;AACA;AACO,YAAY,kFAAgB,EAAE,8CAA8C;AAC5E;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACD;AACa;AACxD,2CAA2C;AAC3C;AACP;AACA;AACA;AACO;AACP,WAAW,kBAAkB;AAC7B,WAAW,WAAW;AACtB,oBAAoB,0DAAG;AACvB,YAAY,uEAAqB;AACjC,YAAY,0DAAe;AAC3B;AACA;AACO;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6E;AAC7B;AACK;AACjB;AACI;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,iBAAiB;AAC5B;AACA;AACA,qBAAqB,sEAAmB;AACxC;AACA,yBAAyB,kFAA+B;AACxD;AACA;AACA,oBAAoB,qDAAS,EAAE,UAAU,IAAI,mBAAmB,qBAAqB,EAAE;AACvF,eAAe,gFAA6B;AAC5C;AACA;AACA,IAAI,0FAAuC;AAC3C;AACA;AACA;AACA,eAAe,8BAA8B,GAAG,iEAAW;AAC3D;AACA;AACA;AACA,wCAAwC,yFAAsC;AAC9E,uBAAuB,qEAAkB;AACzC,oBAAoB,iDAAO,EAAE,UAAU,eAAe,mBAAmB,sBAAsB,EAAE;AACjG,4BAA4B,iEAAU;AACtC,wBAAwB,4DAAM;AAC9B,cAAc,iDAAO,EAAE,UAAU,aAAa,mBAAmB,kBAAkB,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA,yBAAyB,oFAAiC;AAC1D,cAAc,iDAAO,EAAE,UAAU,SAAS,mBAAmB,kBAAkB,EAAE;AACjF;AACA;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACQ;AAC/C;AACP,WAAW,iBAAiB;AAC5B,WAAW,2BAA2B;AACtC,mBAAmB,kEAAY;AAC/B;AACA;AACO;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACP;AAC/B;AACP,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB;AACA,WAAW,mDAAQ,EAAE,UAAU,uCAAuC,WAAW;AACjF;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO,gBAAgB,kFAAgB,EAAE,sEAAsE;AACxG;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACkB;AACrE,mCAAmC;AAC5B,mBAAmB,iFAAe,EAAE,wBAAwB;AAC5D;AACP,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AAClB;AACnD,aAAa,2DAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO,aAAa,iFAAe,EAAE,gDAAgD;AAC9E;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AAClB;AACnD,cAAc,2DAAiB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO,cAAc,iFAAe,EAAE,kDAAkD;AACjF;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACE;AACV;AACvC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,QAAQ;AACnB;AACA,kBAAkB,qEAAkB;AACpC,mBAAmB,8EAA2B;AAC9C,mBAAmB,qEAAkB;AACrC,IAAI,8DAAW,2CAA2C,OAAO,QAAQ,OAAO;AAChF,kBAAkB,QAAQ,QAAQ,MAAM;AACxC;AACA;AACA,8BAA8B,0DAAa;AAC3C,uCAAuC,0DAAa;AACpD,eAAe,oEAAa;AAC5B;AACA;AACA,YAAY;AACZ;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AACG;AACa;AACrE;AACP,WAAW,yBAAyB;AACpC,WAAW,SAAS;AACpB,WAAW,uCAAuC;AAClD;AACA,oBAAoB,0DAAG;AACvB,YAAY,oFAA2B;AACvC,YAAY,uEAAqB;AACjC;AACA;AACO;AACP,gBAAgB,iEAAc;AAC9B;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACqB;AACzE;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B,wBAAwB,wFAA6B;AACrD;AACA;AACO;AACP,gBAAgB,qEAAkB;AAClC;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACgB;AACvE;AACP,WAAW,yBAAyB;AACpC,WAAW,SAAS;AACpB,WAAW,uCAAuC;AAClD;AACA,wBAAwB,sFAA4B;AACpD;AACA;AACO;AACP,gBAAgB,wEAAqB;AACrC;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAC4B;AACvF;AACP,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B,wBAAwB,sGAAmC;AAC3D;AACA;AACO;AACP,gBAAgB,4EAAyB;AACzC;AACA;AACA;AACA,qD;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACX;AACa;AACvB;AAC/B;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA,kBAAkB,sEAAmB;AACrC;AACA,eAAe,mDAAQ,EAAE,UAAU,IAAI,WAAW;AAClD;AACA,oBAAoB,0DAAG;AACvB,YAAY,qEAAoB;AAChC,YAAY,wDAAc;AAC1B;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACX;AACvC;AACP,gBAAgB,mEAAgB;AAChC;AACA,kBAAkB,yBAAyB;AAC3C,eAAe,QAAQ;AACvB,eAAe,6BAA6B;AAC5C;AACA,4BAA4B,sDAAa;AACzC;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO,cAAc,iFAAe,EAAE,mBAAmB;AAClD;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACuB;AACf;AACtD,qCAAqC;AAC9B,cAAc,iFAAe,EAAE,kCAAkC,8DAAY,EAAE;AAC/E;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AAChB;AACZ;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,wDAAwD,GAAG,+EAA4B;AAClG;AACA;AACA;AACA;AACA,2BAA2B,iDAAO,EAAE,UAAU,aAAa,mBAAmB,iCAAiC,EAAE;AACjH,qBAAqB,iDAAO,EAAE,UAAU,aAAa,mBAAmB,iCAAiC,EAAE;AAC3G,sFAAsF;AACtF,wBAAwB,wDAAc;AACtC;AACA,qBAAqB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,QAAQ,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACb;AACvC;AACP,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,wBAAwB,sDAAa;AACrC,+DAA+D,iEAAU;AACzE;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACU;AACrE;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD,kBAAkB,0EAAuB;AACzC;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACqB;AACrE,oDAAoD;AAC7C,gBAAgB,iFAAe,EAAE,qBAAqB;AACtD;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AACrE;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACkD;AAC9F,YAAY,qFAAuB;AACnC;AACA;AACO,YAAY,iFAAe,EAAE,iBAAiB;AAC9C;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AACrE;AACA;AACA;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACf;AACV;AACa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAA4B,QAAQ,sEAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,cAAc;AACzB,4BAA4B,8EAA2B;AACvD,IAAI,+EAA4B;AAChC,QAAQ,qEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAY;AACtC;AACA;AACA,WAAW,WAAW;AACtB,wBAAwB,8EAA2B;AACnD;AACA,wBAAwB,0DAAG;AAC3B,gBAAgB,iEAAkB;AAClC,gBAAgB,oDAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,wDAAK;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACxC;AACA;AACQ;AACA;AACR;AACA;AACrB;AACP,WAAW,yBAAyB;AACpC,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,iBAAiB,sEAAmB;AACpC,qBAAqB,yCAAG;AACxB,iBAAiB,YAAY;AAC7B;AACA,gBAAgB;AAChB,KAAK;AACL,0BAA0B,oFAAiC;AAC3D,8BAA8B,iDAAO,EAAE,UAAU,cAAc,mBAAmB,uBAAuB,EAAE;AAC3G,cAAc,yCAAG,EAAE,UAAU,kCAAkC,WAAW;AAC1E,cAAc,yCAAG,EAAE,UAAU,OAAO,WAAW;AAC/C,mBAAmB,yCAAG,EAAE,UAAU,OAAO,mBAAmB,8BAA8B,EAAE;AAC5F,2BAA2B,iDAAO,EAAE,UAAU,YAAY,mBAAmB,uBAAuB,EAAE;AACtG,gBAAgB,iDAAO,EAAE,UAAU,0BAA0B,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,0DAAO;AACvB;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACoB;AACrE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB,iFAAe,EAAE,sBAAsB;AACxD;AACP,gBAAgB,2DAAQ;AACxB;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2E;AAC3C;AACI;AACI;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,uBAAuB;AAClC,IAAI,8DAAW;AACf;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA,oBAAoB,6CAAK;AACzB,iBAAiB,IAAI;AACrB;AACA,gBAAgB;AAChB,KAAK;AACL,gCAAgC,2EAAwB;AACxD,8CAA8C,2EAAwB;AACtE,yBAAyB,mFAAgC;AACzD,4BAA4B,iDAAO,EAAE,UAAU,aAAa,mBAAmB,6BAA6B,EAAE;AAC9G,qBAAqB,qDAAS;AAC9B,iBAAiB,qBAAqB;AACtC;AACA,gBAAgB;AAChB,KAAK;AACL,mBAAmB,iDAAO,EAAE,UAAU,cAAc,mBAAmB,sBAAsB,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,iEAAc;AAC9B;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACpB;AACZ;AAC7B;AACP,WAAW,yBAAyB;AACpC,WAAW,4CAA4C;AACvD,WAAW,cAAc;AACzB,WAAW,6CAA6C,GAAG,+EAA4B;AACvF;AACA,wBAAwB,wDAAc;AACtC;AACA,qBAAqB,iDAAO,EAAE,UAAU,SAAS,mBAAmB,qBAAqB,EAAE;AAC3F;AACA;AACA;AACO;AACP,gBAAgB,gEAAa;AAC7B;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmE;AACnC;AACzB;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,wBAAwB;AACnC,kBAAkB,sEAAmB;AACrC,uBAAuB,gFAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAK,EAAE,UAAU,IAAI,mBAAmB,yBAAyB,EAAE;AAC1F;AACA;AACA,KAAK;AACL;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AACrE,6BAA6B;AACtB,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AACsB;AACrE,6BAA6B;AACtB,eAAe,iFAAe,EAAE,oBAAoB;AACpD;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACY;AACtE,qDAAqD;AAC9C,0BAA0B,kFAAgB,EAAE,qEAAqE;AACjH;AACP,gBAAgB,oEAAiB;AACjC;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACsB;AAC5D,eAAe,yBAAyB;AAC/C,WAAW,IAAI;AACf,sBAAsB,2DAAiB;AACvC,mCAAmC,YAAY;AAC/C;AACA,wBAAwB,wDAAc;AACtC;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyE;AACZ;AACF;AACvB;AACJ;AACzB;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,qFAAqF;AAChG,WAAW,yDAAyD,GAAG,uEAAoB;AAC3F,eAAe,iDAAO,EAAE,UAAU,IAAI,mBAAmB,kBAAkB,EAAE;AAC7E;AACA;AACA,uBAAuB,6CAAK,EAAE,UAAU,QAAQ,mBAAmB,sBAAsB,EAAE;AAC3F,iBAAiB,iDAAO,EAAE,UAAU,YAAY,mBAAmB,kBAAkB,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAM;AAC/B,iCAAiC,yEAAmB;AACpD;AACA;AACA;AACA,gCAAgC,mEAAmB;AACnD;AACA;AACA;AACA,2BAA2B,iDAAO,EAAE,UAAU,YAAY,mBAAmB,kBAAkB,EAAE;AACjG;AACA;AACA;AACA;AACO;AACP,gBAAgB,+DAAY;AAC5B;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AAC0B;AACR;AAC9D,0BAA0B;AACnB,YAAY,kFAAgB;AACnC;AACA;AACA;AACA,mBAAmB,4DAAM;AACzB,CAAC;AACM;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACP;AAC9B;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,iBAAiB;AAC5B,WAAW,kDAAO;AAClB;AACO;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuE;AACvB;AACZ;AACa;AAC1C;AACP;AACA;AACA,qBAAqB,sEAAmB;AACxC;AACA,yBAAyB,kFAA+B;AACxD;AACA;AACA;AACA,mBAAmB,8DAAa;AAChC,eAAe,gFAA6B;AAC5C;AACA,IAAI,0FAAuC;AAC3C,uCAAuC,yFAAsC;AAC7E;AACA;AACA;AACA,mBAAmB,oFAAiC;AACpD;AACA,mBAAmB,qEAAkB;AACrC,kBAAkB,qEAAkB;AACpC;AACA,0BAA0B,iDAAO,EAAE,UAAU,cAAc,UAAU,6BAA6B,WAAW;AAC7G,oBAAoB,iEAAU;AAC9B,oBAAoB,4DAAM;AAC1B,gBAAgB,iDAAO,EAAE,UAAU,aAAa,UAAU,kBAAkB,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACyB;AACrE,2BAA2B;AACpB,YAAY,iFAAe,EAAE,iBAAiB;AAC9C;AACP,gBAAgB,sDAAG;AACnB;AACA;AACA;AACA,+B;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACwB;AACrE;AACA;AACA;AACA;AACO,aAAa,iFAAe,EAAE,kBAAkB;AAChD;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACN;AACX;AACnC;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,0CAA0C,oEAAiB;AAC3D,oBAAoB,6DAAM;AAC1B,uBAAuB,iEAAW;AAClC;AACA;AACA,wBAAwB,kDAAW;AACnC;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACQ;AAC9C;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,YAAY;AACvB;AACA,0CAA0C,iEAAW;AACrD;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,uDAAI;AACpB;AACA;AACA;AACA,gC;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACD;AACmB;AAC7D;AACP,WAAW,yBAAyB;AACpC,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAY;AACtC;AACA;AACA;AACA;AACA;AACA,cAAc,8DAAa;AAC3B;AACA;AACA;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACc;AACN;AACa;AAC1D;AACP,oBAAoB,0DAAG;AACvB,YAAY,yEAAsB;AAClC,YAAY,4DAAgB;AAC5B;AACA;AAC4B;AAC5B,0C;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AACQ;AACN;AAC1C;AACP,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,IAAI,6DAAgB;AACpB;AACA;AACA;AACA,WAAW,qCAAqC,GAAG,mEAAa;AAChE;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AACX;AACJ;AACzB;AACP,WAAW,yBAAyB;AACpC,WAAW,QAAQ;AACnB,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,uBAAuB,6CAAK,EAAE,UAAU,IAAI,mBAAmB,cAAc,EAAE;AAC/E,yBAAyB,iDAAO,EAAE,UAAU,YAAY,mBAAmB,kBAAkB,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2F;AACzC;AAClB;AACI;AACN;AACU;AACjC;AACP,WAAW,yBAAyB;AACpC,WAAW,gBAAgB;AAC3B,WAAW,cAAc;AACzB;AACA;AACA;AACA,wBAAwB,kFAA+B;AACvD;AACA;AACA,oBAAoB,qDAAS,EAAE,UAAU,IAAI,mBAAmB,oBAAoB,EAAE;AACtF;AACA,eAAe,gFAA6B;AAC5C;AACA,qBAAqB,4FAAyC;AAC9D,mBAAmB,qEAAkB;AACrC,gBAAgB,iDAAO,EAAE,UAAU,eAAe,mBAAmB,sBAAsB,EAAE;AAC7F;AACA,wBAAwB,iEAAU;AAClC;AACA;AACA;AACA,2BAA2B,0GAAuD;AAClF,2BAA2B;AAC3B,4BAA4B,0DAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAAK;AAC/B;AACA,oBAAoB;AACpB,SAAS;AACT,yBAAyB,2CAAI;AAC7B,qBAAqB,eAAe;AACpC;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAO,EAAE,UAAU,iBAAiB,mBAAmB,kBAAkB,EAAE;AAChG;AACA;AACA;AACA,qBAAqB,sFAAmC;AACxD,iBAAiB,qDAAS,EAAE,UAAU,YAAY,mBAAmB,OAAO,EAAE;AAC9E;AACA;AACA;AACA;AACO;AACP,gBAAgB,qEAAkB;AAClC;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACd;AACN;AACA;AACA;AACvB;AACP,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA,yBAAyB,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC/D,6BAA6B,UAAU,cAAc,WAAW;AAChE,yBAAyB,2CAAI,EAAE,UAAU,WAAW,WAAW;AAC/D,6BAA6B,UAAU,cAAc,WAAW;AAChE,uBAAuB,iDAAO,EAAE,UAAU,mBAAmB,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACO;AACP,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,qC;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACA;AAC9C;AACP,WAAW,yBAAyB;AACpC,WAAW,qCAAqC;AAChD,WAAW,qDAAqD;AAChE,WAAW,kEAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,gBAAgB,+DAAY;AAC5B;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,YAAY,MAAM;AACtD;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA,qCAAqC,MAAM,aAAa,KAAK,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK,QAAQ,KAAK;AAC1C;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO,YAAY;AAC1C,oDAAoD,YAAY;AAChE,yCAAyC,WAAW;AACpD,0BAA0B,YAAY;;AAEtC;AACA,sCAAsC;;AAEtC;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,MAAM,mBAAmB,KAAK;;AAEvD,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,YAAY,MAAM;AACtD;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA,qCAAqC,MAAM,aAAa,KAAK,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC,gCAAgC;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,KAAK,QAAQ,KAAK;AAC3C;AACA;AACA,6DAA6D,KAAK;;AAElE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO,IAAI,QAAQ;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,kBAAkB,eAAe;AACjC,gDAAgD,aAAa;;AAE7D,oCAAoC,mBAAmB;AACvD;AACA;AACA;;AAEA,0BAA0B,QAAQ,sBAAsB;AACxD,kDAAkD,YAAY;;AAE9D,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,UAAU;;AAE1C;AACA;AACA,qCAAqC,qBAAqB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,IAAI,OAAO,IAAI,QAAQ;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC,mBAAmB,cAAc;AACjC,gDAAgD,YAAY;;AAE5D,oCAAoC,kBAAkB;AACtD;AACA;AACA;;AAEA,0BAA0B,QAAQ;AAClC,sBAAsB,eAAe;AACrC,kDAAkD,aAAa;;AAE/D,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC,wBAAwB,cAAc;AACtC,oDAAoD,YAAY;;AAEhE,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA,yBAAyB,sBAAsB,KAAK,qBAAqB;AACzE,yBAAyB,qBAAqB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA;AACA,eAAe,yCAAyC;AACxD;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,wDAAwD,6DAAU;AAClE,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;;AAEA,uBAAuB,OAAO,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA,iCAAiC;AACjC,cAAc,8BAA8B;AAC5C;;AAEA,YAAY;AACZ,SAAS,YAAY,8BAA8B;AACnD;AACA;AACA;;AAEA,YAAY;AACZ,SAAS,YAAY,8BAA8B;AACnD;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB;;AAEpB;AACA;AACA;AACA,wCAAwC;AACxC,WAAW;AACX,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,MAAM,WAAW,MAAM,GAAG,MAAM;AACxC,QAAQ,MAAM,SAAS,MAAM,GAAG,IAAI;;AAEpC;AACA,UAAU,MAAM;AAChB,uBAAuB,OAAO,MAAM;AACpC;AACA,iDAAiD;AACjD,WAAW;AACX,qDAAqD;AACrD;AACA;AACA,UAAU,MAAM;AAChB,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC;AACA;AACA,uBAAuB,0DAAW;AAClC,uBAAuB,0DAAW;AAClC,0BAA0B,iBAAiB,KAAK,2BAA2B;AAC3E,0DAA0D,wBAAwB;AAClF;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB;AACA,0CAA0C;AAC1C,SAAS;AACT,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB,UAAU;AACV,sCAAsC,cAAc,KAAK,UAAU;AACnE,UAAU,iBAAiB;AAC3B,aAAa,OAAO;AACpB,YAAY;AACZ,wCAAwC,cAAc,KAAK,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB,UAAU,MAAM,QAAQ,MAAM;AAC9B,UAAU,MAAM,SAAS,MAAM;AAC/B,UAAU,MAAM;AAChB;AACA,6CAA6C,OAAO;AACpD,kDAAkD,OAAO;AACzD;AACA;AACA;AACA,UAAU,MAAM;AAChB,UAAU;AACV,sCAAsC,cAAc,KAAK,UAAU;AACnE,UAAU,iBAAiB;AAC3B,aAAa,OAAO;AACpB,YAAY;AACZ,wCAAwC,cAAc,KAAK,UAAU;AACrE;AACA;AACA,UAAU,iBAAiB;AAC3B,aAAa,iBAAiB,KAAK,2BAA2B;AAC9D,YAAY;AACZ,wCAAwC,cAAc,KAAK,UAAU;AACrE,YAAY,iBAAiB;AAC7B,eAAe,OAAO;AACtB,cAAc;AACd,0CAA0C,cAAc,KAAK,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM,WAAW,MAAM,GAAG,MAAM;AAC9C,cAAc,MAAM,SAAS,MAAM,GAAG,IAAI;;AAE1C;AACA,UAAU,MAAM;AAChB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA,kEAAkE;AAClE;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA,QAAQ;;AAER,sCAAsC,sBAAsB;;AAE5D;AACA;AACA,uBAAuB,OAAO,uBAAuB;AACrD,yBAAyB;AACzB,yBAAyB;AACzB,wCAAwC,QAAQ;AAChD,wCAAwC,QAAQ;;AAEhD;AACA;AACA,uBAAuB,YAAY,KAAK,YAAY;AACpD,uBAAuB,YAAY,KAAK,YAAY;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU;;AAEV,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,OAAO,iBAAiB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS,WAAW,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACS;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW;AACxC,0BAA0B,mEAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;;AAElB,eAAe,qBAAqB;AACpC;AACA,WAAW;AACX,cAAc;;AAEd,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,yBAAyB,UAAU;AACnC,2BAA2B,wBAAwB,IAAI,wBAAwB;AAC/E,2BAA2B,UAAU;AACrC,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,0BAA0B,UAAU;AACpC,mBAAmB,QAAQ,MAAM,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,mBAAmB,gBAAgB;AACnC,8BAA8B,gBAAgB;AAC9C,8BAA8B,gBAAgB;AAC9C,uCAAuC,gBAAgB;AACvD;AACA,oC;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qEAAqE,KAAK,GAAG,EAAE;AAC/E;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA,qBAAqB,mEAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB;;AAEpB;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAK,WAAW,KAAK,GAAG,MAAM;AACtC,QAAQ,KAAK,SAAS,KAAK,GAAG,IAAI;;AAElC;AACA,UAAU,KAAK;AACf;AACA,4BAA4B,cAAc;AAC1C,SAAS;AACT,YAAY,KAAK;AACjB,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACS;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC;AACA;AACA,uBAAuB,0DAAW;AAClC,uBAAuB,0DAAW;AAClC,0BAA0B,iBAAiB,KAAK,2BAA2B;AAC3E,0DAA0D,wBAAwB;AAClF;AACA,eAAe,MAAM,gBAAgB,MAAM,iBAAiB;AAC5D,YAAY,OAAO;AACnB;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B,YAAY,iBAAiB,KAAK,2BAA2B,GAAG;AAChE,mCAAmC,iBAAiB;AACpD,cAAc,OAAO,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA,UAAU;AACV,cAAc,YAAY;AAC1B,mBAAmB,EAAE,YAAY,cAAc;AAC/C,SAAS;AACT,YAAY,MAAM;AAClB,mBAAmB,EAAE,sBAAsB,cAAc,KAAK,UAAU;AACxE;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA,cAAc,MAAM,WAAW,MAAM,GAAG,MAAM;AAC9C,cAAc,MAAM,SAAS,MAAM,GAAG,IAAI;;AAE1C;AACA,UAAU,MAAM;AAChB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,kBAAkB,WAAW,iBAAiB,WAAW,oBAAoB;AACnI,4CAA4C,iBAAiB,WAAW,oBAAoB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa,IAAI,YAAY;AACnE,mCAAmC,OAAO,IAAI,QAAQ;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,QAAQ;AAClC,sBAAsB,eAAe;AACrC;;AAEA,kCAAkC,kBAAkB;AACpD;AACA;;AAEA,4BAA4B,QAAQ;AACpC,wBAAwB,cAAc;AACtC;;AAEA,oCAAoC,iBAAiB;AACrD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA,mCAAmC;AACnC;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS,GAAG,SAAS,GAAG,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,OAAO;AACP,wBAAwB,UAAU;AAClC;AACA;AACA;AACA,oCAAoC,aAAa,IAAI,YAAY;AACjE,iCAAiC,OAAO,IAAI,QAAQ;AACpD,0CAA0C;AAC1C;;AAEA;;AAEA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;;AAEA,wBAAwB,QAAQ;AAChC,oBAAoB,eAAe;AACnC;;AAEA,gCAAgC,kBAAkB;AAClD;AACA;;AAEA,0BAA0B,QAAQ,wBAAwB;AAC1D,uCAAuC;;AAEvC;AACA;AACA,yCAAyC,cAAc;AACvD,6CAA6C,cAAc;AAC3D,6CAA6C,cAAc;AAC3D;;AAEA,cAAc;AACd;;AAEA,gCAAgC;AAChC,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd,WAAW,YAAY,+BAA+B;AACtD;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA;;AAEA,cAAc;AACd,WAAW,YAAY,+BAA+B;AACtD;AACA;AACA,yCAAyC,cAAc;AACvD,6CAA6C,cAAc;AAC3D;AACA;;AAEA,cAAc;AACd;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,IAAI,aAAa,IAAI,YAAY;AACjE,mCAAmC,SAAS,IAAI,OAAO,IAAI,QAAQ;;AAEnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,QAAQ;AAClC,sBAAsB,cAAc;AACpC;;AAEA,kCAAkC,iBAAiB;AACnD;AACA;;AAEA,4BAA4B,QAAQ;AACpC,wBAAwB,eAAe;AACvC;;AAEA,oCAAoC,kBAAkB;AACtD;AACA;;AAEA,8BAA8B,QAAQ;AACtC,0BAA0B,cAAc;AACxC;;AAEA,sCAAsC,iBAAiB;AACvD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,qCAAqC;AACrC;AACA,kCAAkC,iBAAiB,WAAW,kBAAkB,WAAW,iBAAiB,WAAW,oBAAoB;AAC3I,8BAA8B,kBAAkB,WAAW,iBAAiB,WAAW,oBAAoB;AAC3G,wBAAwB,sBAAsB,KAAK,qBAAqB;AACxE,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS,GAAG,SAAS,GAAG,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,OAAO;AACP,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA,gBAAgB,YAAY,IAAI,aAAa,IAAI,YAAY;AAC7D,iCAAiC,SAAS,IAAI,OAAO,IAAI,QAAQ;AACjE,0CAA0C;AAC1C;;AAEA;;AAEA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;;AAEA,wBAAwB,QAAQ;AAChC,oBAAoB,cAAc;AAClC;;AAEA,gCAAgC,iBAAiB;AACjD;AACA;;AAEA,0BAA0B,QAAQ;AAClC,oBAAoB,eAAe;AACnC;;AAEA,kCAAkC,kBAAkB;AACpD;AACA;;AAEA,4BAA4B,QAAQ,wBAAwB;AAC5D,yCAAyC;;AAEzC;AACA;AACA,+CAA+C,cAAc;AAC7D,mDAAmD,cAAc;AACjE,mDAAmD,cAAc;AACjE;;AAEA,gBAAgB;AAChB;;AAEA,kCAAkC;AAClC,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,aAAa,YAAY,+BAA+B;AACxD;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;;AAEA,gBAAgB;AAChB,aAAa,YAAY,+BAA+B;AACxD;AACA;AACA,+CAA+C,cAAc;AAC7D,mDAAmD,cAAc;AACjE;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;AC1ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,yCAAyC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,GAAG,WAAW,GAAG,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA,OAAO,YAAY,sBAAsB;AACzC;AACA;AACA,OAAO;AACP,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO,uBAAuB;AACrD;AACA,YAAY,QAAQ,YAAY,QAAQ;AACxC;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA,iCAAiC;AACjC,cAAc,8BAA8B;AAC5C,YAAY,QAAQ,YAAY,QAAQ;AACxC;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ,SAAS,YAAY,8BAA8B;AACnD,YAAY,QAAQ,YAAY,QAAQ;AACxC;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ,SAAS,YAAY,8BAA8B;AACnD,YAAY,QAAQ,YAAY,QAAQ;AACxC;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACK;AAClB;AACE;AACE;AACJ;AACE;AACF;AACA;AACM;AACA;AACJ;AACE;AACF;AACE;AACA;AACI;AACI;AACQ;AACJ;AACA;AACJ;AACU;AACZ;AACR;AACA;AACc;AACR;AACM;AACR;AACA;AAC4B;AACF;AAC1B;AACgC;AACJ;AAClC;AACE;AACkB;AACd;AACc;AACF;AACkB;AAC4B;AACF;AAC5D;AACY;AACd;AACQ;AACJ;AACJ;AACA;AACc;AACV;AACJ;AACE;AACkB;AAChB;AACM;AACI;AACE;AACkB;AACxB;AACA;AACF;AACU;AACR;AACR;AACA;AACQ;AACN;AACA;AACQ;AACV;AACU;AACF;AACV;AACI;AACU;AACA;AACF;AACZ;AACQ;AACR;AACQ;AACA;AACI;AACQ;AACJ;AACY;AAC1B;AACF;AACQ;AACI;AACZ;AACgB;AACN;AACV;AACgC;AACA;AACA;AACtB;AACJ;AACI;AACR;AACE;AACJ;AACI;AACF;AACE;AACF;AACM;AACM;AACZ;AACE;AACI;AACc;AACQ;AACM;AACQ;AACpC;AACkB;AACtB;AACA;AACQ;AACN;AACJ;AACM;AACN;AACF;AACE;AACE;AACI;AACE;AACY;AACF;AACd;AACJ;AACI;AACsB;AAC1B;AACgB;AAClB;AACA;AACA;AACE;AACA;AACA;AACU;AACN;AACA;AACwB;AAClB;AACtD;AACA;AACA,IAAI,mDAAS;AACb,IAAI,2DAAa;AACjB,IAAI,oEAAkB;AACtB,IAAI,mDAAS;AACb,IAAI,qDAAU;AACd,IAAI,uDAAW;AACf,IAAI,mDAAS;AACb,IAAI,qDAAU;AACd,IAAI,mDAAS;AACb,IAAI,oDAAS;AACb,IAAI,0DAAY;AAChB,IAAI,0DAAY;AAChB,IAAI,sDAAU;AACd,IAAI,wDAAW;AACf,IAAI,wDAAW;AACf,IAAI,sDAAU;AACd,IAAI,wDAAW;AACf,IAAI,gEAAe;AACnB,IAAI,4DAAa;AACjB,IAAI,wEAAmB;AACvB,IAAI,oEAAiB;AACrB,IAAI,oEAAiB;AACrB,IAAI,gEAAe;AACnB,IAAI,0EAAoB;AACxB,IAAI,8DAAc;AAClB,IAAI,sDAAU;AACd,IAAI,sDAAU;AACd,IAAI,oEAAiB;AACrB,IAAI,kEAAgB;AACpB,IAAI,4DAAa;AACjB,IAAI,0DAAY;AAChB,IAAI,sFAA0B;AAC9B,IAAI,oFAAyB;AAC7B,IAAI,0DAAY;AAChB,IAAI,0FAA4B;AAChC,IAAI,sFAAyB;AAC7B,IAAI,0DAAY;AAChB,IAAI,oDAAS;AACb,IAAI,sDAAU;AACd,IAAI,wEAAmB;AACvB,IAAI,0DAAY;AAChB,IAAI,wEAAmB;AACvB,IAAI,sEAAkB;AACtB,IAAI,oHAAyC;AAC7C,IAAI,kHAAwC;AAC5C,IAAI,wFAA2B;AAC/B,IAAI,sDAAU;AACd,IAAI,kEAAgB;AACpB,IAAI,oDAAS;AACb,IAAI,4DAAa;AACjB,IAAI,wDAAW;AACf,IAAI,oDAAS;AACb,IAAI,oDAAS;AACb,IAAI,kEAAgB;AACpB,IAAI,wDAAW;AACf,IAAI,oDAAS;AACb,IAAI,sDAAU;AACd,IAAI,wEAAmB;AACvB,IAAI,wDAAW;AACf,IAAI,8DAAc;AAClB,IAAI,kEAAgB;AACpB,IAAI,oEAAiB;AACrB,IAAI,sFAA0B;AAC9B,IAAI,8DAAc;AAClB,IAAI,8DAAc;AAClB,IAAI,4DAAa;AACjB,IAAI,sEAAkB;AACtB,IAAI,8DAAc;AAClB,IAAI,sDAAU;AACd,IAAI,sDAAU;AACd,IAAI,8DAAc;AAClB,IAAI,wDAAW;AACf,IAAI,wDAAW;AACf,IAAI,gEAAe;AACnB,IAAI,sDAAU;AACd,IAAI,gEAAe;AACnB,IAAI,8DAAc;AAClB,IAAI,wDAAW;AACf,IAAI,oDAAS;AACb,IAAI,kEAAgB;AACpB,IAAI,kEAAgB;AACpB,IAAI,gEAAe;AACnB,IAAI,oDAAS;AACb,IAAI,gEAAe;AACnB,IAAI,4DAAa;AACjB,IAAI,wEAAmB;AACvB,IAAI,oEAAiB;AACrB,IAAI,gFAAuB;AAC3B,IAAI,4DAAa;AACjB,IAAI,sDAAU;AACd,IAAI,oDAAS;AACb,IAAI,4DAAa;AACjB,IAAI,gEAAe;AACnB,IAAI,oDAAS;AACb,IAAI,oEAAiB;AACrB,IAAI,8DAAc;AAClB,IAAI,oDAAS;AACb,IAAI,oFAAyB;AAC7B,IAAI,oFAAyB;AAC7B,IAAI,qFAAyB;AAC7B,IAAI,+DAAc;AAClB,IAAI,2DAAY;AAChB,IAAI,+DAAc;AAClB,IAAI,uDAAU;AACd,IAAI,yDAAW;AACf,IAAI,qDAAS;AACb,IAAI,yDAAW;AACf,IAAI,uDAAU;AACd,IAAI,yDAAW;AACf,IAAI,uDAAU;AACd,IAAI,6DAAa;AACjB,IAAI,mEAAgB;AACpB,IAAI,yDAAW;AACf,IAAI,uDAAU;AACd,IAAI,6DAAa;AACjB,IAAI,2EAAoB;AACxB,IAAI,mFAAwB;AAC5B,IAAI,yFAA2B;AAC/B,IAAI,iGAA+B;AACnC,IAAI,6DAAa;AACjB,IAAI,+EAAsB;AAC1B,IAAI,yDAAW;AACf,IAAI,yDAAW;AACf,IAAI,iEAAe;AACnB,IAAI,2DAAY;AAChB,IAAI,uDAAU;AACd,IAAI,6DAAa;AACjB,IAAI,uDAAU;AACd,IAAI,qDAAS;AACb,IAAI,uDAAU;AACd,IAAI,yDAAW;AACf,IAAI,6DAAa;AACjB,IAAI,+DAAc;AAClB,IAAI,2EAAoB;AACxB,IAAI,yEAAmB;AACvB,IAAI,2DAAY;AAChB,IAAI,uDAAU;AACd,IAAI,2DAAY;AAChB,IAAI,iFAAuB;AAC3B,IAAI,uDAAU;AACd,IAAI,uEAAkB;AACtB,IAAI,qDAAS;AACb,IAAI,qDAAS;AACb,IAAI,qDAAS;AACb,IAAI,uDAAU;AACd,IAAI,uDAAU;AACd,IAAI,uDAAU;AACd,IAAI,iEAAe;AACnB,IAAI,2DAAY;AAChB,IAAI,2DAAY;AAChB,IAAI,mFAAwB;AAC5B,IAAI,iEAAe;AACnB;AACA;AACA,IAAI,qEAAc;AAClB;AACA,gD;;;;;;;;;;;;;;;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,sCAAsC;AACtC;AACA,yCAAyC;AACzC;AACA;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV,UAAU,gDAAgD;AAC1D;;AAEA;AACA;;AAEA,mBAAmB,EAAE;AACrB;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA,QAAQ;AACR,QAAQ,qEAA8B;;AAEtC;AACA;;AAEA;;AAEA;AACA,qBAAqB;AACrB,qBAAqB;;AAErB,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qFAA8C;AACjF;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,YAAY;AACtD,yCAAyC,WAAW;;AAEpD,6CAA6C,eAAe;AAC5D,4CAA4C,cAAc;;AAE1D,oCAAoC,UAAU;AAC9C,mCAAmC,SAAS;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,uBAAuB;AACtD;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA,iCAAiC,sBAAsB;AACvD;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;;AAEA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wD;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAyC;AACrD,YAAY,yCAAyC;AACrD,uCAAuC,UAAU,MAAM,SAAS;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAyC;AACrD,YAAY,yCAAyC;AACrD,YAAY,yCAAyC;AACrD,uCAAuC,UAAU,MAAM,SAAS;AAChE,uCAAuC,SAAS;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,YAAY;AACtD,yCAAyC,WAAW;;AAEpD,6CAA6C,eAAe;AAC5D,4CAA4C,cAAc;;AAE1D,oCAAoC,UAAU;AAC9C,mCAAmC,SAAS;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,uBAAuB;AACtD;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA,iCAAiC,sBAAsB;AACvD;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;AACA,sBAAsB,kBAAkB;AACxC,sCAAsC,kBAAkB;;AAExD;AACA,wBAAwB,kBAAkB;AAC1C,wCAAwC,kBAAkB;;AAE1D;AACA,4BAA4B,QAAQ;AACpC,kBAAkB,aAAa;AAC/B;;AAEA;AACA,4BAA4B,OAAO;AACnC,kBAAkB,aAAa;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gE;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAyC;AACrD,YAAY,yCAAyC;AACrD,uCAAuC,UAAU,MAAM,SAAS;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA,8DAA8D,UAAU;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA,8DAA8D,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU,YAAY,EAAE;AAClD;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA,qBAAqB,mEAAiB;AACtC;AACA;AACA,UAAU,KAAK;AACf,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACS;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,KAAK;AACnE;AACA;AACA,yBAAyB,0DAAW;AACpC,8BAA8B,mBAAmB,SAAS,2BAA2B;AACrF,2BAA2B,mBAAmB,SAAS,2BAA2B;AAClF,qBAAqB,mEAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD,cAAc,UAAU;AACxB,eAAe,WAAW;AAC1B,2CAA2C,UAAU;AACrD,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA,uBAAuB;AACvB,eAAe,WAAW;AAC1B,yBAAyB;AACzB;AACA,eAAe,QAAQ;AACvB,yBAAyB;AACzB,iBAAiB,WAAW;AAC5B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS,UAAU,UAAU;AACnE;AACA;AACA;AACA,0BAA0B,UAAU,KAAK,aAAa;AACtD;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8EAA2B;AAC9D;AACA;AACA;AACA;AACA,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc,MAAM,UAAU,iBAAiB,cAAc,MAAM;AAC/G,4CAA4C,cAAc,MAAM,UAAU,iBAAiB,cAAc,MAAM;AAC/G,iDAAiD,cAAc;AAC/D,iDAAiD,cAAc;AAC/D,YAAY;AACZ,uCAAuC,WAAW,8BAA8B,YAAY;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA,4BAA4B,mEAAiB;AAC7C,sBAAsB,mEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA,UAAU,YAAY,aAAa,YAAY,GAAG,QAAQ;;AAE1D;AACA,YAAY,MAAM;AAClB;AACA;AACA,yBAAyB,OAAO,YAAY;AAC5C;AACA,2BAA2B,OAAO,UAAU;AAC5C,kCAAkC,eAAe;AACjD,0CAA0C;AAC1C;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY,aAAa,WAAW;AAChD,wDAAwD,YAAY;;AAEpE;;AAEA,uBAAuB,OAAO,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA,iCAAiC;AACjC,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ,SAAS,YAAY,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ,SAAS,YAAY,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C,oCAAoC,iBAAiB;AACrD;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC;AACA;AACA,UAAU,MAAM;AAChB,4BAA4B,QAAQ;AACpC;AACA,2BAA2B,SAAS;AACpC,SAAS;AACT,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC3D,OAAO,mBAAmB,GAAG,+DAAY;AACW;AACE;AAC/C;AACP;AACA;AACA,qBAAqB,qEAAkB;AACvC;AACA;AACA,iDAAiD,OAAO,EAAE,eAAe,KAAK,SAAS;AACvF;AACA;AACA,qDAAqD,QAAQ;AAC7D,qDAAqD,QAAQ;AAC7D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,MAAM,eAAe;AACrB,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN,MAAM;AACN,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB,IAAI,kBAAkB;AAC5E,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,IAAI,YAAY;AAChE,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB,IAAI,kBAAkB;AAC5E,iCAAiC,kBAAkB;;AAEnD,wBAAwB;AACxB,qBAAqB;;AAErB,6BAA6B,mBAAmB;AAChD,4BAA4B,mBAAmB;;AAE/C;AACA;AACA;AACA;AACA;AACA,mCAAmC,qFAA8C;AACjF;AACA;AACA;AACA,oCAAoC,YAAY,IAAI,YAAY;AAChE,iCAAiC,YAAY;AAC7C,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,aAAa,EAAE,aAAa;AAC5B,kBAAkB,EAAE,KAAK;AACzB;AACA,qBAAqB,EAAE;AACvB;AACA;AACA,UAAU,aAAa;AACvB;AACA,oCAAoC,kBAAkB,IAAI,kBAAkB;AAC5E,iCAAiC,kBAAkB;;AAEnD,QAAQ;;AAER,wBAAwB;AACxB,qBAAqB;;AAErB,6BAA6B,mBAAmB;AAChD,4BAA4B,mBAAmB;;AAE/C,mBAAmB,aAAa,GAAG,OAAO;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,qFAA8C;AACjF;AACA;AACA;AACA,eAAe,YAAY,IAAI,YAAY;AAC3C,iCAAiC,YAAY;AAC7C,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,mCAAmC,qFAA8C;AACjF;AACA;AACA,kDAAkD,YAAY;AAC9D,+BAA+B,YAAY;;AAE3C,iCAAiC,YAAY;;AAE7C,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qFAA8C;AACjF;AACA;AACA;AACA,eAAe,YAAY,IAAI,YAAY;AAC3C,iCAAiC,YAAY;;AAE7C,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA,8CAA8C,kBAAkB,IAAI,kBAAkB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB,IAAI,kBAAkB;;AAE5E,iCAAiC,kBAAkB;AACnD,6BAA6B,mBAAmB;AAChD,4BAA4B,mBAAmB;;AAE/C;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA,0CAA0C,YAAY,IAAI,YAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,IAAI,YAAY;AAClE,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,IAAI,YAAY;AAClE,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,IAAI,YAAY;AAChE,iCAAiC,YAAY;AAC7C,wBAAwB;AACxB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,iEAAkB;AACnC;AACA,WAAW,SAAS;AACpB,eAAe,eAAe,GAAG,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,IAAI,SAAS,UAAU;AACxD;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,6BAA6B,MAAM,IAAI,MAAM,IAAI,OAAO;AACxD,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAkB;AACnC;AACA,WAAW,SAAS;AACpB;AACA,UAAU,kBAAkB,IAAI,kBAAkB;AAClD,eAAe,eAAe,GAAG,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,6CAA6C,OAAO,aAAa,MAAM;AACvE,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,wCAAwC,OAAO,aAAa,MAAM;AAClE,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,6BAA6B,MAAM,IAAI,MAAM,YAAY,OAAO;AAChE,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAkB;AACnC,4BAA4B,mEAAgB;AAC5C;AACA,aAAa,SAAS;AACtB,qDAAqD,QAAQ,MAAM,QAAQ;;AAE3E,iBAAiB,eAAe,GAAG,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,iCAAiC,aAAa,IAAI,kBAAkB,IAAI,kBAAkB;AAC1F,eAAe,eAAe,GAAG,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAgB;AAC5C;AACA;AACA;AACA,YAAY,SAAS;AACrB,mDAAmD,QAAQ,MAAM,QAAQ;AACzE,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA,WAAW,qBAAqB,GAAG,oEAAiB;AACpD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,cAAc,SAAS;AACvB,iBAAiB,SAAS,GAAG,oCAAoC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,qDAAqD,SAAS;AAC9D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,yCAAyC,OAAO,UAAU,SAAS;AACnE,4CAA4C,QAAQ;AACpD,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,yCAAyC,OAAO,UAAU,SAAS;AACnE,uCAAuC,QAAQ;AAC/C,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA,wBAAwB,SAAS,WAAW;AAC5C,2BAA2B,QAAQ,IAAI,QAAQ;AAC/C,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,eAAe,SAAS;AACxB,mBAAmB,SAAS,GAAG,oCAAoC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAkB;AACnC;AACA,WAAW,SAAS;AACpB;AACA,UAAU,QAAQ,IAAI,QAAQ,IAAI,cAAc,IAAI,aAAa;AACjE,eAAe,eAAe,GAAG,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB,GAAG,oEAAiB;AACpD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,gBAAgB,SAAS;AACzB,mBAAmB,SAAS,GAAG,oCAAoC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,iCAAiC,QAAQ,IAAI,QAAQ;AACrD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,oDAAoD,QAAQ;AAC5D;AACA,4BAA4B,QAAQ,MAAM,QAAQ;AAClD,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,8CAA8C,SAAS;AACvD;AACA,qDAAqD,QAAQ,MAAM,QAAQ;AAC3E,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,4BAA4B,QAAQ,WAAW,QAAQ,aAAa;AACpE,+BAA+B,QAAQ,IAAI,QAAQ;AACnD,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc,iBAAiB,aAAa;AACnE,mBAAmB,cAAc;AACjC,yBAAyB,EAAE;AAC3B;AACA,oBAAoB,EAAE,KAAK,cAAc;AACzC;AACA,iBAAiB,iEAAkB;AACnC;AACA,WAAW,SAAS,GAAG,OAAO;AAC9B,oBAAoB;AACpB,2BAA2B;AAC3B,kCAAkC;AAClC,qDAAqD,QAAQ,IAAI,QAAQ;AACzE,eAAe,eAAe,GAAG,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB,GAAG,oEAAiB;AACpD;AACA;AACA;AACA;AACA,QAAQ;AACR,cAAc,SAAS;AACvB,iBAAiB,SAAS,GAAG,oCAAoC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,iCAAiC,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AACjE,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,uBAAuB,QAAQ,IAAI,QAAQ;AAC3C;AACA,0BAA0B,QAAQ,MAAM,QAAQ;AAChD,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,gCAAgC,oBAAoB,IAAI,SAAS;AACjE;AACA;AACA,yBAAyB,QAAQ,MAAM,QAAQ;AAC/C,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA,0BAA0B,QAAQ,WAAW,QAAQ;AACrD,oBAAoB,QAAQ;AAC5B,6BAA6B,QAAQ,IAAI,QAAQ,YAAY,OAAO;AACpE,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB,GAAG,oEAAiB;AACpD;AACA;AACA;AACA;AACA,QAAQ;AACR,cAAc,SAAS;AACvB,iBAAiB,SAAS,GAAG,oCAAoC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,iBAAiB,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAC7D;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,gCAAgC,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAChE;AACA,0BAA0B,QAAQ,MAAM,QAAQ;AAChD,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,iBAAiB,+BAA+B;AAChD,iBAAiB,oBAAoB,IAAI,SAAS;AAClD;AACA;AACA,yBAAyB,QAAQ,MAAM,QAAQ;AAC/C,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA,0BAA0B,QAAQ,WAAW,QAAQ,aAAa,QAAQ;AAC1E,qBAAqB,QAAQ,cAAc;AAC3C,6BAA6B,QAAQ,IAAI,QAAQ;AACjD,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB,GAAG,oEAAiB;AACpD;AACA;AACA;AACA;AACA,QAAQ;AACR,cAAc,SAAS;AACvB;AACA,iBAAiB,SAAS,GAAG,oCAAoC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,iBAAiB,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAC7D;AACA;AACA,mBAAmB,QAAQ;AAC3B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,iBAAiB,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAC7D;AACA;AACA,0BAA0B,QAAQ,MAAM,QAAQ;AAChD,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,iBAAiB,0CAA0C;AAC3D,iBAAiB,+BAA+B;AAChD,iBAAiB,oBAAoB;AACrC,iBAAiB,SAAS;AAC1B;AACA;AACA,yBAAyB,QAAQ,MAAM,QAAQ;AAC/C,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA,0BAA0B,QAAQ,WAAW,QAAQ,aAAa,QAAQ;AAC1E,qBAAqB,QAAQ,cAAc,QAAQ,cAAc;AACjE,6BAA6B,QAAQ,IAAI,QAAQ;AACjD,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAkB;AACrC;AACA,yBAAyB,SAAS;AAClC;AACA;AACA,mBAAmB,OAAO,QAAQ;AAClC;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,6CAA6C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA,qCAAqC;AACrC,mBAAmB,qEAAkB;AACrC;AACA,oBAAoB,qEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,WAAW,SAAS;AACpB,QAAQ,KAAK;AACb,QAAQ;AACR,8BAA8B,eAAe,GAAG,sBAAsB;AACtE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA,cAAc,SAAS;AACvB,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,6CAA6C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA,YAAY,SAAS;AACrB,QAAQ,KAAK;AACb,QAAQ;AACR,kBAAkB,eAAe,GAAG,sBAAsB;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;;;;;;AC7sCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,sEAAmB;AACvC;AACA;AACA,6BAA6B,UAAU,KAAK,MAAM,KAAK,OAAO;AAC9D;AACA,mBAAmB,cAAc,KAAK,MAAM,KAAK,UAAU,KAAK,OAAO;AACvE,wBAAwB,UAAU,KAAK,OAAO;AAC9C,kBAAkB,OAAO,GAAG,OAAO;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB;AACA,iBAAiB,SAAS,GAAG,YAAY;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,SAAS,OAAO,SAAS;AAC5C;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,uBAAuB,iBAAiB,IAAI,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA,8CAA8C,EAAE;AAChD,8CAA8C,EAAE;AAChD;AACA,uBAAuB,iBAAiB,IAAI,iBAAiB;AAC7D;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACO;AACP,oBAAoB,sEAAmB;AACvC;AACA;AACA,wBAAwB,WAAW,gBAAgB,WAAW;AAC9D;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC,iDAAiD,UAAU,EAAE;AAC7D;AACA;AACA;AACA,gCAAgC,UAAU,WAAW,EAAE,aAAa,WAAW;AAC/E,SAAS;AACT;AACA,UAAU,MAAM;AAChB,UAAU,MAAM;AAChB,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA,UAAU;AACV,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA,qC;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACS;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC,uBAAuB,0DAAW;AAClC,0BAA0B,0DAAW;AACrC,kEAAkE,2BAA2B;AAC7F,mDAAmD,iBAAiB,KAAK,UAAU;AACnF;AACA,mBAAmB;AACnB,cAAc,sBAAsB,KAAK,wBAAwB;AACjE,YAAY;AACZ,qBAAqB;AACrB,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV,cAAc,sBAAsB,KAAK,wBAAwB;AACjE,YAAY;AACZ,qBAAqB;AACrB,gBAAgB,sBAAsB,KAAK,wBAAwB;AACnE,cAAc;AACd,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM,GAAG,gCAAgC,EAAE,WAAW,EAAE;AACtE,sCAAsC,aAAa,KAAK,UAAU,WAAW,EAAE,EAAE;AACjF;AACA;AACA,0BAA0B,UAAU;AACpC;AACA,UAAU,MAAM;AAChB,UAAU,MAAM;AAChB,UAAU;AACV;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA;AACA,2BAA2B,mEAAiB;AAC5C,sBAAsB,mEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,EAAE,YAAY,EAAE;AAC5D,kCAAkC,eAAe,cAAc,EAAE,YAAY,EAAE;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,WAAW,WAAW,WAAW,GAAG,MAAM;AAClD,QAAQ,WAAW,aAAa,WAAW,GAAG,QAAQ;;AAEtD;AACA,UAAU,MAAM;AAChB,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AAC5C;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,qEAAkB;AACnC;AACA,WAAW,2EAAwB;AACnC;AACO;AACP;AACA,yCAAyC,aAAa;AACtD,eAAe,mBAAmB;AAClC;AACA;AACA;AACO;AACP;AACA;AACA,0CAA0C,cAAc,eAAe,aAAa;AACpF;AACA;AACA,qBAAqB,4BAA4B;AACjD,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AAC+M;AAC1G;AAC1I;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6EAAsC;AACtE;AACA;AACA,qCAAqC,6EAAsC;AAC3E;AACA;AACA;AACA,qCAAqC,2EAAoC;AACzE;AACA;AACA;AACA,qCAAqC,2EAAoC;AACzE;AACA;AACA;AACA,qCAAqC,mFAA4C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0DAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB,KAAK,qBAAqB,OAAO,MAAM;AAChG;AACA,wCAAwC,wBAAwB;AAChE,qCAAqC,mBAAmB,IAAI,4BAA4B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iFAAsC;AAClF;AACA;AACA;AACA,gCAAgC,mFAAwC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6EAAsC;AACnD,mBAAmB,oFAAuC;AAC1D,aAAa,6EAAsC;AACnD,mBAAmB,2FAA8C;AACjE,aAAa,2EAAoC;AACjD,mBAAmB,qFAAwC;AAC3D,aAAa,2EAAoC;AACjD,mBAAmB,qFAAwC;AAC3D,aAAa,mFAA4C;AACzD,mBAAmB,2FAA8C;AACjE;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA,mBAAmB,6EAAsC;AACzD;AACA,eAAe,2EAAoC;AACnD;AACA;AACA,eAAe,6EAAsC;AACrD;AACA,WAAW,2EAAoC;AAC/C;AACA;AACA,2BAA2B,0DAAmB;AAC9C,eAAe,6EAAsC;AACrD;AACA,gCAAgC,0DAAmB;AACnD;AACA;AACA,gCAAgC,4DAAqB;AACrD,2BAA2B,0DAAmB;AAC9C,eAAe,mFAA4C;AAC3D;AACA,oDAAoD,eAAe;AACnE;AACA;AACA,cAAc,gBAAgB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,SAAS;AAChF;AACA,2C;;;;;;;;;;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC;AACA;AACA;AACA,UAAU,MAAM;AAChB,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,kCAAkC,iBAAiB,IAAI,UAAU;AACjE;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAC/C;AACP;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,sBAAsB,mEAAiB;AACvC;AACA;AACA;AACA,QAAQ,MAAM;AACd,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACM;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA,sBAAsB,mEAAiB;AACvC,4BAA4B,6DAAc;AAC1C;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,kCAAkC,+BAA+B;AACjE,gCAAgC,2BAA2B,KAAK,2BAA2B;AAC3F,wCAAwC,qBAAqB,KAAK,UAAU;AAC5E;AACA;AACA,QAAQ,MAAM;AACd;AACA,oBAAoB;AACpB,WAAW,WAAW;AACtB,sBAAsB;AACtB;AACA,UAAU;AACV,aAAa,2BAA2B,KAAK,2BAA2B;AACxE,sBAAsB;AACtB,aAAa,WAAW;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AAClD,yBAAyB;AACzB,2BAA2B;AAC3B;AACP;AACA,mCAAmC,MAAM;AACzC;AACA;AACO,oDAAoD;AACpD;AACP;AACA;AACO;AACP;AACA;AACO,wBAAwB;AAC/B,uC;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB;AACzB;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACR;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAW;AACpC,sBAAsB,mEAAiB;AACvC,6BAA6B,8DAAe;AAC5C;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA,UAAU,MAAM;AAChB,kCAAkC,aAAa;;AAE/C,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACmB;AACnB,mC;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACD;AACA;AACQ;AACH;AACD;AAC/C;AACkC;AAClC;AACA;AACA;AACA,SAAS;AACT;AACO;AACP,IAAI,0DAAG;AACP;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACF;AACF;AACvC;AACP;AACA,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gEAAa;AACpF;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAa,8BAA8B,yBAAyB,0BAA0B;AACpH;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,2BAA2B,0DAAG;AAC9B;AACA,8BAA8B,MAAM,GAAG,OAAO;AAC9C;AACA;AACA;AACA,8BAA8B,MAAM,GAAG,OAAO;AAC9C,wBAAwB,eAAe,GAAG,eAAe;AACzD;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E,kDAAkD,iBAAiB;AACnE;AACA;AACO;AACP,WAAW,qEAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,0DAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAiB;AAC/C;AACA;AACA,eAAe,qEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAAwB;AAC3C;AACA,eAAe,2EAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,6DAAe;AAClC;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA,mBAAmB,6DAAe;AAClC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,6DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,mBAAmB,6DAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,6DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,6DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,6DAAe;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAW,mCAAmC,OAAO;AACjE;AACA;AACA,KAAK;AACL;AACA,sC","file":"vendors-node_modules_tensorflow_tfjs-backend-webgl_dist_index_js.bundle.js","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(t => {\n        if (t != null) {\n            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors in the CPU backend.`);\n        }\n    });\n}\n//# sourceMappingURL=cpu_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Abs, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function simpleAbsImpl(vals) {\n    const resultValues = new Float32Array(vals.length);\n    for (let i = 0; i < vals.length; ++i) {\n        resultValues[i] = Math.abs(vals[i]);\n    }\n    return resultValues;\n}\nexport const abs = (args) => {\n    const { x } = args.inputs;\n    const cpuBackend = args.backend;\n    assertNotComplex(x, 'abs');\n    let resultValues = new Float32Array(util.sizeFromShape(x.shape));\n    const values = cpuBackend.data.get(x.dataId).values;\n    resultValues = simpleAbsImpl(values);\n    return cpuBackend.makeOutput(resultValues, x.shape, 'float32');\n};\nexport const absConfig = {\n    kernelName: Abs,\n    backendName: 'cpu',\n    kernelFunc: abs,\n};\n//# sourceMappingURL=Abs.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Add } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/binary_utils';\nexport const addImpl = createSimpleBinaryKernelImpl(((a, b) => a + b));\nexport const addComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return { real: aReal + bReal, imag: aImag + bImag };\n}));\nexport const add = binaryKernelFunc(Add, addImpl, addComplexImpl);\nexport const addConfig = {\n    kernelName: Add,\n    backendName: 'cpu',\n    kernelFunc: add\n};\n//# sourceMappingURL=Add.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, util } from '@tensorflow/tfjs-core';\nexport function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {\n    const weightsSize = util.sizeFromShape(weightsShape);\n    const outVals = util.makeZerosTypedArray(size, weightsDtype);\n    for (let i = 0; i < xVals.length; i++) {\n        const value = xVals[i];\n        if (value < 0) {\n            throw new Error('Input x must be non-negative!');\n        }\n        if (value >= size) {\n            continue;\n        }\n        if (weightsSize > 0) {\n            outVals[value] += weightsVals[i];\n        }\n        else {\n            outVals[value] += 1;\n        }\n    }\n    return outVals;\n}\nexport function bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {\n    const numRows = xBuf.shape[0];\n    const numCols = xBuf.shape[1];\n    const outBuf = buffer([numRows, size], weightsBuf.dtype);\n    for (let i = 0; i < numRows; i++) {\n        for (let j = 0; j < numCols; j++) {\n            const value = xBuf.get(i, j);\n            if (value < 0) {\n                throw new Error('Input x must be non-negative!');\n            }\n            if (value >= size) {\n                continue;\n            }\n            if (binaryOutput) {\n                outBuf.set(1, i, value);\n            }\n            else {\n                if (weightsBuf.size > 0) {\n                    outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);\n                }\n                else {\n                    outBuf.set(outBuf.get(i, value) + 1, i, value);\n                }\n            }\n        }\n    }\n    return outBuf;\n}\n//# sourceMappingURL=Bincount_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Cast, util } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { zeros } from '../utils/zeros_impl';\nimport { complex } from './Complex';\nimport { identity } from './Identity';\nimport { real } from './Real';\nexport function cast(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { dtype } = attrs;\n    // Casting to complex64.\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return identity({ inputs: { x }, backend });\n        }\n        const zerosTensorInfo = zeros(backend, x.shape, x.dtype);\n        const floatX = cast({ inputs: { x }, backend, attrs: { dtype: 'float32' } });\n        const result = complex({ inputs: { real: floatX, imag: zerosTensorInfo }, backend });\n        backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n        backend.disposeIntermediateTensorInfo(floatX);\n        return result;\n    }\n    // Casting from complex64\n    if (x.dtype === 'complex64') {\n        const realPart = real({ inputs: { input: x }, backend });\n        const result = cast({ inputs: { x: realPart }, backend, attrs: { dtype } });\n        backend.disposeIntermediateTensorInfo(realPart);\n        return result;\n    }\n    if (!util.hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        const result = identity({ inputs: { x }, backend });\n        return { dataId: result.dataId, shape: result.shape, dtype };\n    }\n    if (dtype === 'int32') {\n        const values = backend.data.get(x.dataId).values;\n        const resultValues = Int32Array.from(values);\n        return backend.makeTensorInfo(x.shape, 'int32', resultValues);\n    }\n    if (dtype === 'bool') {\n        // This is essentially the result of notEqual(x, 0). We avoid using\n        // kernel notEqual to avoid circular dependency, i.e. binary_utils ->\n        // cast -> notEqual -> binary_utils.\n        const xVals = backend.data.get(x.dataId).values;\n        const zero = util.toTypedArray([0], x.dtype);\n        const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => (a !== b) ? 1 : 0)(x.shape, [], xVals, zero, 'bool');\n        return backend.makeTensorInfo(resultShape, 'bool', resultData);\n    }\n    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\nexport const castConfig = {\n    kernelName: Cast,\n    backendName: 'cpu',\n    kernelFunc: cast\n};\n//# sourceMappingURL=Cast.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Ceil } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));\nexport const ceil = unaryKernelFuncFromImpl(Ceil, ceilImpl);\nexport const ceilConfig = {\n    kernelName: Ceil,\n    backendName: 'cpu',\n    kernelFunc: ceil,\n};\n//# sourceMappingURL=Ceil.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Complex } from '@tensorflow/tfjs-core';\nexport function complex(args) {\n    const { inputs, backend } = args;\n    const { real, imag } = inputs;\n    const realVals = backend.data.get(real.dataId).values;\n    const imagVals = backend.data.get(imag.dataId).values;\n    const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n    const complex = backend.data.get(complexInfo.dataId);\n    // The complex tensor owns the underlying real and imag tensorInfos, only the\n    // complex tensor tracks refCount, when complexData is disposed the\n    // underlying tensorData will be disposed.\n    complex.complexTensorInfos = {\n        real: backend.makeTensorInfo(real.shape, 'float32', realVals),\n        imag: backend.makeTensorInfo(imag.shape, 'float32', imagVals)\n    };\n    return complexInfo;\n}\nexport const complexConfig = {\n    kernelName: Complex,\n    backendName: 'cpu',\n    kernelFunc: complex\n};\n//# sourceMappingURL=Complex.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function concatImpl(inputs, outShape, dtype, simplyConcat) {\n    const outVals = util.getArrayFromDType(dtype, util.sizeFromShape(outShape));\n    if (simplyConcat && dtype !== 'string') {\n        // Use built-in TypedArray.set() method for speed.\n        let offset = 0;\n        inputs.forEach(input => {\n            const size = util.sizeFromShape(input.shape);\n            outVals.set(input.vals, offset);\n            offset += size;\n        });\n    }\n    else {\n        let colOffset = 0;\n        inputs.forEach(input => {\n            const decodedData = dtype === 'string' ?\n                backend_util.fromUint8ToStringArray(input.vals) :\n                input.vals;\n            let tIdx = 0;\n            for (let row = 0; row < input.shape[0]; ++row) {\n                const resIdx = row * outShape[1] + colOffset;\n                for (let col = 0; col < input.shape[1]; ++col) {\n                    outVals[resIdx + col] = decodedData[tIdx++];\n                }\n            }\n            colOffset += input.shape[1];\n        });\n    }\n    return outVals;\n}\n//# sourceMappingURL=Concat_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Exp } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));\nexport const exp = unaryKernelFuncFromImpl(Exp, expImpl);\nexport const expConfig = {\n    kernelName: Exp,\n    backendName: 'cpu',\n    kernelFunc: exp,\n};\n//# sourceMappingURL=Exp.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Expm1 } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));\nexport const expm1 = unaryKernelFuncFromImpl(Expm1, expm1Impl);\nexport const expm1Config = {\n    kernelName: Expm1,\n    backendName: 'cpu',\n    kernelFunc: expm1,\n};\n//# sourceMappingURL=Expm1.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Floor } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));\nexport const floor = unaryKernelFuncFromImpl(Floor, floorImpl);\nexport const floorConfig = {\n    kernelName: Floor,\n    backendName: 'cpu',\n    kernelFunc: floor,\n};\n//# sourceMappingURL=Floor.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {\n    const outBuf = buffer(flattenOutputShape, xBuf.dtype);\n    for (let i = 0; i < outBuf.size; ++i) {\n        const newLoc = outBuf.indexToLoc(i);\n        const originalLoc = newLoc.slice();\n        const batchIdx = originalLoc[0];\n        const indicesIdx = originalLoc[2];\n        const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);\n        originalLoc[2] = indicesBuf.values[indicesIndex];\n        const originalIndex = xBuf.locToIndex(originalLoc);\n        outBuf.values[i] = xBuf.values[originalIndex];\n    }\n    return outBuf;\n}\n//# sourceMappingURL=GatherV2_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Greater } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const greaterImpl = createSimpleBinaryKernelImpl((a, b) => (a > b) ? 1 : 0);\nexport const greater = binaryKernelFunc(Greater, greaterImpl, null /* complexImpl */, 'bool');\nexport const greaterConfig = {\n    kernelName: Greater,\n    backendName: 'cpu',\n    kernelFunc: greater\n};\n//# sourceMappingURL=Greater.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Identity } from '@tensorflow/tfjs-core';\nexport function identity(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    backend.incRef(x.dataId);\n    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };\n}\nexport const identityConfig = {\n    kernelName: Identity,\n    backendName: 'cpu',\n    kernelFunc: identity\n};\n//# sourceMappingURL=Identity.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Less } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const lessImpl = createSimpleBinaryKernelImpl((a, b) => (a < b) ? 1 : 0);\nexport const less = binaryKernelFunc(Less, lessImpl, null /* complexImpl */, 'bool');\nexport const lessConfig = {\n    kernelName: Less,\n    backendName: 'cpu',\n    kernelFunc: less\n};\n//# sourceMappingURL=Less.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function linSpaceImpl(start, stop, num) {\n    const step = (stop - start) / (num - 1);\n    const values = util.makeZerosTypedArray(num, 'float32');\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n//# sourceMappingURL=LinSpace_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Log } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));\nexport const log = unaryKernelFuncFromImpl(Log, logImpl);\nexport const logConfig = {\n    kernelName: Log,\n    backendName: 'cpu',\n    kernelFunc: log,\n};\n//# sourceMappingURL=Log.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function maxImpl(aVals, reduceSize, outShape, dtype) {\n    const vals = util.getTypedArrayFromDType(dtype, util.sizeFromShape(outShape));\n    for (let i = 0; i < vals.length; ++i) {\n        const offset = i * reduceSize;\n        let max = aVals[offset];\n        for (let j = 0; j < reduceSize; ++j) {\n            const value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n            }\n        }\n        vals[i] = max;\n    }\n    return vals;\n}\n//# sourceMappingURL=Max_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Maximum } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const maximumImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => Math.max(aValue, bValue)));\nexport const maximum = binaryKernelFunc(Maximum, maximumImpl);\nexport const maximumConfig = {\n    kernelName: Maximum,\n    backendName: 'cpu',\n    kernelFunc: maximum\n};\n//# sourceMappingURL=Maximum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Minimum } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const minimumImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => Math.min(aValue, bValue)));\nexport const minimum = binaryKernelFunc(Minimum, minimumImpl);\nexport const minimumConfig = {\n    kernelName: Minimum,\n    backendName: 'cpu',\n    kernelFunc: minimum\n};\n//# sourceMappingURL=Minimum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Multiply } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/binary_utils';\nexport const multiplyImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue * bValue));\nexport const multiplyComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return {\n        real: aReal * bReal - aImag * bImag,\n        imag: aReal * bImag + aImag * bReal\n    };\n}));\nexport const multiply = binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);\nexport const multiplyConfig = {\n    kernelName: Multiply,\n    backendName: 'cpu',\n    kernelFunc: multiply\n};\n//# sourceMappingURL=Multiply.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Neg, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { multiplyImpl } from './Multiply';\nexport function negImpl(xVals, xShape, xDtype) {\n    const minusOne = util.createScalarValue(-1, xDtype);\n    return multiplyImpl([], xShape, minusOne, xVals, xDtype);\n}\nexport function neg(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    assertNotComplex(x, 'neg');\n    const xVals = backend.data.get(x.dataId).values;\n    const [res, newShape] = negImpl(xVals, x.shape, x.dtype);\n    return backend.makeTensorInfo(newShape, x.dtype, res);\n}\nexport const negConfig = {\n    kernelName: Neg,\n    backendName: 'cpu',\n    kernelFunc: neg\n};\n//# sourceMappingURL=Neg.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { NotEqual } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const notEqualImpl = createSimpleBinaryKernelImpl(((a, b) => (a !== b) ? 1 : 0));\nexport const notEqual = binaryKernelFunc(NotEqual, notEqualImpl, null /* complexOp */, 'bool');\nexport const notEqualConfig = {\n    kernelName: NotEqual,\n    backendName: 'cpu',\n    kernelFunc: notEqual\n};\n//# sourceMappingURL=NotEqual.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function prodImpl(xShape, xDtype, xVals, reductionAxes) {\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n    const outDtype = upcastType(xDtype, 'int32');\n    const outVals = util.makeZerosTypedArray(util.sizeFromShape(outShape), outDtype);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    for (let i = 0; i < outVals.length; ++i) {\n        const offset = i * reduceSize;\n        let prod = 1;\n        for (let j = 0; j < reduceSize; ++j) {\n            prod *= xVals[offset + j];\n        }\n        outVals[i] = prod;\n    }\n    return { outVals, outShape, outDtype };\n}\nexport function prod(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    assertNotComplex(x, 'prod');\n    const xRank = x.shape.length;\n    const axes = util.parseAxisParam(axis, x.shape);\n    const permutation = backend_util.getAxesPermutation(axes, xRank);\n    let reductionAxes = axes;\n    let permutedX = x;\n    const intermediateTensorInfos = [];\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutation } });\n        intermediateTensorInfos.push(permutedX);\n        reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n    }\n    const xVals = backend.data.get(permutedX.dataId).values;\n    const { outVals, outShape, outDtype } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n    let resultShape = outShape;\n    if (keepDims) {\n        resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n    }\n    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nexport const prodConfig = {\n    kernelName: Prod,\n    backendName: 'cpu',\n    kernelFunc: prod\n};\n//# sourceMappingURL=Prod.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function rangeImpl(start, stop, step, dtype) {\n    const sameStartStop = start === stop;\n    const increasingRangeNegativeStep = start < stop && step < 0;\n    const decreasingRangePositiveStep = stop < start && step > 1;\n    if (sameStartStop || increasingRangeNegativeStep ||\n        decreasingRangePositiveStep) {\n        return util.makeZerosTypedArray(0, dtype);\n    }\n    const numElements = Math.abs(Math.ceil((stop - start) / step));\n    const values = util.makeZerosTypedArray(numElements, dtype);\n    if (stop < start && step === 1) {\n        // Auto adjust the step's sign if it hasn't been set\n        // (or was set to 1)\n        step = -1;\n    }\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n//# sourceMappingURL=Range_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Real } from '@tensorflow/tfjs-core';\nexport function real(args) {\n    const { inputs, backend } = args;\n    const { input } = inputs;\n    const real = backend.data.get(input.dataId).complexTensorInfos.real;\n    const realVal = backend.data.get(real.dataId).values;\n    // When complex tensor is disposed, its underlying parts will be disposed too.\n    // Make new tensor out of the real value of the complex. This makes sure the\n    // value is still accessible even if complex tensor is disposed.\n    return backend.makeTensorInfo(real.shape, real.dtype, realVal);\n}\nexport const realConfig = {\n    kernelName: Real,\n    backendName: 'cpu',\n    kernelFunc: real\n};\n//# sourceMappingURL=Real.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Rsqrt } from '@tensorflow/tfjs-core';\nimport { createSimpleUnaryImpl } from '../utils/unary_impl';\nimport { unaryKernelFuncFromImpl } from '../utils/unary_utils';\nexport const rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));\nexport const rsqrt = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);\nexport const rsqrtConfig = {\n    kernelName: Rsqrt,\n    backendName: 'cpu',\n    kernelFunc: rsqrt,\n};\n//# sourceMappingURL=Rsqrt.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function sliceImpl(vals, begin, size, shape, dtype) {\n    const isContinous = slice_util.isSliceContinous(shape, begin, size);\n    const length = util.sizeFromShape(size);\n    const xStrides = util.computeStrides(shape);\n    if (isContinous) {\n        const flatOffset = slice_util.computeFlatOffset(begin, xStrides);\n        if (dtype === 'string') {\n            return vals.slice(flatOffset, flatOffset + length);\n        }\n        return vals.subarray(flatOffset, flatOffset + length);\n    }\n    const decodedData = dtype === 'string' ?\n        backend_util.fromUint8ToStringArray(vals) :\n        vals;\n    const inBuf = buffer(shape, dtype, decodedData);\n    const outBuf = buffer(size, dtype);\n    for (let i = 0; i < outBuf.size; ++i) {\n        const outLoc = outBuf.indexToLoc(i);\n        const inLoc = outLoc.map((idx, j) => idx + begin[j]);\n        outBuf.set(inBuf.get(...inLoc), ...outLoc);\n    }\n    if (dtype === 'string') {\n        return backend_util.fromStringArrayToUint8(outBuf.values);\n    }\n    return outBuf.values;\n}\nexport function slice(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { begin, size } = attrs;\n    assertNotComplex(x, 'slice');\n    const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n    slice_util.assertParamsValid(x, $begin, $size);\n    const vals = backend.data.get(x.dataId).values;\n    const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outVals);\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'cpu',\n    kernelFunc: slice\n};\n//# sourceMappingURL=Slice.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SquaredDifference } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc } from '../utils/binary_utils';\nexport const squaredDifferenceImpl = createSimpleBinaryKernelImpl(((a, b) => {\n    const diff = a - b;\n    return diff * diff;\n}));\nexport const squaredDifference = binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);\nexport const squaredDifferenceConfig = {\n    kernelName: SquaredDifference,\n    backendName: 'cpu',\n    kernelFunc: squaredDifference\n};\n//# sourceMappingURL=SquaredDifference.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function stridedSliceImpl(outShape, xBuf, strides, begin) {\n    const outBuf = buffer(outShape, xBuf.dtype);\n    for (let i = 0; i < outBuf.size; i++) {\n        const loc = outBuf.indexToLoc(i);\n        const newLoc = new Array(loc.length);\n        for (let j = 0; j < newLoc.length; j++) {\n            newLoc[j] = loc[j] * strides[j] + begin[j];\n        }\n        outBuf.set(xBuf.get(...newLoc), ...loc);\n    }\n    return outBuf;\n}\n//# sourceMappingURL=StridedSlice_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sub } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { binaryKernelFunc, createComplexBinaryKernelImpl } from '../utils/binary_utils';\nexport const subImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue - bValue));\nexport const subComplexImpl = createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n    return { real: aReal - bReal, imag: aImag - bImag };\n}));\nexport const sub = binaryKernelFunc(Sub, subImpl, subComplexImpl);\nexport const subConfig = {\n    kernelName: Sub,\n    backendName: 'cpu',\n    kernelFunc: sub\n};\n//# sourceMappingURL=Sub.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\n/**\n * An implementation of the tile kernel shared between webgl and cpu for string\n * tensors only.\n */\nexport function tileImpl(xBuf, reps) {\n    const newShape = new Array(xBuf.rank);\n    for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = xBuf.shape[i] * reps[i];\n    }\n    const result = buffer(newShape, xBuf.dtype);\n    for (let i = 0; i < result.values.length; ++i) {\n        const newLoc = result.indexToLoc(i);\n        const originalLoc = new Array(xBuf.rank);\n        for (let j = 0; j < originalLoc.length; j++) {\n            originalLoc[j] = newLoc[j] % xBuf.shape[j];\n        }\n        const originalIndex = xBuf.locToIndex(originalLoc);\n        result.values[i] = xBuf.values[originalIndex];\n    }\n    return result;\n}\n//# sourceMappingURL=Tile_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/** An implementation of the TopK kernel shared between webgl and cpu. */\nimport { buffer, util } from '@tensorflow/tfjs-core';\nexport function topKImpl(x, xShape, xDtype, k, sorted) {\n    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n    const lastDim = xShape[xShape.length - 1];\n    const [batch, size] = [x.length / lastDim, lastDim];\n    const allTopKVals = util.getTypedArrayFromDType(xDtype, batch * k);\n    const allTopKIndices = util.getTypedArrayFromDType('int32', batch * k);\n    for (let b = 0; b < batch; b++) {\n        const offset = b * size;\n        const vals = x.subarray(offset, offset + size);\n        const valAndInd = [];\n        for (let i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort((a, b) => b.value - a.value);\n        const outOffset = b * k;\n        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);\n        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);\n        for (let i = 0; i < k; i++) {\n            topKVals[i] = valAndInd[i].value;\n            topKIndices[i] = valAndInd[i].index;\n        }\n    }\n    // Reshape back to the original input shape, except that the last\n    // dimension is k.\n    const outputShape = xShape.slice();\n    outputShape[outputShape.length - 1] = k;\n    return [\n        buffer(outputShape, xDtype, allTopKVals),\n        buffer(outputShape, 'int32', allTopKIndices)\n    ];\n}\n//# sourceMappingURL=TopK_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transpose } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transposeImpl } from './Transpose_impl';\nexport function transpose(args) {\n    const { inputs, attrs, backend } = args;\n    const { x } = inputs;\n    const { perm } = attrs;\n    assertNotComplex(x, 'transpose');\n    const xRank = x.shape.length;\n    const newShape = new Array(xRank);\n    for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = x.shape[perm[i]];\n    }\n    const values = backend.data.get(x.dataId).values;\n    const result = transposeImpl(values, x.shape, x.dtype, perm, newShape);\n    const dataId = backend.write(result, newShape, x.dtype);\n    return { dataId, shape: newShape, dtype: x.dtype };\n}\nexport const transposeConfig = {\n    kernelName: Transpose,\n    backendName: 'cpu',\n    kernelFunc: transpose\n};\n//# sourceMappingURL=Transpose.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function transposeImpl(xVals, xShape, dtype, perm, newShape) {\n    const xRank = xShape.length;\n    const xSize = util.sizeFromShape(xShape);\n    const xStrides = util.computeStrides(xShape);\n    const newStrides = util.computeStrides(newShape);\n    const result = util.getTypedArrayFromDType(dtype, util.sizeFromShape(newShape));\n    for (let i = 0; i < xSize; ++i) {\n        const loc = util.indexToLoc(i, xRank, xStrides);\n        // Permute location.\n        const newLoc = new Array(loc.length);\n        for (let i = 0; i < newLoc.length; i++) {\n            newLoc[i] = loc[perm[i]];\n        }\n        const newIndex = util.locToIndex(newLoc, xRank, newStrides);\n        result[newIndex] = xVals[i];\n    }\n    return result;\n}\n//# sourceMappingURL=Transpose_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TensorBuffer, util } from '@tensorflow/tfjs-core';\nexport function uniqueImpl(values, axis, shape, dtype) {\n    // Normalize and validate axis.\n    const $axis = util.parseAxisParam(axis, shape)[0];\n    // Calculate the new shape that is suitable for extracting data along the\n    // given axis.\n    //\n    // The rank is 3.\n    // The size of the 1st dimension is the size of all the axes < the given axis.\n    // The size of the 2nd dimension is the same as the size of the given axis.\n    // The size of the 3rd dimension is the size of all the axes > the given axis.\n    //\n    // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the\n    // newShape would be: [2*3, 5, 4].\n    //\n    // Note that this is not the final output shape. This will be the shape for an\n    // intermediate TensorBuffer (see inputBuffer below) to allow us to extract\n    // values along the given axis. To demonstrate how it works, consider the\n    // following example:\n    //\n    // Input: a 3D tensor, with shape [1, 2, 3]\n    // [\n    //   [\n    //      [1,2,3],\n    //      [4,5,6]\n    //   ]\n    // ]\n    // Axis: 2 (the last axis).\n    // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].\n    //\n    // For this example, newShape would be: [2, 3, 1], where 2 is calculated from\n    // 1*2. The re-shaped data would look like:\n    //\n    // [\n    //   [\n    //     [1], [2], [3]\n    //   ],\n    //   [\n    //     [4], [5], [6]\n    //   ]\n    // ]\n    //\n    // Then, we can construct a 3-level nested loop by the following dimension\n    // order to extract the values along the axis (dimension1):\n    // i: dimension1       // 0,1,2 (newShape[1])\n    //   m: dimension0     // 0,1   (newShape[0])\n    //     n: dimension2   // 0     (newShape[2])\n    //\n    //                       m, i, n\n    //                      ---------\n    // Iteration 0: data at [0, 0, 0] => \"1\"\n    // Iteration 1: data at [1, 0, 0] => \"4\"\n    // We got [1,4].\n    // Iteration 2: data at [0, 1, 0] => \"2\"\n    // Iteration 3: data at [1, 1, 0] => \"5\"\n    // We got [2,5].\n    // Iteration 4: data at [0, 2, 0] => \"3\"\n    // Iteration 5: data at [1, 2, 0] => \"6\"\n    // We got [3,6].\n    const newShape = [1, shape[0], 1];\n    for (let i = 0; i < $axis; i++) {\n        newShape[0] *= shape[i];\n    }\n    newShape[1] = shape[$axis];\n    for (let i = $axis + 1; i < shape.length; i++) {\n        newShape[2] *= shape[i];\n    }\n    // A map from unique elements (their string representations) to their values\n    // in \"indices\" (below).\n    const uniqueElements = {};\n    // The indices of each unique element in the original tensor along the given\n    // axis. It is 1D and has the same size as the given axis.\n    const indices = new Int32Array(shape[$axis]);\n    // Create a buffer so we can easily extract value at a given location.\n    const inputBuffer = new TensorBuffer(newShape, dtype, values);\n    // The indices along the given axis that have unique elements. This is a\n    // de-duped version of \"indices\" above.\n    const uniqueIndices = [];\n    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;\n    for (let i = 0; i < shape[$axis]; i++) {\n        // Extract values along the axis.\n        let element;\n        if (is1DTensor) {\n            // Fast path for 1D tensor input.\n            element = values[i].toString();\n        }\n        else {\n            const axisValues = [];\n            for (let m = 0; m < newShape[0]; m++) {\n                for (let n = 0; n < newShape[2]; n++) {\n                    axisValues.push(inputBuffer.get(m, i, n));\n                }\n            }\n            element = axisValues.join(',');\n        }\n        // Dedup and update various indices.\n        if (uniqueElements[element] !== undefined) {\n            indices[i] = uniqueElements[element];\n        }\n        else {\n            const uniqueIndex = Object.keys(uniqueElements).length;\n            uniqueElements[element] = uniqueIndex;\n            indices[i] = uniqueIndex;\n            uniqueIndices.push(i);\n        }\n    }\n    // Now we know where each of the unique elements are located along the axis\n    // (uniqueIndices). Extract them from input buffer and store them in the\n    // output buffer.\n    const outputTmpShape = newShape.slice();\n    outputTmpShape[1] = Object.keys(uniqueElements).length;\n    const outputBuffer = new TensorBuffer(outputTmpShape, dtype);\n    uniqueIndices.forEach((uniqueElementIndex, i) => {\n        for (let m = 0; m < newShape[0]; m++) {\n            for (let n = 0; n < newShape[2]; n++) {\n                outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);\n            }\n        }\n    });\n    // The output shape can be calculated from the input shape with the size of\n    // the given axis replaced by the number of unique elements along that axis.\n    const outputShape = shape.slice();\n    outputShape[$axis] = outputTmpShape[1];\n    return {\n        outputValues: outputBuffer.values,\n        outputShape,\n        indices,\n    };\n}\n//# sourceMappingURL=Unique_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Shared functionality among backends.\nexport { simpleAbsImpl } from './kernels/Abs';\nexport { addImpl } from './kernels/Add';\nexport { bincountImpl, bincountReduceImpl } from './kernels/Bincount_impl';\nexport { ceilImpl } from './kernels/Ceil';\nexport { concatImpl } from './kernels/Concat_impl';\nexport { expImpl } from './kernels/Exp';\nexport { expm1Impl } from './kernels/Expm1';\nexport { floorImpl } from './kernels/Floor';\nexport { gatherV2Impl } from './kernels/GatherV2_impl';\nexport { greaterImpl } from './kernels/Greater';\nexport { lessImpl } from './kernels/Less';\nexport { linSpaceImpl } from './kernels/LinSpace_impl';\nexport { logImpl } from './kernels/Log';\nexport { maxImpl } from './kernels/Max_impl';\nexport { maximumImpl } from './kernels/Maximum';\nexport { minimumImpl } from './kernels/Minimum';\nexport { multiplyImpl } from './kernels/Multiply';\nexport { negImpl } from './kernels/Neg';\nexport { notEqualImpl } from './kernels/NotEqual';\nexport { prodImpl } from './kernels/Prod';\nexport { rangeImpl } from './kernels/Range_impl';\nexport { rsqrtImpl } from './kernels/Rsqrt';\nexport { sliceImpl } from './kernels/Slice';\nexport { squaredDifferenceImpl } from './kernels/SquaredDifference';\nexport { stridedSliceImpl } from './kernels/StridedSlice_impl';\nexport { subImpl } from './kernels/Sub';\nexport { tileImpl } from './kernels/Tile_impl';\nexport { topKImpl } from './kernels/TopK_impl';\nexport { transposeImpl } from './kernels/Transpose_impl';\nexport { uniqueImpl } from './kernels/Unique_impl';\n//# sourceMappingURL=shared.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nexport function createSimpleBinaryKernelImpl(op) {\n    return (aShape, bShape, aVals, bVals, dtype) => {\n        const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const resultRank = newShape.length;\n        const resultStrides = util.computeStrides(newShape);\n        const resultSize = util.sizeFromShape(newShape);\n        const result = util.getTypedArrayFromDType(dtype, resultSize);\n        const aRank = aShape.length;\n        const bRank = bShape.length;\n        const aStrides = util.computeStrides(aShape);\n        const bStrides = util.computeStrides(bShape);\n        const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < result.length; ++i) {\n                result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            for (let i = 0; i < result.length; ++i) {\n                const loc = util.indexToLoc(i, resultRank, resultStrides);\n                const aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n                const bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n                result[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return [result, newShape];\n    };\n}\n//# sourceMappingURL=binary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from '../kernels/Cast';\nimport { complex } from '../kernels/Complex';\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param name Kernel name.\n * @param binaryKernelImpl A `SimpleBinaryKernelImpl` for the kernel.\n * @param binaryKernelComplexImpl Optional. If exists, represents a\n *     `ComplexBinaryKernelImpl` for the kernel, will be used when input dtype\n *     is `complex64`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {\n    if (complexImpl == null) {\n        return ({ inputs, backend }) => {\n            const { a, b } = inputs;\n            const cpuBackend = backend;\n            assertNotComplex([a, b], name);\n            const aVals = cpuBackend.data.get(a.dataId).values;\n            const bVals = cpuBackend.data.get(b.dataId).values;\n            const $dtype = dtype || a.dtype;\n            const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);\n            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n        };\n    }\n    return ({ inputs, backend }) => {\n        const { a, b } = inputs;\n        const cpuBackend = backend;\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            const $aComplex = cast({ inputs: { x: a }, backend: cpuBackend, attrs: { dtype: 'complex64' } });\n            const $aComplexVals = cpuBackend.data.get($aComplex.dataId);\n            const aReal = $aComplexVals.complexTensorInfos.real;\n            const aImag = $aComplexVals.complexTensorInfos.imag;\n            const aRealVals = cpuBackend.data.get(aReal.dataId).values;\n            const aImagVals = cpuBackend.data.get(aImag.dataId).values;\n            const $bComplex = cast({ inputs: { x: b }, backend: cpuBackend, attrs: { dtype: 'complex64' } });\n            const $bComplexVals = cpuBackend.data.get($bComplex.dataId);\n            const bReal = $bComplexVals.complexTensorInfos.real;\n            const bImag = $bComplexVals.complexTensorInfos.imag;\n            const bRealVals = cpuBackend.data.get(bReal.dataId).values;\n            const bImagVals = cpuBackend.data.get(bImag.dataId).values;\n            const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);\n            const resultReal = cpuBackend.makeTensorInfo(resultShape, 'float32', resultRealData);\n            const resultImag = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImagData);\n            const result = complex({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });\n            cpuBackend.disposeIntermediateTensorInfo($aComplex);\n            cpuBackend.disposeIntermediateTensorInfo($bComplex);\n            cpuBackend.disposeIntermediateTensorInfo(resultReal);\n            cpuBackend.disposeIntermediateTensorInfo(resultImag);\n            return result;\n        }\n        else {\n            const aVals = cpuBackend.data.get(a.dataId).values;\n            const bVals = cpuBackend.data.get(b.dataId).values;\n            const $dtype = dtype || a.dtype;\n            const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);\n            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n        }\n    };\n}\n/**\n * Template that creates the complex type implementation for binary ops.\n * Supports broadcast.\n */\nexport function createComplexBinaryKernelImpl(op) {\n    return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {\n        const resultShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const resultSize = util.sizeFromShape(resultShape);\n        const resultRank = resultShape.length;\n        const resultStrides = util.computeStrides(resultShape);\n        const resultRealVals = util.getTypedArrayFromDType('float32', resultSize);\n        const resultImagVals = util.getTypedArrayFromDType('float32', resultSize);\n        const aBroadcastDims = backend_util.getBroadcastDims(aShape, resultShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(bShape, resultShape);\n        const aVals = backend_util.mergeRealAndImagArrays(aRealVals, aImagVals);\n        const bVals = backend_util.mergeRealAndImagArrays(bRealVals, bImagVals);\n        const aRank = aShape.length;\n        const aStrides = util.computeStrides(aShape);\n        const bRank = bShape.length;\n        const bStrides = util.computeStrides(bShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < resultRealVals.length; i++) {\n                const aIdx = i % aVals.length;\n                const bIdx = i % bVals.length;\n                const result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);\n                resultRealVals[i] = result.real;\n                resultImagVals[i] = result.imag;\n            }\n        }\n        else {\n            for (let i = 0; i < resultRealVals.length; i++) {\n                const loc = util.indexToLoc(i, resultRank, resultStrides);\n                const aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n                const bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n                const opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);\n                resultRealVals[i] = opResult.real;\n                resultImagVals[i] = opResult.imag;\n            }\n        }\n        return [resultRealVals, resultImagVals, resultShape];\n    };\n}\n//# sourceMappingURL=binary_utils.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for unary op.\n */\nexport function createSimpleUnaryImpl(op) {\n    return (values, dtype, attrs) => {\n        const newValues = util.getTypedArrayFromDType(dtype, values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return newValues;\n    };\n}\n//# sourceMappingURL=unary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param name Kernel name.\n * @param op A `SimpleUnaryOperation` for the kernel.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFunc(name, op, dtype) {\n    return ({ inputs, attrs, backend }) => {\n        const { x } = inputs;\n        assertNotComplex(x, name);\n        if (x.dtype === 'string' || dtype === 'string') {\n            throw new Error('unaryKernelFunc does not support string input/output');\n        }\n        const cpuBackend = backend;\n        const values = cpuBackend.data.get(x.dataId).values;\n        const xSize = util.sizeFromShape(x.shape);\n        const $dtype = dtype || x.dtype;\n        const newValues = util.getArrayFromDType($dtype, xSize);\n        for (let i = 0; i < xSize; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n    };\n}\n/**\n * Template that creates a `KernelFunc` for unary ops from the given\n * `SimpleUnaryImpl`..\n * @param name Kernel name.\n * @param unaryImpl A `SimpleUnaryImpl` that implements the op.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {\n    return ({ inputs, attrs, backend }) => {\n        const { x } = inputs;\n        assertNotComplex(x, name);\n        if (x.dtype === 'string' || dtype === 'string') {\n            throw new Error('unaryKernelFunc does not support string input/output');\n        }\n        const cpuBackend = backend;\n        const values = cpuBackend.data.get(x.dataId).values;\n        const $dtype = dtype || x.dtype;\n        const newValues = unaryImpl(values, $dtype, attrs);\n        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n    };\n}\n//# sourceMappingURL=unary_utils.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { complex } from '../kernels/Complex';\n/**\n * Generates a tensorInfo with all zeros value.\n * @param backend cpu backend.\n * @param shape Shape for the zeros tensor.\n * @param dtype Optional. If set, the result has this dtype.\n */\nexport function zeros(backend, shape, dtype = 'float32') {\n    if (dtype === 'complex64') {\n        const real = zeros(backend, shape, 'float32');\n        const imag = zeros(backend, shape, 'float32');\n        return complex({ inputs: { real, imag }, backend });\n    }\n    const values = util.makeZerosTypedArray(util.sizeFromShape(shape), dtype);\n    return backend.makeTensorInfo(shape, dtype, values);\n}\n//# sourceMappingURL=zeros_impl.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AddNProgram {\n    constructor(outputShape, shapes) {\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(variable => {\n            snippets.push(`float v${variable} = get${variable}AtOutCoords();`);\n        });\n        // Calculate the sum of all elements.\n        const operation = this.variableNames\n            .map(variable => {\n            return `v${variable}`;\n        })\n            .join(' + ');\n        this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        float result = ${operation};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=addn_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AddNPackedProgram {\n    constructor(outputShape, shapes) {\n        this.outputShape = [];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(variable => {\n            snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);\n        });\n        // Calculate the sum of all elements.\n        const operation = this.variableNames\n            .map(variable => {\n            return `v${variable}`;\n        })\n            .join(' + ');\n        this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        vec4 result = ${operation};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=addn_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ArgMinMaxProgram {\n    constructor(reduceInfo, op, firstPass) {\n        this.variableNames = ['A'];\n        const { windowSize, batchSize, outSize } = reduceInfo;\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        this.outputShape = [batchSize, outSize];\n        const compOp = (op === 'max') ? '>' : '<';\n        const indexSnippet = firstPass ?\n            'inOffset + i;' :\n            'round(getBestIndicesA(batch, inOffset + i));';\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          int inIdx = ${indexSnippet};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${compOp} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=argminmax_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ArgMinMaxPackedProgram {\n    constructor(shape, windowSize, op, firstPass) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        util.assert(shape.length > 2, () => `Packed arg${op.charAt(0).toUpperCase() +\n            op.slice(1)} supports only inputs with rank above 2.`);\n        const inSize = shape[shape.length - 1];\n        const outSize = Math.ceil(inSize / windowSize);\n        this.outputShape = shape.slice(0, -1);\n        if (outSize > 1) {\n            this.outputShape.push(outSize);\n        }\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        const outShape = this.outputShape;\n        const rank = outShape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        let sourceLocSetup;\n        let sourceRank;\n        if (outSize === 1) {\n            sourceRank = rank + 1;\n            const sourceLocDType = getCoordsDataType(sourceRank);\n            sourceLocSetup = `\n        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 1]};\n        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 2]};\n        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 1]};\n        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 2]};`;\n        }\n        else {\n            sourceRank = rank;\n            sourceLocSetup = `\n        ${dtype} sourceLocR = coords;\n        ++${coords[rank - 1]};\n        ${dtype} sourceLocG = coords;\n        ++${coords[rank - 2]};\n        ${dtype} sourceLocA = coords;\n        --${coords[rank - 1]};\n        ${dtype} sourceLocB = coords;\n        --${coords[rank - 2]};`;\n        }\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n        const inChannel = '.' + channels[sourceRank - 1]; // e.g. \".b\" for rank 3.\n        const intChannels = channels.map(x => 'int ' + x);\n        const srcRCoords = getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n        const srcGCoords = getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n        const srcBCoords = getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n        const srcACoords = getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n        const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n        const fetchCandidateIdx = firstPass ? '' : `\n          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),\n                             getBestIndicesAChannel(${srcGCoords.join()}),\n                             getBestIndicesAChannel(${srcBCoords.join()}),\n                             getBestIndicesAChannel(${srcACoords.join()})));`;\n        const fetchValue = `vec4(\n            getAChannel(${srcRCoords.join()}),\n            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,\n            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;\n        const getBestIndicesAChannelSnippet = firstPass ? '' : `\n      float getBestIndicesAChannel(${intChannels.join()}) {\n        return getChannel(getBestIndicesA(${channels.join()}),\n                                          vec2(${channels.slice(-2).join()}));\n      }`;\n        this.userCode = `\n      float getAChannel(${intChannels.join()}) {\n        return getChannel(getA(${channels.join()}),\n                               vec2(${channels.slice(-2).join()}));\n      }\n      ${getBestIndicesAChannelSnippet}\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};\n        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};\n        ${sourceLocSetup}\n        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},\n          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${fetchValue};\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          inIdx = srcIdx;\n          ${fetchCandidateIdx}\n          vec4 candidate = ${fetchValue};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=argminmax_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AvgPool2DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const avgMultiplier = 1 / (filterHeight * filterWidth);\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth};\n            wC+= ${dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class AvgPool3DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=avg_pool_backprop_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import webgl flags.\nimport './flags_webgl';\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, scalar, tidy, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { DecodeMatrixProgram } from './decode_matrix_gpu';\nimport { DecodeMatrixPackedProgram } from './decode_matrix_packed_gpu';\nimport { EncodeFloatProgram } from './encode_float_gpu';\nimport { EncodeFloatPackedProgram } from './encode_float_packed_gpu';\nimport { EncodeMatrixProgram } from './encode_matrix_gpu';\nimport { EncodeMatrixPackedProgram } from './encode_matrix_packed_gpu';\nimport { GPGPUContext } from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport { simpleAbsImplCPU } from './kernel_utils/shared';\nimport { PackProgram } from './pack_gpu';\nimport { ReshapePackedProgram } from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport { TextureUsage } from './tex_util';\nimport { TextureManager } from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport { UnaryOpProgram } from './unaryop_gpu';\nimport { UnaryOpPackedProgram } from './unaryop_packed_gpu';\nimport { UnpackProgram } from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nconst whereImpl = kernel_impls.whereImpl;\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\nconst binaryCaches = {};\nexport function getBinaryCache(webGLVersion) {\n    if (webGLVersion in binaryCaches) {\n        return binaryCaches[webGLVersion];\n    }\n    binaryCaches[webGLVersion] = {};\n    return binaryCaches[webGLVersion];\n}\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD = 128;\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning() {\n    if (env().global.screen == null) {\n        return 1024; // 1 GB.\n    }\n    return (env().global.screen.height * env().global.screen.width *\n        window.devicePixelRatio) *\n        BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\nexport class MathBackendWebGL extends KernelBackend {\n    constructor(gpgpu) {\n        super();\n        // Maps data ids that have a pending read operation, to list of subscribers.\n        this.pendingRead = new WeakMap();\n        // List of data ids that are scheduled for disposal, but are waiting on a\n        // pending read operation.\n        this.pendingDisposal = new WeakSet();\n        // Used to count the number of 'shallow' sliced tensors that point to the\n        // same data id.\n        this.dataRefCount = new WeakMap();\n        this.numBytesInGPU = 0;\n        // Accumulated time spent (including blocking) in uploading data to webgl.\n        this.uploadWaitMs = 0;\n        // Accumulated time spent (including blocking in downloading data from webgl.\n        this.downloadWaitMs = 0;\n        this.warnedAboutMemory = false;\n        this.warnedAboutCPUBackend = false;\n        this.pendingDeletes = 0;\n        this.disposed = false;\n        if (!env().getBool('HAS_WEBGL')) {\n            throw new Error('WebGL is not supported on this device');\n        }\n        if (gpgpu == null) {\n            const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n            this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n            this.gpgpu = new GPGPUContext(gl);\n            this.canvas = gl.canvas;\n            this.gpgpuCreatedLocally = true;\n        }\n        else {\n            this.gpgpu = gpgpu;\n            this.binaryCache = {};\n            this.gpgpuCreatedLocally = false;\n            this.canvas = gpgpu.gl.canvas;\n        }\n        this.textureManager = new TextureManager(this.gpgpu);\n        this.numMBBeforeWarning = numMBBeforeWarning();\n        this.texData = new DataStorage(this, engine());\n    }\n    numDataIds() {\n        return this.texData.numDataIds() +\n            (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) -\n            this.pendingDeletes;\n    }\n    write(values, shape, dtype) {\n        if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n            env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64' && values != null) {\n            throw new Error(`Cannot write to a complex64 dtype. ` +\n                `Please use tf.complex(real, imag).`);\n        }\n        const dataId = {};\n        this.texData.set(dataId, {\n            shape,\n            dtype,\n            values,\n            usage: TextureUsage.UPLOAD,\n            refCount: 1,\n            complexParentRefCount: 0\n        });\n        return dataId;\n    }\n    /** Increase refCount of a `TextureData`. */\n    incRef(dataId) {\n        const texData = this.texData.get(dataId);\n        texData.refCount++;\n    }\n    /** Decrease refCount of a `TextureData`. */\n    decRef(dataId) {\n        if (this.texData.has(dataId)) {\n            const texData = this.texData.get(dataId);\n            texData.refCount--;\n        }\n    }\n    /**\n     * Decrease refCount of a `TextureData` if it is a component of complex\n     * tensor.\n     */\n    decComplexRef(dataId) {\n        if (this.texData.has(dataId)) {\n            const texData = this.texData.get(dataId);\n            if (texData.complexParentRefCount > 0) {\n                texData.refCount--;\n            }\n        }\n    }\n    move(dataId, values, shape, dtype) {\n        if (env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64') {\n            throw new Error(`Cannot write to a complex64 dtype. ` +\n                `Please use tf.complex(real, imag).`);\n        }\n        this.texData.set(dataId, {\n            shape,\n            dtype,\n            values,\n            usage: TextureUsage.UPLOAD,\n            refCount: 1,\n            complexParentRefCount: 0\n        });\n    }\n    disposeIntermediateTensorInfo(tensorInfo) {\n        const dataId = tensorInfo.dataId;\n        if (this.texData.has(dataId)) {\n            const textureData = this.texData.get(dataId);\n            textureData.refCount--;\n            if (textureData.refCount < 1) {\n                this.disposeData(dataId);\n            }\n        }\n    }\n    readSync(dataId) {\n        const texData = this.texData.get(dataId);\n        const { values, dtype, complexTensorInfos, slice, shape, isPacked } = texData;\n        // The presence of `slice` indicates this tensor is a shallow slice of a\n        // different tensor, and is using that original tensor's texture. Run\n        // `clone` in order to copy that texture and read from it.\n        if (slice != null) {\n            let program;\n            if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n            }\n            else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n            }\n            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);\n            const data = this.readSync(res.dataId);\n            this.disposeIntermediateTensorInfo(res);\n            return data;\n        }\n        if (values != null) {\n            return this.convertAndCacheOnCPU(dataId);\n        }\n        if (dtype === 'string') {\n            return values;\n        }\n        const shouldTimeProgram = this.activeTimers != null;\n        let start;\n        if (shouldTimeProgram) {\n            start = util.now();\n        }\n        let result;\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensorInfos.real.dataId);\n            const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        else {\n            result = this.getValuesFromTexture(dataId);\n        }\n        if (shouldTimeProgram) {\n            this.downloadWaitMs += util.now() - start;\n        }\n        return this.convertAndCacheOnCPU(dataId, result);\n    }\n    async read(dataId) {\n        if (this.pendingRead.has(dataId)) {\n            const subscribers = this.pendingRead.get(dataId);\n            return new Promise(resolve => subscribers.push(resolve));\n        }\n        const texData = this.texData.get(dataId);\n        const { values, shape, slice, dtype, complexTensorInfos, isPacked } = texData;\n        // The presence of `slice` indicates this tensor is a shallow slice of a\n        // different tensor, and is using that original tensor's texture. Run\n        // `clone` in order to copy that texture and read from it.\n        if (slice != null) {\n            let program;\n            if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n            }\n            else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n            }\n            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);\n            const data = this.read(res.dataId);\n            this.disposeIntermediateTensorInfo(res);\n            return data;\n        }\n        if (values != null) {\n            return this.convertAndCacheOnCPU(dataId);\n        }\n        if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n            env().getNumber('WEBGL_VERSION') === 2) {\n            throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n                `WEBGL_VERSION=2 not yet supported.`);\n        }\n        let buffer = null;\n        let tmpDownloadTarget;\n        if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n            // Possibly copy the texture into a buffer before inserting a fence.\n            tmpDownloadTarget = this.decode(dataId);\n            const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n            buffer = this.gpgpu.createBufferFromTexture(tmpData.texture, ...tex_util.getDenseTexShape(shape));\n        }\n        this.pendingRead.set(dataId, []);\n        if (dtype !== 'complex64') {\n            // Create a fence and wait for it to resolve.\n            await this.gpgpu.createAndWaitForFence();\n        }\n        // Download the values from the GPU.\n        let vals;\n        if (dtype === 'complex64') {\n            const ps = await Promise.all([\n                this.read(complexTensorInfos.real.dataId),\n                this.read(complexTensorInfos.imag.dataId)\n            ]);\n            const realValues = ps[0];\n            const imagValues = ps[1];\n            vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        else if (buffer == null) {\n            vals = this.getValuesFromTexture(dataId);\n        }\n        else {\n            const size = util.sizeFromShape(shape);\n            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n        }\n        if (tmpDownloadTarget != null) {\n            this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n        }\n        const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n        const subscribers = this.pendingRead.get(dataId);\n        this.pendingRead.delete(dataId);\n        // Notify all pending reads.\n        subscribers.forEach(resolve => resolve(dTypeVals));\n        if (this.pendingDisposal.has(dataId)) {\n            this.pendingDisposal.delete(dataId);\n            this.disposeData(dataId);\n            this.pendingDeletes--;\n        }\n        return dTypeVals;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return buffer(t.shape, t.dtype, decodedData);\n    }\n    checkNumericalProblems(values) {\n        if (values == null) {\n            return;\n        }\n        for (let i = 0; i < values.length; i++) {\n            const num = values[i];\n            if (!webgl_util.canBeRepresented(num)) {\n                if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n                    throw Error(`The value ${num} cannot be represented with your ` +\n                        `current settings. Consider enabling float32 rendering: ` +\n                        `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n                }\n                throw Error(`The value ${num} cannot be represented on this device.`);\n            }\n        }\n    }\n    getValuesFromTexture(dataId) {\n        const { shape, dtype, isPacked } = this.texData.get(dataId);\n        const size = util.sizeFromShape(shape);\n        if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n            const tmpTarget = this.decode(dataId);\n            const tmpData = this.texData.get(tmpTarget.dataId);\n            const vals = this.gpgpu\n                .downloadMatrixFromPackedTexture(tmpData.texture, ...tex_util.getDenseTexShape(shape))\n                .subarray(0, size);\n            this.disposeIntermediateTensorInfo(tmpTarget);\n            return vals;\n        }\n        const shouldUsePackedProgram = env().getBool('WEBGL_PACK') && isPacked === true;\n        const outputShape = shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n        const program = shouldUsePackedProgram ?\n            new EncodeFloatPackedProgram(outputShape) :\n            new EncodeFloatProgram(outputShape);\n        const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], 'float32');\n        const tmpData = this.texData.get(output.dataId);\n        const vals = this.gpgpu\n            .downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])\n            .subarray(0, size);\n        this.disposeIntermediateTensorInfo(output);\n        return vals;\n    }\n    async time(f) {\n        const oldActiveTimers = this.activeTimers;\n        const newActiveTimers = [];\n        let outerMostTime = false;\n        if (this.programTimersStack == null) {\n            this.programTimersStack = newActiveTimers;\n            outerMostTime = true;\n        }\n        else {\n            this.activeTimers.push(newActiveTimers);\n        }\n        this.activeTimers = newActiveTimers;\n        f();\n        // needing to split these up because util.flatten only accepts certain types\n        const flattenedActiveTimerQueries = util.flatten(this.activeTimers.map((d) => d.query))\n            .filter(d => d != null);\n        const flattenedActiveTimerNames = util.flatten(this.activeTimers.map((d) => d.name))\n            .filter(d => d != null);\n        this.activeTimers = oldActiveTimers;\n        if (outerMostTime) {\n            this.programTimersStack = null;\n        }\n        const res = {\n            uploadWaitMs: this.uploadWaitMs,\n            downloadWaitMs: this.downloadWaitMs,\n            kernelMs: null,\n            wallMs: null // will be filled by the engine\n        };\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n            res['kernelMs'] = util.sum(kernelMs);\n            res['getExtraProfileInfo'] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d }))\n                .map(d => `${d.name}: ${d.ms}`)\n                .join(', ');\n        }\n        else {\n            res['kernelMs'] = {\n                error: 'WebGL query timers are not supported in this environment.'\n            };\n        }\n        this.uploadWaitMs = 0;\n        this.downloadWaitMs = 0;\n        return res;\n    }\n    memory() {\n        return {\n            unreliable: false,\n            numBytesInGPU: this.numBytesInGPU,\n            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n            numBytesInGPUFree: this.textureManager.numBytesFree\n        };\n    }\n    startTimer() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            return this.gpgpu.beginQuery();\n        }\n        return { startMs: util.now(), endMs: null };\n    }\n    endTimer(query) {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            this.gpgpu.endQuery();\n            return query;\n        }\n        query.endMs = util.now();\n        return query;\n    }\n    async getQueryTime(query) {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            return this.gpgpu.waitForQueryAndGetTime(query);\n        }\n        const timerQuery = query;\n        return timerQuery.endMs - timerQuery.startMs;\n    }\n    disposeData(dataId) {\n        if (this.pendingDisposal.has(dataId)) {\n            return;\n        }\n        if (this.pendingRead.has(dataId)) {\n            this.pendingDisposal.add(dataId);\n            this.pendingDeletes++;\n            return;\n        }\n        // No-op if already disposed.\n        if (!this.texData.has(dataId)) {\n            return;\n        }\n        // Trying to dispose a textureData that has a 'kept' refCount, e.g. trying\n        // to dispose a tensor whose data bucket is shared with a complex tensor. In\n        // this case we are removing a reference to the textureData, but we\n        // shouldn't actually dispose the texture.\n        if (this.texData.get(dataId).complexParentRefCount > 0) {\n            this.texData.get(dataId).refCount--;\n            return;\n        }\n        this.releaseGPUData(dataId);\n        const { complexTensorInfos } = this.texData.get(dataId);\n        if (complexTensorInfos != null) {\n            this.texData.get(complexTensorInfos.real.dataId).complexParentRefCount--;\n            this.disposeIntermediateTensorInfo(complexTensorInfos.real);\n            this.texData.get(complexTensorInfos.imag.dataId).complexParentRefCount--;\n            this.disposeIntermediateTensorInfo(complexTensorInfos.imag);\n        }\n        this.texData.delete(dataId);\n    }\n    releaseGPUData(dataId) {\n        const { texture, dtype, texShape, usage, isPacked, slice } = this.texData.get(dataId);\n        const key = slice && slice.origDataId || dataId;\n        const refCount = this.dataRefCount.get(key);\n        if (refCount > 1) {\n            this.dataRefCount.set(key, refCount - 1);\n        }\n        else {\n            this.dataRefCount.delete(key);\n            if (texture != null) {\n                this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n                this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n            }\n        }\n        const texData = this.texData.get(dataId);\n        texData.texture = null;\n        texData.texShape = null;\n        texData.isPacked = false;\n        texData.slice = null;\n    }\n    getTexture(dataId) {\n        this.uploadToGPU(dataId);\n        return this.texData.get(dataId).texture;\n    }\n    /**\n     * Returns internal information for the specific data bucket. Used in unit\n     * tests.\n     */\n    getDataInfo(dataId) {\n        return this.texData.get(dataId);\n    }\n    getCPUBackend() {\n        if (!env().getBool('WEBGL_CPU_FORWARD')) {\n            return null;\n        }\n        if (this.cpuBackend == null) {\n            this.cpuBackend = engine().findBackend('cpu');\n        }\n        return this.cpuBackend;\n    }\n    /*\n    Tests whether all the inputs to an op are small and on the CPU. This heuristic\n    determines when it would be faster to execute a kernel on the CPU. WebGL\n    kernels opt into running this check and forwarding when appropriate.\n    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n    sustainable strategy for optimizing backend execution of ops.\n     */\n    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {\n        const cpuBackend = this.getCPUBackend();\n        if (!env().getBool('IS_TEST') && !this.warnedAboutCPUBackend &&\n            cpuBackend == null) {\n            console.warn('Your application contains ops that are small enough to be ' +\n                'executed on the CPU backend, however the CPU backend cannot ' +\n                'be found. Consider importing the CPU backend ' +\n                '(@tensorflow/tfjs-backend-cpu) for better performance.');\n            this.warnedAboutCPUBackend = true;\n        }\n        return cpuBackend != null &&\n            inputs.every(input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n    }\n    getGPGPUContext() {\n        return this.gpgpu;\n    }\n    where(condition) {\n        backend_util.warn('tf.where() in webgl locks the UI thread. ' +\n            'Call tf.whereAsync() instead');\n        const condVals = condition.dataSync();\n        return whereImpl(condition.shape, condVals);\n    }\n    packedUnaryOp(x, op, dtype) {\n        const program = new UnaryOpPackedProgram(x.shape, op);\n        return this.compileAndRun(program, [x], dtype);\n    }\n    // TODO(msoulanille) remove this once the backend has been modularized\n    // a copy is needed here to break a circular dependency.\n    // Also remove the op from unary_op.\n    abs(x) {\n        // TODO: handle cases when x is complex.\n        if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n            const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);\n            return this.makeOutput(x.shape, x.dtype, outValues);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.ABS, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n        return this.compileAndRun(program, [x]);\n    }\n    makeTensorInfo(shape, dtype, values) {\n        let dataId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            util.isString(values[0])) {\n            const encodedValues = values.map(d => util.encodeString(d));\n            dataId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            dataId = this.write(values, shape, dtype);\n        }\n        this.texData.get(dataId).usage = null;\n        return { dataId, shape, dtype };\n    }\n    makeOutput(shape, dtype, values) {\n        const { dataId } = this.makeTensorInfo(shape, dtype, values);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    unpackTensor(input) {\n        const program = new UnpackProgram(input.shape);\n        return this.runWebGLProgram(program, [input], input.dtype);\n    }\n    packTensor(input) {\n        const program = new PackProgram(input.shape);\n        const preventEagerUnpackingOutput = true;\n        return this.runWebGLProgram(program, [input], input.dtype, null /* customSetup */, preventEagerUnpackingOutput);\n    }\n    packedReshape(input, afterShape) {\n        const input3DShape = [\n            webgl_util.getBatchDim(input.shape),\n            ...webgl_util.getRowsCols(input.shape)\n        ];\n        const input3D = {\n            dtype: input.dtype,\n            shape: input3DShape,\n            dataId: input.dataId\n        };\n        const afterShapeAs3D = [\n            webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n        ];\n        const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n        const preventEagerUnpackingOfOutput = true;\n        const output = this.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };\n    }\n    decode(dataId) {\n        const texData = this.texData.get(dataId);\n        const { isPacked, shape, dtype } = texData;\n        const shapeAs3D = webgl_util.getShapeAs3D(shape);\n        let program;\n        if (isPacked) {\n            program = new DecodeMatrixPackedProgram(shapeAs3D);\n        }\n        else {\n            program = new DecodeMatrixProgram(shapeAs3D);\n        }\n        const preventEagerUnpackingOfOutput = true;\n        const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dtype, shape, dataId: out.dataId };\n    }\n    runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {\n        const output = this.makeTensorInfo(program.outputShape, outputDtype);\n        const outData = this.texData.get(output.dataId);\n        if (program.packedOutput) {\n            outData.isPacked = true;\n        }\n        if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n            const texelShape = tex_util.getDenseTexShape(program.outputShape);\n            // For a densely packed output, we explicitly set texShape\n            // so it doesn't get assigned later according to our typical packing\n            // scheme wherein a single texel can only contain values from adjacent\n            // rows/cols.\n            outData.texShape = texelShape.map(d => d * 2);\n        }\n        if (program.outTexUsage != null) {\n            outData.usage = program.outTexUsage;\n        }\n        if (util.sizeFromShape(output.shape) === 0) {\n            // Short-circuit the computation since the result is empty (has 0 in its\n            // shape).\n            outData.values =\n                util.getTypedArrayFromDType(output.dtype, 0);\n            return output;\n        }\n        const dataToDispose = [];\n        const inputsData = inputs.map(input => {\n            if (input.dtype === 'complex64') {\n                throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` +\n                    `dtypes, please separate the program into real and imaginary ` +\n                    `parts.`);\n            }\n            let texData = this.texData.get(input.dataId);\n            if (texData.texture == null) {\n                if (!program.packedInputs &&\n                    util.sizeFromShape(input.shape) <=\n                        env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n                    // Upload small tensors that live on the CPU as uniforms, not as\n                    // textures. Do this only when the environment supports 32bit floats\n                    // due to problems when comparing 16bit floats with 32bit floats.\n                    // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n                    // possible for packed shaders to sample from uniforms.\n                    return {\n                        shape: input.shape,\n                        texData: null,\n                        isUniform: true,\n                        uniformValues: texData.values\n                    };\n                }\n                // This ensures that if a packed program's inputs have not yet been\n                // uploaded to the GPU, they get uploaded as packed right off the bat.\n                if (program.packedInputs) {\n                    texData.isPacked = true;\n                    texData.shape = input.shape;\n                }\n            }\n            else if (!!texData.isPacked !== !!program.packedInputs) {\n                input = texData.isPacked ? this.unpackTensor(input) :\n                    this.packTensor(input);\n                dataToDispose.push(input);\n                texData = this.texData.get(input.dataId);\n            }\n            else if (texData.isPacked &&\n                !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n                // This is a special case where a texture exists for a tensor\n                // but the shapes are incompatible (due to packing constraints) because\n                // the tensor did not have a chance to go through the packed reshape\n                // shader. This only happens when we reshape the *same* tensor to form\n                // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n                // case will disappear once packed uploading is the default.\n                const savedInput = input;\n                const targetShape = input.shape;\n                input.shape = texData.shape;\n                input = this.packedReshape(input, targetShape);\n                dataToDispose.push(input);\n                texData = this.texData.get(input.dataId);\n                savedInput.shape = targetShape;\n            }\n            this.uploadToGPU(input.dataId);\n            return { shape: input.shape, texData, isUniform: false };\n        });\n        this.uploadToGPU(output.dataId);\n        const outputData = { shape: output.shape, texData: outData, isUniform: false };\n        const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n        const binary = this.getAndSaveBinary(key, () => {\n            return gpgpu_math.compileProgram(this.gpgpu, program, inputsData, outputData);\n        });\n        const shouldTimeProgram = this.activeTimers != null;\n        let query;\n        if (shouldTimeProgram) {\n            query = this.startTimer();\n        }\n        gpgpu_math.runProgram(this.gpgpu, binary, inputsData, outputData, customSetup);\n        dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));\n        if (shouldTimeProgram) {\n            query = this.endTimer(query);\n            this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });\n        }\n        if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n            preventEagerUnpackingOfOutput === false) {\n            const unpacked = this.unpackTensor(output);\n            this.disposeIntermediateTensorInfo(output);\n            return unpacked;\n        }\n        return output;\n    }\n    compileAndRun(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {\n        outputDtype = outputDtype || inputs[0].dtype;\n        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput);\n        return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);\n    }\n    getAndSaveBinary(key, getBinary) {\n        if (!(key in this.binaryCache)) {\n            this.binaryCache[key] = getBinary();\n        }\n        return this.binaryCache[key];\n    }\n    getTextureManager() {\n        return this.textureManager;\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        // Avoid disposing the compiled webgl programs during unit testing because\n        // it slows down test execution.\n        if (!env().getBool('IS_TEST')) {\n            const allKeys = Object.keys(this.binaryCache);\n            allKeys.forEach(key => {\n                this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n                delete this.binaryCache[key];\n            });\n        }\n        this.textureManager.dispose();\n        if (this.canvas != null &&\n            (typeof (HTMLCanvasElement) !== 'undefined' &&\n                this.canvas instanceof HTMLCanvasElement)) {\n            this.canvas.remove();\n        }\n        else {\n            this.canvas = null;\n        }\n        if (this.gpgpuCreatedLocally) {\n            this.gpgpu.program = null;\n            this.gpgpu.dispose();\n        }\n        this.disposed = true;\n    }\n    floatPrecision() {\n        if (this.floatPrecisionValue == null) {\n            this.floatPrecisionValue = tidy(() => {\n                if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n                    // Momentarily switching DEBUG flag to false so we don't throw an\n                    // error trying to upload a small value.\n                    const debugFlag = env().getBool('DEBUG');\n                    env().set('DEBUG', false);\n                    const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n                    env().set('DEBUG', debugFlag);\n                    if (underflowCheckValue > 0) {\n                        return 32;\n                    }\n                }\n                return 16;\n            });\n        }\n        return this.floatPrecisionValue;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n    uploadToGPU(dataId) {\n        const texData = this.texData.get(dataId);\n        const { shape, dtype, values, texture, usage, isPacked } = texData;\n        if (texture != null) {\n            // Array is already on GPU. No-op.\n            return;\n        }\n        const shouldTimeProgram = this.activeTimers != null;\n        let start;\n        if (shouldTimeProgram) {\n            start = util.now();\n        }\n        let texShape = texData.texShape;\n        if (texShape == null) {\n            texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n            texData.texShape = texShape;\n        }\n        if (values != null) {\n            const shapeAs3D = webgl_util.getShapeAs3D(shape);\n            let program;\n            let width = texShape[1], height = texShape[0];\n            const isByteArray = values instanceof Uint8Array;\n            if (isPacked) {\n                [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);\n                program = new EncodeMatrixPackedProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            else {\n                program =\n                    new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n            if (isByteArray) {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.PIXELS;\n            }\n            else {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.UPLOAD;\n            }\n            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);\n            // We want the output to remain packed regardless of the value of\n            // WEBGL_PACK.\n            const preventEagerUnpacking = true;\n            const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);\n            // Have the original texture assume the identity of the encoded output.\n            const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n            texData.texture = outputTexData.texture;\n            texData.texShape = outputTexData.texShape;\n            texData.isPacked = outputTexData.isPacked;\n            texData.usage = outputTexData.usage;\n            this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n            this.texData.delete(encodedOutputTarget.dataId);\n            // Once uploaded, don't store the values on cpu.\n            texData.values = null;\n            if (shouldTimeProgram) {\n                this.uploadWaitMs += util.now() - start;\n            }\n        }\n        else {\n            const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n            texData.texture = newTexture;\n        }\n    }\n    convertAndCacheOnCPU(dataId, float32Values) {\n        const texData = this.texData.get(dataId);\n        const { dtype } = texData;\n        this.releaseGPUData(dataId);\n        if (float32Values != null) {\n            texData.values = float32ToTypedArray(float32Values, dtype);\n        }\n        return texData.values;\n    }\n    acquireTexture(texShape, texType, dtype, isPacked) {\n        this.numBytesInGPU += this.computeBytes(texShape, dtype);\n        if (!this.warnedAboutMemory &&\n            this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n            const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n            this.warnedAboutMemory = true;\n            console.warn(`High memory usage in GPU: ${mb} MB, ` +\n                `most likely due to a memory leak`);\n        }\n        return this.textureManager.acquireTexture(texShape, texType, isPacked);\n    }\n    computeBytes(shape, dtype) {\n        return shape[0] * shape[1] * util.bytesPerElement(dtype);\n    }\n}\nfunction float32ToTypedArray(a, dtype) {\n    if (dtype === 'float32' || dtype === 'complex64') {\n        return a;\n    }\n    else if (dtype === 'int32' || dtype === 'bool') {\n        const result = (dtype === 'int32') ? new Int32Array(a.length) :\n            new Uint8Array(a.length);\n        for (let i = 0; i < result.length; ++i) {\n            result[i] = Math.round(a[i]);\n        }\n        return result;\n    }\n    else {\n        throw new Error(`Unknown dtype ${dtype}`);\n    }\n}\n//# sourceMappingURL=backend_webgl.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// base.ts is the webgl backend without auto kernel registration.\nimport { device_util, registerBackend } from '@tensorflow/tfjs-core';\nimport { MathBackendWebGL } from './backend_webgl';\nexport { version as version_webgl } from './version';\nif (device_util.isBrowser()) {\n    registerBackend('webgl', () => new MathBackendWebGL(), 2 /* priority */);\n}\n// Export webgl utilities\nexport * from './webgl';\n// Export forceHalfFlost under webgl namespace for the union bundle.\nimport { forceHalfFloat } from './webgl';\nexport const webgl = { forceHalfFloat };\n//# sourceMappingURL=base.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class BatchNormProgram {\n    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.outputShape = [];\n        this.variableNames = ['x', 'mean', 'variance'];\n        backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        let offsetSnippet = '0.0';\n        if (offsetShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        let scaleSnippet = '1.0';\n        if (scaleShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=batchnorm_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class BatchNormPackedProgram {\n    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.variableNames = ['x', 'mean', 'variance'];\n        backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        let offsetSnippet = 'vec4(0.0)';\n        if (offsetShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        let scaleSnippet = 'vec4(1.0)';\n        if (scaleShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = `\n      void main() {\n        vec4 offset = ${offsetSnippet};\n        vec4 scale = ${scaleSnippet};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=batchnorm_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nexport const COMPLEX_MULTIPLY = {\n    REAL: 'return areal * breal - aimag * bimag;',\n    IMAG: 'return areal * bimag + aimag * breal;'\n};\nexport class BinaryOpComplexProgram {\n    constructor(op, aShape, bShape) {\n        this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${op}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_complex_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport const CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport class BinaryOpProgram {\n    constructor(op, aShape, bShape) {\n        this.variableNames = ['A', 'B'];\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport const CHECK_NAN_SNIPPET = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\nexport class BinaryOpPackedProgram {\n    constructor(op, aShape, bShape, checkOutOfBounds = false) {\n        this.variableNames = ['A', 'B'];\n        this.supportsBroadcasting = true;\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const rank = this.outputShape.length;\n        let checkOutOfBoundsString = '';\n        if (checkOutOfBounds) {\n            if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n                checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n            }\n            else {\n                const dtype = getCoordsDataType(rank);\n                checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n                if (rank === 1) {\n                    checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n                }\n                else {\n                    const channels = getChannels('coords', rank);\n                    checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n                }\n            }\n        }\n        this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst contexts = {};\nconst WEBGL_ATTRIBUTES = {\n    alpha: false,\n    antialias: false,\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: false,\n    depth: false,\n    stencil: false,\n    failIfMajorPerformanceCaveat: true\n};\nexport function clearWebGLContext(webGLVersion) {\n    delete contexts[webGLVersion];\n}\nexport function setWebGLContext(webGLVersion, gl) {\n    contexts[webGLVersion] = gl;\n}\nexport function getWebGLContext(webGLVersion) {\n    if (!(webGLVersion in contexts)) {\n        const newCtx = getWebGLRenderingContext(webGLVersion);\n        if (newCtx !== null) {\n            contexts[webGLVersion] = newCtx;\n        }\n        else {\n            console.log('Could not get context for WebGL version', webGLVersion);\n            return null;\n        }\n    }\n    const gl = contexts[webGLVersion];\n    if (gl.isContextLost()) {\n        delete contexts[webGLVersion];\n        return getWebGLContext(webGLVersion);\n    }\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.STENCIL_TEST);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.DITHER);\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.disable(gl.SAMPLE_COVERAGE);\n    gl.enable(gl.SCISSOR_TEST);\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    return contexts[webGLVersion];\n}\nfunction createCanvas(webGLVersion) {\n    if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n        return new OffscreenCanvas(300, 150);\n    }\n    else if (typeof document !== 'undefined') {\n        return document.createElement('canvas');\n    }\n    else {\n        throw new Error('Cannot create a canvas in this context');\n    }\n}\nfunction getWebGLRenderingContext(webGLVersion) {\n    if (webGLVersion !== 1 && webGLVersion !== 2) {\n        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n    }\n    const canvas = createCanvas(webGLVersion);\n    canvas.addEventListener('webglcontextlost', (ev) => {\n        ev.preventDefault();\n        delete contexts[webGLVersion];\n    }, false);\n    if (webGLVersion === 1) {\n        return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES));\n    }\n    return canvas.getContext('webgl2', WEBGL_ATTRIBUTES);\n}\n//# sourceMappingURL=canvas_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ClipProgram {\n    constructor(aShape) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `;\n    }\n    getCustomSetupFunc(min, max) {\n        return (gpgpu, webGLProgram) => {\n            if (this.minLoc == null) {\n                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(this.minLoc, min);\n            gpgpu.gl.uniform1f(this.maxLoc, max);\n        };\n    }\n}\n//# sourceMappingURL=clip_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ClipPackedProgram {\n    constructor(aShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `;\n    }\n    getCustomSetupFunc(min, max) {\n        return (gpgpu, webGLProgram) => {\n            if (this.minLoc == null) {\n                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(this.minLoc, min);\n            gpgpu.gl.uniform1f(this.maxLoc, max);\n        };\n    }\n}\n//# sourceMappingURL=clip_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ComplexAbsProgram {\n    constructor(shape) {\n        this.variableNames = ['real', 'imag'];\n        this.outputShape = shape;\n        this.userCode = `\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `;\n    }\n}\n//# sourceMappingURL=complex_abs_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class ConcatProgram {\n    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n    constructor(shapes) {\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][1];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][1];\n        }\n        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            snippets.push(`else if (yC < ${offsets[i]}) ` +\n                `setOutput(getT${i}(yR, yC-${shift}));`);\n        }\n        const lastIndex = offsets.length;\n        const lastShift = offsets[offsets.length - 1];\n        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n    }\n}\n//# sourceMappingURL=concat_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n    constructor(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\n        const shape = this.outputShape;\n        const rank = shape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        const channel = channels[axis];\n        const lastChannels = channels.slice(-2);\n        const allChannels = channels.join();\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n        }\n        const lastIndex = offsets.length;\n        const shift = offsets[offsets.length - 1];\n        getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n        this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    const channelIdx = channels.indexOf(channel);\n    const res = channels.map((c, idx) => {\n        if (idx === channelIdx) {\n            return `${c} - ${shift}`;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n//# sourceMappingURL=concat_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              if (${isChannelsLast}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = filterDepth - 1 - convInfo.padInfo.front;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_backprop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class DepthwiseConv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_backprop_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivationWeights) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivationWeights) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\nexport class Conv3DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const xNumRows = convInfo.inHeight;\n        const xNumCols = convInfo.inWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${xNumRows}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${xNumCols}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport class DepthwiseConvPacked2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = convInfo.outShape;\n        const xNumRows = convInfo.inHeight;\n        const xNumCols = convInfo.inWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const texelsAcross = filterWidth;\n        let mainLoop = `int xR; int xC; int xCOffset;`;\n        for (let r = 0; r < filterHeight; r++) {\n            for (let c = 0; c < filterWidth; c++) {\n                mainLoop += `\n          vec4 xTexelR${r}C${c * 2} = vec4(0.);\n          vec4 wR${r}C${c} = vec4(0.);\n          vec4 xR${r}C${c} = vec4(0.);`;\n            }\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        for (let r = 0; r < filterHeight; r++) {\n            for (let texelC = 0; texelC < texelsAcross; texelC++) {\n                const c = texelC * 2;\n                mainLoop += `\n          xR = xRCorner + ${r * dilationHeight};\n          xC = xCCorner + ${c * dilationWidth};\n        `;\n                if (strideWidth === 1) {\n                    if (c < filterWidth) {\n                        // If padding is odd, the outer texels have to be composed.\n                        if (padLeft % 2 === 1) {\n                            // TODO: Ensure vec4 previous does not result in redundant sample,\n                            // and avoid setting xTexelRC's that exceed the boundary in the\n                            // first place rather than resetting them to vec4(0)).\n                            // To compute xCOffset:\n                            // - If padding is odd, we must add 1 to ensure we ask for an\n                            // even-numbered row.\n                            // - We subtract 2 to access the previous texel.\n                            mainLoop += `\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    xTexelR${r}C${c}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);\n                } else {\n                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);\n                }\n              `;\n                        }\n                        else {\n                            // Padding is even, so xRC corresponds to a single texel.\n                            mainLoop += `\n                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xR${r}C${c} = xTexelR${r}C${c};\n              `;\n                        }\n                        if (c + 1 < filterWidth) {\n                            // If dilation is even, the second entry should match the first\n                            // (either both are composed or both are single samples). But if\n                            // dilation is odd, then the second entry should be the opposite\n                            // of the first (if the first is composed, the second is a single\n                            // sample, and vice versa.)\n                            const nextTexelOffset = padLeft % 2 === 0 ?\n                                util.nearestLargerEven(dilationWidth) :\n                                dilationWidth;\n                            if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                                (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `;\n                                // If dilation > 1 then the xRC's will not be able to share any\n                                // values, so each xRC will require two unique calls to getX.\n                                if (dilationWidth > 1) {\n                                    mainLoop += `\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${xNumRows} &&\n                      xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${r}C${c} = vec4(0.);\n                    }\n                  `;\n                                }\n                                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);\n                `;\n                            }\n                            else {\n                                mainLoop += `\n                  xCOffset = xC + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};\n                `;\n                            }\n                        }\n                    }\n                }\n                else { // stride > 1\n                    if (c < filterWidth) {\n                        mainLoop += `\n              if(xR >= 0 && xR < ${xNumRows}) {\n            `;\n                        // Depending on whether padLeft is even or odd, we want either the\n                        // xy or zw channels from X texels for xR${r}C${c}. If padLeft is\n                        // even, xR${r}C${c + 1} is simply the zw channels of texels we've\n                        // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will\n                        // need to come from the xy channels of a new texel, hence the `vec4\n                        // final` initialized below.\n                        if (padLeft % 2 === 1) {\n                            mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n              `;\n                            if (c + 1 < filterWidth) {\n                                mainLoop += `\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);\n                `;\n                            }\n                        }\n                        else {\n                            mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);\n              `;\n                            if (c + 1 < filterWidth) {\n                                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n                `;\n                            }\n                        }\n                        mainLoop += `}`;\n                    }\n                }\n                if (c < filterWidth) {\n                    mainLoop += `\n            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);\n            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);\n          `;\n                    if (c + 1 < filterWidth) {\n                        mainLoop += `\n              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);\n              wR${r}C${c + 1} =\n                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;\n                    }\n                }\n            }\n        }\n        for (let r = 0; r < filterHeight; r++) {\n            for (let c = 0; c < filterWidth; c++) {\n                mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;\n            }\n        }\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${mainLoop}\n\n        vec4 result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_packed_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class CropAndResizeProgram {\n    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        const [batch, imageHeight, imageWidth, depth] = imageShape;\n        const [numBoxes,] = boxShape;\n        const [cropHeight, cropWidth] = cropSize;\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        const methodId = method === 'bilinear' ? 1 : 0;\n        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n        const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n            [\n                `${(imageHeight - 1) / (cropHeight - 1)}`,\n                '(y2-y1) * height_ratio',\n                `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (y1+y2) * ${inputHeightFloat}`,\n            ];\n        const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n            [\n                `${(imageWidth - 1) / (cropWidth - 1)}`,\n                '(x2-x1) * width_ratio',\n                `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (x1+x2) * ${inputWidthFloat}`,\n            ];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n        this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=crop_and_resize_gpu.js.map","import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n    constructor(shape, exclusive, reverse) {\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        const rank = shape.length;\n        const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n        const length = shape[shape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cumsum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n    getCustomSetupFunc(index) {\n        return (gpgpu, webGLProgram) => {\n            if (this.index == null) {\n                this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n            }\n            gpgpu.gl.uniform1f(this.index, index);\n        };\n    }\n}\nfunction getCoords(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=cumsum_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nimport { getDenseTexShape, PackingScheme } from './tex_util';\nexport class DecodeMatrixProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        const texShape = getDenseTexShape(outputShape);\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=decode_matrix_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nimport { getDenseTexShape, PackingScheme } from './tex_util';\nexport class DecodeMatrixPackedProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        const texShape = getDenseTexShape(outputShape);\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=decode_matrix_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthToSpaceProgram {\n    constructor(outputShape, blockSize, dataFormat) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.blockSize = blockSize;\n        this.dataFormat = dataFormat;\n        this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${blockSize};\n      int offset_h = imod(h, ${blockSize});\n      int in_w = w / ${blockSize};\n      int offset_w = imod(w, ${blockSize});\n      int offset_d = (offset_h * ${blockSize} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `;\n    }\n    getHeightCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[1]`;\n        }\n        else {\n            return `coords[2]`;\n        }\n    }\n    getWidthCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[2]`;\n        }\n        else {\n            return `coords[3]`;\n        }\n    }\n    getDepthCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[3]`;\n        }\n        else {\n            return `coords[1]`;\n        }\n    }\n    getOutputDepthSize() {\n        if (this.dataFormat === 'NHWC') {\n            return this.outputShape[3];\n        }\n        else {\n            return this.outputShape[1];\n        }\n    }\n    getInputSamplingString() {\n        if (this.dataFormat === 'NHWC') {\n            return `getX(b, in_h, in_w, in_d)`;\n        }\n        else {\n            return `getX(b, in_d, in_h, in_w)`;\n        }\n    }\n}\n//# sourceMappingURL=depth_to_space_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DiagProgram {\n    constructor(size) {\n        this.variableNames = ['X'];\n        this.outputShape = [size, size];\n        this.userCode = `\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=diag_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Dilation2DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;\n        const { top: padTop, left: padLeft } = padInfo;\n        this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${filterHeight}; h++) {\n          int hIn = hBeg + h * ${dilationHeight};\n\n          if (hIn >= 0 && hIn < ${inHeight}) {\n            for (int w = 0; w < ${filterWidth}; w++) {\n              int wIn = wBeg + w * ${dilationWidth};\n\n              if (wIn >= 0 && wIn < ${inWidth}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=dilation_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport { ENCODE_FLOAT_SNIPPET } from './shader_compiler_util';\nimport { TextureUsage } from './tex_util';\nexport class EncodeFloatProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_float_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport { ENCODE_FLOAT_SNIPPET } from './shader_compiler_util';\nimport { TextureUsage } from './tex_util';\nexport class EncodeFloatPackedProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_float_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nexport class EncodeMatrixProgram {\n    constructor(outputShape, texShape, inputIsUnsignedByte = false) {\n        this.variableNames = ['A'];\n        const glsl = getGlslDifferences();\n        const [height, width] = texShape;\n        this.outputShape = outputShape;\n        let output = `result`;\n        if (inputIsUnsignedByte) {\n            output = `floor(result * 255. + 0.5)`;\n        }\n        this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${width};\n        int c = imod(flatIndex, ${width});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n        vec4 values = ${glsl.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${glsl.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_matrix_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\nexport class EncodeMatrixPackedProgram {\n    constructor(outputShape, texShape, inputIsUnsignedByte = false) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        const glsl = getGlslDifferences();\n        const [height, width] = texShape;\n        this.outputShape = outputShape;\n        let mainLoop = '';\n        let output = 'result';\n        if (inputIsUnsignedByte) {\n            output = 'floor(result * 255. + 0.5)';\n        }\n        for (let row = 0; row <= 1; row++) {\n            for (let col = 0; col <= 1; col++) {\n                const channel = row * 2 + col;\n                mainLoop += `\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${outputShape[2]}) {\n            localCoords[2] += ${col};\n            if(localCoords[1] + ${row} < ${outputShape[1]}) {\n              localCoords[1] += ${row};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${width};\n              c = imod(flatIndex, ${width});\n              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n              values = ${glsl.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${channel}] = values[0];\n              } else if(offset == 1) {\n                result[${channel}] = values[1];\n              } else if(offset == 2) {\n                result[${channel}] = values[2];\n              } else {\n                result[${channel}] = values[3];\n              }\n            }\n          }\n        `;\n            }\n        }\n        this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${mainLoop}\n\n        ${glsl.output} = ${output};\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_matrix_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class FFTProgram {\n    constructor(component, inputShape, inverse) {\n        this.variableNames = ['real', 'imag'];\n        const innerDim = inputShape[1];\n        this.outputShape = inputShape;\n        const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n        const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n        let opString;\n        if (component === 'real') {\n            opString = 'return real * expR - imag * expI;';\n        }\n        else if (component === 'imag') {\n            opString = 'return real * expI + imag * expR;';\n        }\n        else {\n            throw new Error(`FFT component must be either \"real\" or \"imag\", got ${component}.`);\n        }\n        this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${opString}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=fft_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class FillProgram {\n    constructor(shape, value) {\n        this.outputShape = [];\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        this.userCode = `\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `;\n    }\n    getCustomSetupFunc(value) {\n        return (gpgpu, webGLProgram) => {\n            if (this.valueLoc == null) {\n                this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n            }\n            gpgpu.gl.uniform1f(this.valueLoc, value);\n        };\n    }\n}\n//# sourceMappingURL=fill_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { device_util, env } from '@tensorflow/tfjs-core';\nimport { getMaxTexturesInShader, getWebGLDisjointQueryTimerVersion, getWebGLMaxTextureSize, isCapableOfRenderingToFloatTexture, isDownloadFloatTextureEnabled, isWebGLFenceEnabled, isWebGLVersionEnabled } from './webgl_util';\nconst ENV = env();\n/**\n * This file contains WebGL-specific flag registrations.\n */\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', () => {\n    if (isWebGLVersionEnabled(2)) {\n        return 2;\n    }\n    else if (isWebGLVersionEnabled(1)) {\n        return 1;\n    }\n    return 0;\n});\n/** Whether to check for numerical representation problems. */\nENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', () => false);\nENV.registerFlag('WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', () => true);\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack the depthwise conv op. */\n// TODO: https://github.com/tensorflow/tfjs/issues/1679\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => false);\n/** Whether we will pack binary ops. */\nENV.registerFlag('WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack unary ops. */\nENV.registerFlag('WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack array ops. */\nENV.registerFlag('WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack image ops. */\nENV.registerFlag('WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURE_SIZE', () => getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')));\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURES_IN_SHADER', () => getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')));\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {\n    const webGLVersion = ENV.getNumber('WEBGL_VERSION');\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n    !device_util.isMobile());\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_CAPABLE', () => isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')));\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {\n    return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n        false :\n        ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag('WEBGL_DOWNLOAD_FLOAT_ENABLED', () => isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')));\n/** Whether the fence API is available. */\nENV.registerFlag('WEBGL_FENCE_API_ENABLED', () => isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')));\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {\n    // Use uniform uploads only when 32bit floats are supported. In\n    // 16bit\n    // environments there are problems with comparing a 16bit texture value\n    // with a 32bit uniform value.\n    const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n    return useUniforms ? 4 : 0;\n});\n/**\n * If the total number of bytes allocated on the GPU is greater than this\n * number, we will aggressively delete textures upon disposal with\n * gl.deleteMatrixTexture, rather than making them available for reuse.\n *\n * Default value -1 indicates that we will never aggressively delete textures.\n */\nENV.registerFlag('WEBGL_DELETE_TEXTURE_THRESHOLD', () => {\n    return -1;\n}, threshold => {\n    if (threshold < 0 && threshold !== -1) {\n        throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` +\n            `delete) or at least 0, but got ${threshold}.`);\n    }\n});\n//# sourceMappingURL=flags_webgl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class FlipLeftRightProgram {\n    constructor(imageShape) {\n        this.variableNames = ['Image'];\n        this.outputShape = [];\n        const imageWidth = imageShape[2];\n        this.outputShape = imageShape;\n        this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${imageWidth} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${imageWidth}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n    }\n}\n//# sourceMappingURL=flip_left_right_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class GatherProgram {\n    constructor(aShape, outputShape) {\n        this.variableNames = ['A', 'indices'];\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const sourceCoords = getSourceCoords(aShape, 2);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n    }\n}\n// The input and output are always flattened into rank 4 tensors.\nfunction getSourceCoords(aShape, axis) {\n    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n    const sourceCoords = [];\n    for (let i = 0; i < aShape.length; i++) {\n        if (i === 2) {\n            sourceCoords.push('int(getIndices(resRC.x, resRC.z))');\n        }\n        else {\n            sourceCoords.push(`${currentCoords[i]}`);\n        }\n    }\n    return sourceCoords.join();\n}\n//# sourceMappingURL=gather_gpu.js.map","import { getCoordsDataType } from './shader_compiler';\nexport class GatherNDProgram {\n    constructor(sliceDim, strides, shape) {\n        this.sliceDim = sliceDim;\n        this.strides = strides;\n        this.variableNames = ['x', 'indices'];\n        this.outputShape = shape;\n        const stridesType = getCoordsDataType(strides.length);\n        const dtype = getCoordsDataType(shape.length);\n        const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = `\n        ${stridesType} strides = ${stridesType}(${this.strides});\n         void main() {\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${strideString};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `;\n    }\n}\n//# sourceMappingURL=gather_nd_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nexport function getGlslDifferences() {\n    let version;\n    let attribute;\n    let varyingVs;\n    let varyingFs;\n    let texture2D;\n    let output;\n    let defineOutput;\n    let defineSpecialNaN;\n    let defineSpecialInf;\n    let defineRound;\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        version = '#version 300 es';\n        attribute = 'in';\n        varyingVs = 'out';\n        varyingFs = 'in';\n        texture2D = 'texture';\n        output = 'outputColor';\n        defineOutput = 'out vec4 outputColor;';\n        // Use custom isnan definition to work across differences between\n        // implementations on various platforms. While this should happen in ANGLE\n        // we still see differences between android and windows (on chrome) when\n        // using isnan directly.\n        defineSpecialNaN = `\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;\n        // In webgl 2 we do not need to specify a custom isinf so there is no\n        // need for a special INFINITY constant.\n        defineSpecialInf = ``;\n        defineRound = `\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n    }\n    else {\n        version = '';\n        attribute = 'attribute';\n        varyingVs = 'varying';\n        varyingFs = 'varying';\n        texture2D = 'texture2D';\n        output = 'gl_FragColor';\n        defineOutput = '';\n        // WebGL1 has no built in isnan so we define one here.\n        defineSpecialNaN = `\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;\n        defineSpecialInf = `\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;\n        defineRound = `\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n    }\n    return {\n        version,\n        attribute,\n        varyingVs,\n        varyingFs,\n        texture2D,\n        output,\n        defineOutput,\n        defineSpecialNaN,\n        defineSpecialInf,\n        defineRound\n    };\n}\n//# sourceMappingURL=glsl_version.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n    constructor(gl) {\n        this.outputTexture = null;\n        this.program = null;\n        this.disposed = false;\n        this.vertexAttrsAreBound = false;\n        this.itemsToPoll = [];\n        const glVersion = env().getNumber('WEBGL_VERSION');\n        if (gl != null) {\n            this.gl = gl;\n            setWebGLContext(glVersion, gl);\n        }\n        else {\n            this.gl = getWebGLContext(glVersion);\n        }\n        // WebGL 2.0 enables texture floats without an extension.\n        let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (env().getNumber('WEBGL_VERSION') === 1) {\n            const TEXTURE_FLOAT = 'OES_texture_float';\n            const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n            this.textureFloatExtension =\n                webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n            if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n                this.textureHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support half float textures, yet the ' +\n                    'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support color renderable half floats, yet ' +\n                    'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n        }\n        else {\n            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n                this.colorBufferFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            }\n            else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            }\n            else {\n                throw new Error('GL context does not support color renderable floats');\n            }\n        }\n        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n        this.framebuffer = webgl_util.createFramebuffer(this.gl);\n        this.textureConfig =\n            tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n    }\n    get debug() {\n        return env().getBool('DEBUG');\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        if (this.program != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n                ' This is probably a resource leak, delete the program with ' +\n                'GPGPUContext.deleteProgram before disposing.');\n        }\n        if (this.outputTexture != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +\n                'texture.  This is probably a resource leak, delete the output ' +\n                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n                'disposing.');\n        }\n        const gl = this.gl;\n        webgl_util.callAndCheck(gl, () => gl.finish());\n        webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n        this.disposed = true;\n    }\n    createFloat32MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createFloat16MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createUnsignedBytesMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    uploadPixelDataToTexture(texture, pixels) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    }\n    uploadDenseMatrixToTexture(texture, width, height, data) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    }\n    createFloat16PackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createPackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    deleteMatrixTexture(texture) {\n        this.throwIfDisposed();\n        if (this.outputTexture === texture) {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n            this.outputTexture = null;\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n    }\n    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n    }\n    downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n        return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    }\n    downloadFloat32MatrixFromBuffer(buffer, size) {\n        return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    }\n    createBufferFromTexture(texture, rows, columns) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    createAndWaitForFence() {\n        const fenceContext = this.createFence(this.gl);\n        return this.pollFence(fenceContext);\n    }\n    createFence(gl) {\n        let query;\n        let isFencePassed;\n        if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n            const gl2 = gl;\n            const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            gl.flush();\n            isFencePassed = () => {\n                const status = gl2.clientWaitSync(sync, 0, 0);\n                return status === gl2.ALREADY_SIGNALED ||\n                    status === gl2.CONDITION_SATISFIED;\n            };\n            query = sync;\n        }\n        else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n            query = this.beginQuery();\n            this.endQuery();\n            isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n        }\n        else {\n            // If we have no way to fence, return true immediately. This will fire in\n            // WebGL 1.0 when there is no disjoint query timer. In this case, because\n            // the fence passes immediately, we'll immediately ask for a download of\n            // the texture, which will cause the UI thread to hang.\n            isFencePassed = () => true;\n        }\n        return { query, isFencePassed };\n    }\n    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n    }\n    createProgram(fragmentShaderSource) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n        const vertexShader = gpgpu_util.createVertexShader(gl);\n        const program = webgl_util.createProgram(gl);\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, vertexShader));\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n        webgl_util.linkProgram(gl, program);\n        if (this.debug) {\n            webgl_util.validateProgram(gl, program);\n        }\n        if (!this.vertexAttrsAreBound) {\n            this.setProgram(program);\n            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n        }\n        return program;\n    }\n    deleteProgram(program) {\n        this.throwIfDisposed();\n        if (program === this.program) {\n            this.program = null;\n        }\n        if (program != null) {\n            webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n        }\n    }\n    setProgram(program) {\n        this.throwIfDisposed();\n        this.program = program;\n        if ((this.program != null) && this.debug) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n    }\n    getUniformLocation(program, uniformName, shouldThrow = true) {\n        this.throwIfDisposed();\n        if (shouldThrow) {\n            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n        }\n        else {\n            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n        }\n    }\n    getAttributeLocation(program, attribute) {\n        this.throwIfDisposed();\n        return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n    }\n    getUniformLocationNoThrow(program, uniformName) {\n        this.throwIfDisposed();\n        return this.gl.getUniformLocation(program, uniformName);\n    }\n    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    }\n    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    }\n    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n        this.throwIfDisposed();\n        const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    }\n    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    }\n    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    }\n    debugValidate() {\n        if (this.program != null) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.validateFramebuffer(this.gl);\n    }\n    executeProgram() {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        const gl = this.gl;\n        if (this.debug) {\n            this.debugValidate();\n        }\n        webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n    }\n    blockUntilAllProgramsCompleted() {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n    }\n    getQueryTimerExtension() {\n        if (this.disjointQueryTimerExtension == null) {\n            this.disjointQueryTimerExtension =\n                webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                    'EXT_disjoint_timer_query_webgl2' :\n                    'EXT_disjoint_timer_query');\n        }\n        return this.disjointQueryTimerExtension;\n    }\n    getQueryTimerExtensionWebGL2() {\n        return this.getQueryTimerExtension();\n    }\n    getQueryTimerExtensionWebGL1() {\n        return this.getQueryTimerExtension();\n    }\n    beginQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const query = gl2.createQuery();\n            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n            return query;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        const query = ext.createQueryEXT();\n        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n        return query;\n    }\n    endQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            gl2.endQuery(ext.TIME_ELAPSED_EXT);\n            return;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    }\n    async waitForQueryAndGetTime(query) {\n        await util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed\n            // in rapid succession, so without this check we\n            // may poll for the query timer indefinitely\n            this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n        return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    }\n    getQueryTime(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return null;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n    }\n    isQueryAvailable(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return true;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n    }\n    pollFence(fenceContext) {\n        return new Promise(resolve => {\n            this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n        });\n    }\n    pollItems() {\n        // Find the last query that has finished.\n        const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n        for (let i = 0; i <= index; ++i) {\n            const { resolveFn } = this.itemsToPoll[i];\n            resolveFn();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    }\n    addItemToPoll(isDoneFn, resolveFn) {\n        this.itemsToPoll.push({ isDoneFn, resolveFn });\n        if (this.itemsToPoll.length > 1) {\n            // We already have a running loop that polls.\n            return;\n        }\n        // Start a new loop that polls.\n        util.repeatedTry(() => {\n            this.pollItems();\n            // End the loop if no more items to poll.\n            return this.itemsToPoll.length === 0;\n        });\n    }\n    bindTextureToFrameBuffer(texture) {\n        this.throwIfDisposed();\n        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(this.gl);\n        }\n    }\n    unbindTextureToFrameBuffer() {\n        if (this.outputTexture != null) {\n            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n            if (this.debug) {\n                webgl_util.validateFramebuffer(this.gl);\n            }\n        }\n        else {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        }\n    }\n    downloadMatrixDriver(texture, downloadAndDecode) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = downloadAndDecode();\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(gl);\n        }\n        this.outputTexture = outputMatrixTextureMaybePacked;\n        webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n        webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n    }\n    setOutputMatrixWriteRegionDriver(x, y, width, height) {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n    }\n    throwIfDisposed() {\n        if (this.disposed) {\n            throw new Error('Attempted to use disposed GPGPUContext.');\n        }\n    }\n    throwIfNoProgram() {\n        if (this.program == null) {\n            throw new Error('No GPU program is currently set.');\n        }\n    }\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr) {\n    let i = 0;\n    for (; i < arr.length; ++i) {\n        const isDone = arr[i]();\n        if (!isDone) {\n            break;\n        }\n    }\n    return i - 1;\n}\n//# sourceMappingURL=gpgpu_context.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport * as shader_compiler from './shader_compiler';\nexport function compileProgram(gpgpu, program, inputs, output) {\n    const userCode = program.userCode;\n    const inputInfos = inputs.map((input, i) => {\n        const shapeInfo = {\n            logicalShape: input.shape,\n            texShape: input.isUniform ? null : input.texData.texShape,\n            isUniform: input.isUniform,\n            isPacked: input.isUniform ? false : input.texData.isPacked,\n            flatOffset: null\n        };\n        if (input.texData != null && input.texData.slice != null &&\n            input.texData.slice.flatOffset > 0) {\n            shapeInfo.flatOffset = input.texData.slice.flatOffset;\n        }\n        return { name: program.variableNames[i], shapeInfo };\n    });\n    const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n    const outShapeInfo = {\n        logicalShape: output.shape,\n        texShape: output.texData.texShape,\n        isUniform: false,\n        isPacked: output.texData.isPacked,\n        flatOffset: null\n    };\n    const source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);\n    const webGLProgram = gpgpu.createProgram(source);\n    // Add special uniforms (NAN, INFINITY)\n    let infLoc = null;\n    const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n    }\n    // Add user-defined uniforms\n    const uniformLocations = {};\n    for (let i = 0; i < program.variableNames.length; i++) {\n        const varName = program.variableNames[i];\n        const shouldThrow = false;\n        uniformLocations[varName] =\n            gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n        uniformLocations[`offset${varName}`] =\n            gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n    }\n    return {\n        program,\n        source,\n        webGLProgram,\n        uniformLocations,\n        inShapeInfos,\n        outShapeInfo,\n        infLoc,\n        nanLoc,\n    };\n}\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n    if (shapeInfos.length !== inputs.length) {\n        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` +\n            `was executed with ${inputs.length} inputs`);\n    }\n    shapeInfos.forEach((s, i) => {\n        const shapeA = s.logicalShape;\n        const input = inputs[i];\n        const shapeB = input.shape;\n        if (!util.arraysEqual(shapeA, shapeB)) {\n            throw Error(`Binary was compiled with different shapes than ` +\n                `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n        }\n        // The input is uploaded as uniform.\n        if (s.isUniform && input.isUniform) {\n            return;\n        }\n        const texShapeA = s.texShape;\n        const texShapeB = input.isUniform ? null : input.texData.texShape;\n        if (!util.arraysEqual(texShapeA, texShapeB)) {\n            throw Error(`Binary was compiled with different texture shapes than the` +\n                ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n        }\n    });\n}\nexport function runProgram(gpgpu, binary, inputs, output, customSetup) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n    const outTex = output.texData.texture;\n    const outTexShape = output.texData.texShape;\n    if (output.texData.isPacked) {\n        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    else {\n        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    gpgpu.setProgram(binary.webGLProgram);\n    // Set special uniforms (NAN, INFINITY)\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        if (binary.infLoc !== null) {\n            gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n        }\n    }\n    if (binary.nanLoc !== null) {\n        gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n    }\n    // Set user-defined inputs\n    inputs.forEach((input, i) => {\n        const varName = binary.program.variableNames[i];\n        const varLoc = binary.uniformLocations[varName];\n        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n        if (varLoc == null) {\n            // The compiler inferred that this variable is not used in this shader.\n            return;\n        }\n        if (input.isUniform) {\n            // Upload the values of the tensor as uniform.\n            if (util.sizeFromShape(input.shape) < 2) {\n                gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n            }\n            else {\n                let vals = input.uniformValues;\n                if (!(vals instanceof Float32Array)) {\n                    vals = new Float32Array(vals);\n                }\n                gpgpu.gl.uniform1fv(varLoc, vals);\n            }\n            return;\n        }\n        // If the input was sliced, upload the flat offset index.\n        if (input.texData.slice != null && varOffsetLoc != null) {\n            gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n        }\n        gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n    });\n    if (customSetup != null) {\n        customSetup(gpgpu, binary.webGLProgram);\n    }\n    gpgpu.executeProgram();\n}\nexport function makeShaderKey(program, inputs, output) {\n    let keyInputs = '';\n    inputs.concat(output).forEach(x => {\n        const hasOffset = x.texData != null && x.texData.slice != null &&\n            x.texData.slice.flatOffset > 0;\n        const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n    });\n    const keyUserCode = program.userCode;\n    let key = program.constructor.name;\n    // Fast string concat. See https://jsperf.com/string-concatenation/14.\n    key += '_' + keyInputs + '_' + keyUserCode;\n    return key;\n}\n//# sourceMappingURL=gpgpu_math.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl) {\n    const glsl = getGlslDifferences();\n    const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n    return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\nexport function createVertexBuffer(gl) {\n    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n    return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\nexport function createIndexBuffer(gl) {\n    // OpenGL (and WebGL) have \"CCW == front\" winding\n    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\nfunction createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {\n    webgl_util.validateTextureSize(width, height);\n    const texture = webgl_util.createTexture(gl);\n    const tex2d = gl.TEXTURE_2D;\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n    return texture;\n}\nexport function getInternalFormatForFloat32MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatFloat;\n}\nexport function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatHalfFloat;\n}\nexport function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {\n    return textureConfig.downloadTextureFormat;\n}\nexport function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function getInternalFormatForPackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedFloat;\n}\nexport function createPackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedHalfFloat;\n}\nexport function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n    const posOffset = 0; // x is the first buffer element\n    const uvOffset = 3 * 4; // uv comes after [x y z]\n    const stride = (3 * 4) + (2 * 4); // xyz + uv, each entry is 4-byte float.\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n    const success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n    return success &&\n        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    let dataForUpload, texelDataType, internalFormat;\n    if (data instanceof Uint8Array) {\n        dataForUpload = new Uint8Array(width * height * 4);\n        texelDataType = gl.UNSIGNED_BYTE;\n        internalFormat = gl.RGBA;\n    }\n    else {\n        dataForUpload = new Float32Array(width * height * 4);\n        texelDataType = gl.FLOAT;\n        internalFormat = textureConfig.internalFormatPackedFloat;\n    }\n    dataForUpload.set(data);\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function uploadPixelDataToTexture(gl, texture, pixels) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    if (pixels.data instanceof Uint8Array) {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));\n    }\n    else {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));\n    }\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {\n    // Create and bind the buffer.\n    const buffer = gl2.createBuffer();\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n    // Initialize the buffer to the size of the texture in bytes.\n    const bytesPerFloat = 4;\n    const valuesPerTexel = 4;\n    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n    webgl_util.callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n    // Enqueue a command on the GPU command queue to copy of texture into the\n    // buffer.\n    webgl_util.callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n    return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(size);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {\n    const [w, h] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    const numChannels = 4;\n    const downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));\n    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n    // decoding of the 4 bytes that back each 32 bit float.\n    return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {\n    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n    return packedRGBA;\n}\n//# sourceMappingURL=gpgpu_util.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nexport class Im2ColPackedProgram {\n    constructor(outputShape, inputShape, convInfo) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        const { filterWidth, inChannels, strideWidth, strideHeight, padInfo, outWidth, dilationWidth, dilationHeight, dataFormat } = convInfo;\n        const { left, top } = padInfo;\n        const itemsPerBlockRow = inChannels * filterWidth;\n        const glsl = getGlslDifferences();\n        const isChannelsLast = dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 0 : 1;\n        const colDim = isChannelsLast ? 1 : 2;\n        let unrolled = ``;\n        for (let row = 0; row <= 1; row++) {\n            for (let col = 0; col <= 1; col++) {\n                unrolled += `\n          blockIndex = rc.y + ${col};\n          pos = rc.x + ${row};\n\n          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {\n            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${top};\n            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});\n\n            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${strideWidth}. - ${left}.);\n              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${itemsPerBlockRow}.) / ${inChannels}.));\n\n              if(d1 < ${inputShape[colDim]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${inChannels}.));\n\n                if (${isChannelsLast}) {\n                  innerDims = vec2(d1, ch);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;\n            }\n        }\n        this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${unrolled}\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=im2col_packed_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// All exports from this package should be in base.\nexport * from './base';\nimport './register_all_kernels';\n//# sourceMappingURL=index.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, util } from '@tensorflow/tfjs-core';\nimport { ArgMinMaxProgram } from '../argminmax_gpu';\nimport { ArgMinMaxPackedProgram } from '../argminmax_packed_gpu';\nimport { reshape } from '../kernels/Reshape';\nfunction argReduce(backend, x, reduceType, bestIndicesA = null) {\n    let batchSize = x.shape[0];\n    let inSize = x.shape[1];\n    if (bestIndicesA != null) {\n        batchSize = bestIndicesA.shape[0];\n        inSize = bestIndicesA.shape[1];\n    }\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };\n    const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n    const inputs = [x];\n    if (bestIndicesA != null) {\n        inputs.push(bestIndicesA);\n    }\n    const output = backend.runWebGLProgram(program, inputs, 'int32');\n    // No need to run another GPGPU program.\n    if (output.shape[1] === 1) {\n        return output;\n    }\n    const result = argReduce(backend, x, reduceType, output);\n    backend.disposeIntermediateTensorInfo(output);\n    return result;\n}\nfunction argReducePacked(backend, x, reduceType, bestIndicesA = null) {\n    const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;\n    const inSize = inShape[inShape.length - 1];\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);\n    const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];\n    const output = backend.runWebGLProgram(program, inputs, 'int32');\n    if (output.shape.length === x.shape.length) {\n        const result = argReducePacked(backend, x, reduceType, output);\n        backend.disposeIntermediateTensorInfo(output);\n        return result;\n    }\n    return output;\n}\nexport function argMinMaxReduce(backend, x, axis, reduceType) {\n    const axes = [axis];\n    backend_util.assertAxesAreInnerMostDims('arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);\n    if (!env().getBool('WEBGL_PACK_REDUCE') || x.shape.length <= 2) {\n        const intermediateTensorInfos = [];\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const inSize = util.sizeFromShape(reduceShape);\n        const a2D = reshape({ inputs: { x }, backend, attrs: { shape: [-1, inSize] } });\n        intermediateTensorInfos.push(a2D);\n        const reduced = argReduce(backend, a2D, reduceType);\n        intermediateTensorInfos.push(reduced);\n        const reshaped = reshape({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });\n        intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n        return reshaped;\n    }\n    return argReducePacked(backend, x, reduceType);\n}\n//# sourceMappingURL=arg_min_max.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnaryOpProgram } from '../unaryop_gpu';\nconst TO_INT = `return float(int(x));`;\nexport function int(input, backend) {\n    const program = new UnaryOpProgram(input.shape, TO_INT);\n    const output = backend.runWebGLProgram(program, [input], 'int32');\n    return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };\n}\n//# sourceMappingURL=int.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, upcastType } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { complex } from '../kernels/Complex';\nimport { LEAKYRELU, LEAKYRELU_PACKED } from '../kernels/LeakyRelu';\nimport { PRELU, PRELU_PACKED } from '../kernels/Prelu';\nimport * as unary_op from '../unaryop_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nimport * as unary_packed_op from '../unaryop_packed_gpu';\nimport { UnaryOpPackedProgram } from '../unaryop_packed_gpu';\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function unaryKernelFunc({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {\n    return ({ inputs, backend }) => {\n        const { x } = inputs;\n        const webglBackend = backend;\n        const $dtype = dtype || x.dtype;\n        if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n            const xData = webglBackend.texData.get(x.dataId);\n            const outValues = cpuKernelImpl(xData.values, $dtype);\n            return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n        }\n        const shouldUsePackedProgram = env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n        let program;\n        if (shouldUsePackedProgram) {\n            program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n        }\n        else {\n            program = new UnaryOpProgram(x.shape, opSnippet);\n        }\n        return webglBackend.runWebGLProgram(program, [x], $dtype);\n    };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {\n    return ({ inputs, backend }) => {\n        const { a, b } = inputs;\n        const webglBackend = backend;\n        if (supportsComplex && a.dtype === 'complex64') {\n            const aData = webglBackend.texData.get(a.dataId);\n            const bData = webglBackend.texData.get(b.dataId);\n            const [real, imag] = [\n                [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n                [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n            ].map(complexParts => {\n                const [aPart, bPart] = complexParts;\n                const aHandle = {\n                    dataId: aPart.dataId,\n                    dtype: aPart.dtype,\n                    shape: a.shape\n                };\n                const bHandle = {\n                    dataId: bPart.dataId,\n                    dtype: bPart.dtype,\n                    shape: b.shape\n                };\n                const program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n                return webglBackend.runWebGLProgram(program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n            });\n            const complexOutput = complex({ inputs: { real, imag }, backend: webglBackend });\n            webglBackend.disposeIntermediateTensorInfo(real);\n            webglBackend.disposeIntermediateTensorInfo(imag);\n            // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n            return complexOutput;\n        }\n        const $dtype = dtype || upcastType(a.dtype, b.dtype);\n        if (webglBackend.shouldExecuteOnCPU([a, b]) && cpuKernelImpl != null) {\n            const aData = webglBackend.texData.get(a.dataId);\n            const bData = webglBackend.texData.get(b.dataId);\n            const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, aData.values, bData.values, $dtype);\n            const out = webglBackend.makeTensorInfo(outShape, $dtype);\n            const outData = webglBackend.texData.get(out.dataId);\n            outData.values = outValues;\n            return out;\n        }\n        const shouldUsePackedProgram = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&\n            packedOpSnippet != null;\n        let program;\n        if (shouldUsePackedProgram) {\n            program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n        }\n        else {\n            program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        }\n        return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n    };\n}\nexport function mapActivationToShaderProgram(activation, packed = false) {\n    if (activation === 'linear') {\n        if (packed) {\n            return unary_packed_op.LINEAR;\n        }\n        return unary_op.LINEAR;\n    }\n    else if (activation === 'relu') {\n        if (packed) {\n            return unary_packed_op.RELU;\n        }\n        return unary_op.RELU;\n    }\n    else if (activation === 'elu') {\n        if (packed) {\n            return unary_packed_op.ELU;\n        }\n        return unary_op.ELU;\n    }\n    else if (activation === 'relu6') {\n        if (packed) {\n            return unary_packed_op.RELU6;\n        }\n        return unary_op.RELU6;\n    }\n    else if (activation === 'prelu') {\n        if (packed) {\n            return PRELU_PACKED;\n        }\n        return PRELU;\n    }\n    else if (activation === 'leakyrelu') {\n        if (packed) {\n            return LEAKYRELU_PACKED;\n        }\n        return LEAKYRELU;\n    }\n    throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);\n}\n//# sourceMappingURL=kernel_funcs_utils.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { MeanProgram } from '../mean_gpu';\nimport { ReduceProgram } from '../reduce_gpu';\n// Returns an array of configuration objects that describe each stage of the\n// reduction.\nfunction getReductionStages(inShape) {\n    const stages = [];\n    while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {\n        const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];\n        const windowSize = backend_util.computeOptimalWindowSize(outSize);\n        stages.push({\n            inSize: outSize,\n            windowSize,\n            outSize: Math.ceil(outSize / windowSize)\n        });\n    }\n    return stages;\n}\nexport function reduce(x, dtype, reductionType, backend) {\n    const reductionStages = getReductionStages(x.shape);\n    let result = x;\n    for (let i = 0; i < reductionStages.length; i++) {\n        const { inSize, windowSize, outSize } = reductionStages[i];\n        let program;\n        let previousResult;\n        if (reductionType === 'mean') {\n            program = i === 0 ?\n                new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, inSize) :\n                new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize });\n        }\n        else {\n            program = new ReduceProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, reductionType);\n        }\n        previousResult = result;\n        result = backend.runWebGLProgram(program, [result], dtype);\n        if (previousResult.dataId !== x.dataId) {\n            backend.disposeIntermediateTensorInfo(previousResult);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=reduce.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ReshapePackedProgram } from '../reshape_packed_gpu';\nimport { getBatchDim, getRowsCols } from '../webgl_util';\nexport function packedReshape(input, afterShape, backend) {\n    const input3DShape = [getBatchDim(input.shape),\n        ...getRowsCols(input.shape)];\n    const input3D = {\n        dtype: input.dtype,\n        shape: input3DShape,\n        dataId: input.dataId\n    };\n    const afterShapeAs3D = [getBatchDim(afterShape),\n        ...getRowsCols(afterShape)];\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const output = backend.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };\n}\n//# sourceMappingURL=reshape.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import shared functionality from tfjs-backend-cpu without triggering\n// side effects.\n// tslint:disable-next-line: no-imports-from-dist\nimport * as shared from '@tensorflow/tfjs-backend-cpu/dist/shared';\nconst { addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, lessImpl: lessImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, prodImpl: prodImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, stridedSliceImpl: stridedSliceImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU, } = shared;\nexport { addImplCPU, bincountImplCPU, bincountReduceImplCPU, ceilImplCPU, concatImplCPU, expImplCPU, expm1ImplCPU, floorImplCPU, gatherV2ImplCPU, greaterImplCPU, lessImplCPU, linSpaceImplCPU, logImplCPU, maxImplCPU, maximumImplCPU, minimumImplCPU, multiplyImplCPU, negImplCPU, prodImplCPU, simpleAbsImplCPU, sliceImplCPU, stridedSliceImplCPU, subImplCPU, rangeImplCPU, rsqrtImplCPU, tileImplCPU, topKImplCPU, transposeImplCPU, uniqueImplCPU, };\n//# sourceMappingURL=shared.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Abs, env } from '@tensorflow/tfjs-core';\nimport { simpleAbsImplCPU } from '../kernel_utils/shared';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nimport { UnaryOpPackedProgram } from '../unaryop_packed_gpu';\nconst ABS = `return abs(x);`;\nexport function abs(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    // TODO: handle cases when x is complex. Once the cpu implementation\n    // can handle complex values, refactor to use unaryKernelFunc.\n    if (backend.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n        const xData = backend.texData.get(x.dataId);\n        const outValues = simpleAbsImplCPU(xData.values);\n        return backend.makeTensorInfo(x.shape, x.dtype, outValues);\n    }\n    let program;\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n        program = new UnaryOpPackedProgram(x.shape, ABS);\n    }\n    else {\n        program = new UnaryOpProgram(x.shape, ABS);\n    }\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nexport const absConfig = {\n    kernelName: Abs,\n    backendName: 'webgl',\n    kernelFunc: abs\n};\n//# sourceMappingURL=Abs.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Acos } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst ACOS = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;\nexport const acos = unaryKernelFunc({ opSnippet: ACOS });\nexport const acosConfig = {\n    kernelName: Acos,\n    backendName: 'webgl',\n    kernelFunc: acos,\n};\n//# sourceMappingURL=Acos.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Acosh } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst ACOSH = CHECK_NAN_SNIPPET + `\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));`;\nexport const acosh = unaryKernelFunc({ opSnippet: ACOSH });\nexport const acoshConfig = {\n    kernelName: Acosh,\n    backendName: 'webgl',\n    kernelFunc: acosh,\n};\n//# sourceMappingURL=Acosh.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Add } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { addImplCPU as cpuAdd } from '../kernel_utils/shared';\nconst ADD = 'return a + b;';\nexport const addKernelFunc = binaryKernelFunc({\n    opSnippet: ADD,\n    packedOpSnippet: ADD,\n    supportsComplex: true,\n    cpuKernelImpl: cpuAdd\n});\nexport const addConfig = {\n    kernelName: Add,\n    backendName: 'webgl',\n    kernelFunc: addKernelFunc\n};\n//# sourceMappingURL=Add.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { AddN, env, upcastType } from '@tensorflow/tfjs-core';\nimport { AddNProgram } from '../addn_gpu';\nimport { AddNPackedProgram } from '../addn_packed_gpu';\nimport { identity } from './Identity';\nexport function addN(args) {\n    const { inputs, backend } = args;\n    const tensors = inputs;\n    if (tensors.length === 1) {\n        return identity({ inputs: { x: tensors[0] }, backend });\n    }\n    // Limit the number of uploaded textures for optimization.\n    if (tensors.length > env().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n        const midIndex = Math.floor(tensors.length / 2);\n        const leftSide = addN({ inputs: tensors.slice(0, midIndex), backend });\n        const rightSide = addN({ inputs: tensors.slice(midIndex), backend });\n        return addN({ inputs: [leftSide, rightSide], backend });\n    }\n    const dtype = tensors.map(t => t.dtype).reduce((d1, d2) => upcastType(d1, d2));\n    const shapes = tensors.map(t => t.shape);\n    // We can make sure shapes are identical in op level.\n    const usePackedOp = env().getBool('WEBGL_PACK');\n    const program = usePackedOp ?\n        new AddNPackedProgram(tensors[0].shape, shapes) :\n        new AddNProgram(tensors[0].shape, shapes);\n    return backend.runWebGLProgram(program, tensors, dtype);\n}\nexport const addNConfig = {\n    kernelName: AddN,\n    backendName: 'webgl',\n    kernelFunc: addN\n};\n//# sourceMappingURL=AddN.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { All, backend_util, util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport function all(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(axis, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    let permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });\n        axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    backend_util.assertAxesAreInnerMostDims('all', axes, xRank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = reshape({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });\n    const reduced = reduce(a2D, a2D.dtype, 'all', backend);\n    let res;\n    if (keepDims) {\n        const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n        res = reshape({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });\n    }\n    else {\n        res = reshape({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });\n    }\n    backend.disposeIntermediateTensorInfo(a2D);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo(permutedX);\n    }\n    return res;\n}\nexport const allConfig = {\n    kernelName: All,\n    backendName: 'webgl',\n    kernelFunc: all\n};\n//# sourceMappingURL=All.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Any, backend_util, util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport function any(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(axis, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    let permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });\n        axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    backend_util.assertAxesAreInnerMostDims('any', axes, xRank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = reshape({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });\n    const reduced = reduce(a2D, a2D.dtype, 'any', backend);\n    let res;\n    if (keepDims) {\n        const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n        res = reshape({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });\n    }\n    else {\n        res = reshape({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });\n    }\n    backend.disposeIntermediateTensorInfo(a2D);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo(permutedX);\n    }\n    return res;\n}\nexport const anyConfig = {\n    kernelName: Any,\n    backendName: 'webgl',\n    kernelFunc: any\n};\n//# sourceMappingURL=Any.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ArgMax, backend_util, util } from '@tensorflow/tfjs-core';\nimport { argMinMaxReduce } from '../kernel_utils/arg_min_max';\nimport { transpose } from './Transpose';\nexport function argMax(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis } = attrs;\n    let axes = util.parseAxisParam(axis, x.shape);\n    const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n    let $x = x;\n    const intermediateTensorInfos = [];\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });\n        intermediateTensorInfos.push($x);\n        axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n    }\n    backend_util.assertAxesAreInnerMostDims('argMax', [axes[0]], $x.shape.length);\n    const out = argMinMaxReduce(backend, $x, axes[0], 'max');\n    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return out;\n}\nexport const argMaxConfig = {\n    kernelName: ArgMax,\n    backendName: 'webgl',\n    kernelFunc: argMax\n};\n//# sourceMappingURL=ArgMax.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ArgMin, backend_util, util } from '@tensorflow/tfjs-core';\nimport { argMinMaxReduce } from '../kernel_utils/arg_min_max';\nimport { transpose } from './Transpose';\nexport function argMin(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis } = attrs;\n    let axes = util.parseAxisParam(axis, x.shape);\n    const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n    let $x = x;\n    const intermediateTensorInfos = [];\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });\n        intermediateTensorInfos.push($x);\n        axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n    }\n    backend_util.assertAxesAreInnerMostDims('argMin', [axes[0]], $x.shape.length);\n    const out = argMinMaxReduce(backend, $x, axes[0], 'min');\n    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return out;\n}\nexport const argMinConfig = {\n    kernelName: ArgMin,\n    backendName: 'webgl',\n    kernelFunc: argMin\n};\n//# sourceMappingURL=ArgMin.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Asin } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst ASIN = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;\nexport const asin = unaryKernelFunc({ opSnippet: ASIN });\nexport const asinConfig = {\n    kernelName: Asin,\n    backendName: 'webgl',\n    kernelFunc: asin,\n};\n//# sourceMappingURL=Asin.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Asinh } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;\nexport const asinh = unaryKernelFunc({ opSnippet: ASINH });\nexport const asinhConfig = {\n    kernelName: Asinh,\n    backendName: 'webgl',\n    kernelFunc: asinh,\n};\n//# sourceMappingURL=Asinh.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Atan } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst ATAN = CHECK_NAN_SNIPPET + `\n  return atan(x);\n`;\nexport const atan = unaryKernelFunc({ opSnippet: ATAN });\nexport const atanConfig = {\n    kernelName: Atan,\n    backendName: 'webgl',\n    kernelFunc: atan,\n};\n//# sourceMappingURL=Atan.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Atan2 } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc, CHECK_NAN_SNIPPET_BINARY, CHECK_NAN_SNIPPET_BINARY_PACKED } from '../kernel_utils/kernel_funcs_utils';\nconst ATAN2 = CHECK_NAN_SNIPPET_BINARY + `\n  return atan(a, b);\n`;\nconst ATAN2_PACKED = `\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET_BINARY_PACKED + `\n  return result;\n`;\nexport const atan2 = binaryKernelFunc({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });\nexport const atan2Config = {\n    kernelName: Atan2,\n    backendName: 'webgl',\n    kernelFunc: atan2,\n};\n//# sourceMappingURL=Atan2.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Atanh } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst ATANH = CHECK_NAN_SNIPPET + `\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;`;\nexport const atanh = unaryKernelFunc({ opSnippet: ATANH });\nexport const atanhConfig = {\n    kernelName: Atanh,\n    backendName: 'webgl',\n    kernelFunc: atanh,\n};\n//# sourceMappingURL=Atanh.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { AvgPool, backend_util, util } from '@tensorflow/tfjs-core';\nimport { Pool2DProgram } from '../pool_gpu';\nimport { assertNotComplex } from '../webgl_util';\nimport { identity } from './Identity';\nexport function avgPool(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    assertNotComplex(x, 'avgPool');\n    const { filterSize, strides, pad, dimRoundingMode } = attrs;\n    const dilations = 1;\n    util.assert(backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    const convInfo = backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        return identity({ inputs: { x }, backend });\n    }\n    const avgPoolProgram = new Pool2DProgram(convInfo, 'avg', false);\n    return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\nexport const avgPoolConfig = {\n    kernelName: AvgPool,\n    backendName: 'webgl',\n    kernelFunc: avgPool\n};\n//# sourceMappingURL=AvgPool.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { AvgPool3D, backend_util } from '@tensorflow/tfjs-core';\nimport { Pool3DProgram } from '../pool_gpu';\nexport function avgPool3D(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { filterSize, strides, pad, dimRoundingMode, dataFormat } = attrs;\n    const dilations = [1, 1, 1];\n    const convInfo = backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n    const avgPoolProgram = new Pool3DProgram(convInfo, 'avg', false);\n    return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\nexport const avgPool3DConfig = {\n    kernelName: AvgPool3D,\n    backendName: 'webgl',\n    kernelFunc: avgPool3D\n};\n//# sourceMappingURL=AvgPool3D.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { AvgPool3DGrad, backend_util } from '@tensorflow/tfjs-core';\nimport { AvgPool3DBackpropProgram } from '../avg_pool_backprop_gpu';\nexport function avgPool3DGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, input } = inputs;\n    const x = input;\n    const { filterSize, strides, pad, dimRoundingMode } = attrs;\n    const dilations = [1, 1, 1];\n    const convInfo = backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);\n    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\nexport const avgPoolGrad3DConfig = {\n    kernelName: AvgPool3DGrad,\n    backendName: 'webgl',\n    kernelFunc: avgPool3DGrad\n};\n//# sourceMappingURL=AvgPool3DGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { AvgPoolGrad, backend_util } from '@tensorflow/tfjs-core';\nimport { AvgPool2DBackpropProgram } from '../avg_pool_backprop_gpu';\nimport { assertNotComplex } from '../webgl_util';\nexport function avgPoolGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, input } = inputs;\n    const x = input;\n    assertNotComplex([dy, input], 'avgPoolGrad');\n    const { filterSize, strides, pad } = attrs;\n    const convInfo = backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad);\n    const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);\n    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\nexport const avgPoolGradConfig = {\n    kernelName: AvgPoolGrad,\n    backendName: 'webgl',\n    kernelFunc: avgPoolGrad\n};\n//# sourceMappingURL=AvgPoolGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { BatchMatMul } from '@tensorflow/tfjs-core';\nimport { batchMatMulImpl } from './BatchMatMul_impl';\nexport function batchMatMul(args) {\n    const { inputs, backend, attrs } = args;\n    const { a, b } = inputs;\n    const { transposeA, transposeB } = attrs;\n    return batchMatMulImpl({ a, b, transposeA, transposeB, backend });\n}\nexport const batchMatMulConfig = {\n    kernelName: BatchMatMul,\n    backendName: 'webgl',\n    kernelFunc: batchMatMul,\n};\n//# sourceMappingURL=BatchMatMul.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { upcastType, util } from '@tensorflow/tfjs-core';\nimport { mapActivationToShaderProgram } from '../kernel_utils/kernel_funcs_utils';\nimport { MatMulPackedProgram } from '../mulmat_packed_gpu';\nimport { multiply } from './Multiply';\nimport { reshape } from './Reshape';\nimport { sum } from './Sum';\nimport { transpose } from './Transpose';\n// Empirically determined minimal shared dimension in matmul before we forward\n// to a.mul(b).sum() in order to take advantage of GPU parallelism. See\n// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.\nexport const MATMUL_SHARED_DIM_THRESHOLD = 1000;\nexport function batchMatMulImpl({ a, b, transposeA, transposeB, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {\n    const aRank = a.shape.length;\n    const bRank = b.shape.length;\n    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n    const outerDimsA = a.shape.slice(0, -2);\n    const outerDimsB = b.shape.slice(0, -2);\n    const batchDimA = util.sizeFromShape(outerDimsA);\n    const batchDimB = util.sizeFromShape(outerDimsB);\n    const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;\n    util.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the ` +\n        `same or at least one input batch dimension must be 1. Got input ` +\n        `batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);\n    const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);\n    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n    util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n        `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n        `${b.shape} and transposeA=${transposeA}` +\n        ` and transposeB=${transposeB} must match.`);\n    const a3dShape = transposeA ?\n        [batchDimA, innerShapeA, outerShapeA] :\n        [batchDimA, outerShapeA, innerShapeA];\n    const b3dShape = transposeB ?\n        [batchDimB, outerShapeB, innerShapeB] :\n        [batchDimB, innerShapeB, outerShapeB];\n    // The rest of the implementation is designed to operate on rank-3 tensors\n    const a3d = reshape({ inputs: { x: a }, backend, attrs: { shape: a3dShape } });\n    const b3d = reshape({ inputs: { x: b }, backend, attrs: { shape: b3dShape } });\n    const intermediates = [a3d, b3d];\n    const batchDim = Math.max(batchDimA, batchDimB);\n    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const hasLeakyreluAlpha = activation === 'leakyrelu';\n    const fusedActivation = activation != null ?\n        mapActivationToShaderProgram(activation, true) :\n        null;\n    const containsFusedOps = hasBias || hasPreluActivationWeights ||\n        hasLeakyreluAlpha || fusedActivation != null;\n    let out;\n    // Since the matrices are vectors, it is faster to call mul().sum()\n    // because sum() is O(sqrt(N)) due to divide-and-conquer.\n    if ((outerShapeA === 1 || outerShapeB === 1) &&\n        sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {\n        let aVec = a3d;\n        let bVec = b3d;\n        if (transposeA) {\n            aVec = transpose({ inputs: { x: a3d }, backend, attrs: { perm: [0, 2, 1] } });\n            intermediates.push(aVec);\n        }\n        if (transposeB) {\n            bVec = transpose({ inputs: { x: b3d }, backend, attrs: { perm: [0, 2, 1] } });\n            intermediates.push(bVec);\n        }\n        const shouldReshapeA = outerShapeB !== 1;\n        const shouldReshapeB = outerShapeB === 1;\n        let aVec3d = aVec;\n        if (shouldReshapeA) {\n            aVec3d = reshape({\n                inputs: { x: aVec },\n                backend,\n                attrs: { shape: [batchDim, sharedDim, 1] }\n            });\n            intermediates.push(aVec3d);\n        }\n        const axis = outerShapeB === 1 ? 2 : 1;\n        let bVec3d = bVec;\n        if (shouldReshapeB) {\n            bVec3d = reshape({\n                inputs: { x: bVec },\n                backend,\n                attrs: { shape: [batchDim, 1, sharedDim] }\n            });\n            intermediates.push(bVec3d);\n        }\n        const product = multiply({ inputs: { a: aVec3d, b: bVec3d }, backend });\n        out = sum({ inputs: { x: product }, backend, attrs: { axis, keepDims: true } });\n        intermediates.push(product);\n    }\n    else {\n        const dtype = upcastType(a.dtype, b.dtype);\n        const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n        const inputs = [a3d, b3d];\n        if (bias != null) {\n            inputs.push(bias);\n        }\n        if (hasPreluActivationWeights) {\n            inputs.push(preluActivationWeights);\n        }\n        if (hasLeakyreluAlpha) {\n            const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(leakyreluAlpha, 'float32'));\n            inputs.push($leakyreluAlpha);\n            intermediates.push($leakyreluAlpha);\n        }\n        out = backend.runWebGLProgram(program, inputs, dtype);\n    }\n    const outReshaped = reshape({ inputs: { x: out }, backend, attrs: { shape: outShape } });\n    intermediates.push(out);\n    for (const i of intermediates) {\n        backend.disposeIntermediateTensorInfo(i);\n    }\n    return outReshaped;\n}\n//# sourceMappingURL=BatchMatMul_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, FusedBatchNorm, util } from '@tensorflow/tfjs-core';\nimport { BatchNormProgram } from '../batchnorm_gpu';\nimport { BatchNormPackedProgram } from '../batchnorm_packed_gpu';\nexport const batchNorm = ({ inputs, backend, attrs }) => {\n    const { x, mean, variance, offset, scale } = inputs;\n    util.assert(mean.shape.length === variance.shape.length, () => 'Batch normalization gradient requires mean and variance to have ' +\n        'equal ranks.');\n    util.assert(offset == null || mean.shape.length === offset.shape.length, () => 'Batch normalization gradient requires mean and offset to have ' +\n        'equal ranks.');\n    util.assert(scale == null || mean.shape.length === scale.shape.length, () => 'Batch normalization gradient requires mean and scale to have ' +\n        'equal ranks.');\n    let { varianceEpsilon } = attrs;\n    if (varianceEpsilon == null) {\n        varianceEpsilon = 0.001;\n    }\n    const finalInputs = [x, mean, variance];\n    let offsetShape = null;\n    if (offset != null) {\n        offsetShape = offset.shape;\n        finalInputs.push(offset);\n    }\n    let scaleShape = null;\n    if (scale != null) {\n        scaleShape = scale.shape;\n        finalInputs.push(scale);\n    }\n    const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n        new BatchNormPackedProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) :\n        new BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);\n    const output = backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);\n    return output;\n};\nexport const batchNormConfig = {\n    kernelName: FusedBatchNorm,\n    backendName: 'webgl',\n    kernelFunc: batchNorm,\n};\n//# sourceMappingURL=BatchNorm.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, BatchToSpaceND, util } from '@tensorflow/tfjs-core';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\nimport { transpose } from './Transpose';\nexport const batchToSpaceND = (args) => {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { blockShape, crops } = attrs;\n    util.assert(x.shape.length <= 4, () => 'batchToSpaceND for rank > 4 with a WebGL backend not ' +\n        'implemented yet');\n    const prod = blockShape.reduce((a, b) => a * b);\n    const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n    const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n    const reshapedPermuted = backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n    const sliceBeginCoords = backend_util.getSliceBeginCoords(crops, blockShape.length);\n    const sliceSize = backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n    const toDispose = [];\n    const reshapedIntermediate = reshape({ inputs: { x }, backend, attrs: { shape: reshaped } });\n    const transposedIntermediate = transpose({ inputs: { x: reshapedIntermediate }, backend, attrs: { perm: permuted } });\n    const reshapedIntermediate2 = reshape({\n        inputs: { x: transposedIntermediate },\n        backend,\n        attrs: { shape: reshapedPermuted }\n    });\n    const sliced = slice({\n        inputs: { x: reshapedIntermediate2 },\n        backend,\n        attrs: { begin: sliceBeginCoords, size: sliceSize }\n    });\n    toDispose.push(reshapedIntermediate);\n    toDispose.push(transposedIntermediate);\n    toDispose.push(reshapedIntermediate2);\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return sliced;\n};\nexport const batchToSpaceNDConfig = {\n    kernelName: BatchToSpaceND,\n    backendName: 'webgl',\n    kernelFunc: batchToSpaceND\n};\n//# sourceMappingURL=BatchToSpaceND.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Bincount } from '@tensorflow/tfjs-core';\nimport { bincountImplCPU } from '../kernel_utils/shared';\nexport function bincount(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, weights } = inputs;\n    const { size } = attrs;\n    const xVals = backend.readSync(x.dataId);\n    const weightsVals = backend.readSync(weights.dataId);\n    const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n    return backend.makeTensorInfo([size], weights.dtype, outVals);\n}\nexport const bincountConfig = {\n    kernelName: Bincount,\n    backendName: 'webgl',\n    kernelFunc: bincount\n};\n//# sourceMappingURL=Bincount.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { Cast, util } from '@tensorflow/tfjs-core';\nimport { complex } from './Complex';\nimport { identity } from './Identity';\nimport { notEqual } from './NotEqual';\nimport { real } from './Real';\nimport { int } from '../kernel_utils/int';\nexport function cast(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { dtype } = attrs;\n    // Casting to complex64.\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return identity({ inputs: { x }, backend });\n        }\n        // TODO(annxingyuan): Import kernel function once zeros is modularized.\n        const zerosTensor = tf.zeros(x.shape);\n        const floatX = cast({ inputs: { x }, backend, attrs: { dtype: 'float32' } });\n        const result = complex({ inputs: { real: floatX, imag: zerosTensor }, backend });\n        zerosTensor.dispose();\n        backend.disposeIntermediateTensorInfo(floatX);\n        return result;\n    }\n    // Casting from complex64\n    if (x.dtype === 'complex64') {\n        const realPart = real({ inputs: { input: x }, backend });\n        const result = cast({ inputs: { x: realPart }, backend, attrs: { dtype } });\n        backend.disposeIntermediateTensorInfo(realPart);\n        return result;\n    }\n    if (!util.hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        const result = identity({ inputs: { x }, backend });\n        return { dataId: result.dataId, shape: result.shape, dtype };\n    }\n    if (dtype === 'int32') {\n        return int(x, backend);\n    }\n    if (dtype === 'bool') {\n        const zerosTensorInfo = backend.makeTensorInfo([], 'bool', util.getTypedArrayFromDType('bool', 1));\n        const binaryInputs = { a: x, b: zerosTensorInfo };\n        const result = notEqual({ inputs: binaryInputs, backend });\n        backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n        return result;\n    }\n    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\nexport const castConfig = {\n    kernelName: Cast,\n    backendName: 'webgl',\n    kernelFunc: cast\n};\n//# sourceMappingURL=Cast.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Ceil } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { ceilImplCPU } from '../kernel_utils/shared';\nconst CEIL = `return ceil(x);`;\nexport const ceil = unaryKernelFunc({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });\nexport const ceilConfig = {\n    kernelName: Ceil,\n    backendName: 'webgl',\n    kernelFunc: ceil\n};\n//# sourceMappingURL=Ceil.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ClipByValue, env } from '@tensorflow/tfjs-core';\nimport { ClipProgram } from '../clip_gpu';\nimport { ClipPackedProgram } from '../clip_packed_gpu';\nexport function clipByValue(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { clipValueMin, clipValueMax } = attrs;\n    let program;\n    if (env().getBool('WEBGL_PACK_CLIP')) {\n        program = new ClipPackedProgram(x.shape);\n    }\n    else {\n        program = new ClipProgram(x.shape);\n    }\n    const customSetup = program.getCustomSetupFunc(clipValueMin, clipValueMax);\n    return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n}\nexport const clipByValueConfig = {\n    kernelName: ClipByValue,\n    backendName: 'webgl',\n    kernelFunc: clipByValue\n};\n//# sourceMappingURL=ClipByValue.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Complex } from '@tensorflow/tfjs-core';\nimport { identity } from './Identity';\n/**\n * In WebGL data is stored in GPU textures which can't be efficiently copied, so\n * complex tensors share data with their real and imaginary components. Complex\n * tensors increment the `complexParentRefCount` properties of the underlying\n * data buckets to prevent them from being disposed, as the engine's disposal\n * logic does not account for data sharing by complex tensors.\n *\n * When a complex tensor is disposed, it will explicitly decrease the\n * `complexParentRefCount` properties of its underlying components.\n */\nexport function complex(args) {\n    const { inputs, backend } = args;\n    const { real, imag } = inputs;\n    const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n    const complex = backend.texData.get(complexInfo.dataId);\n    const realTensorInfo = identity({ inputs: { x: real }, backend });\n    const realData = backend.texData.get(realTensorInfo.dataId);\n    realData.complexParentRefCount++;\n    const imagTensorInfo = identity({ inputs: { x: imag }, backend });\n    const imagData = backend.texData.get(imagTensorInfo.dataId);\n    imagData.complexParentRefCount++;\n    complex.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };\n    return complexInfo;\n}\nexport const complexConfig = {\n    kernelName: Complex,\n    backendName: 'webgl',\n    kernelFunc: complex\n};\n//# sourceMappingURL=Complex.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ComplexAbs } from '@tensorflow/tfjs-core';\nimport { ComplexAbsProgram } from '../complex_abs_gpu';\n// Returns a TensorInfo with the complex shape and the dataId of the\n// underlying part. We need to do this because a reshaped complex tensor is\n// not reflected in its parts.\nfunction makeComplexComponentTensorInfo(complexTensor, complexPart) {\n    return {\n        dataId: complexPart.dataId,\n        dtype: complexPart.dtype,\n        shape: complexTensor.shape\n    };\n}\nexport function complexAbs(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    const xData = backend.texData.get(x.dataId);\n    const program = new ComplexAbsProgram(x.shape);\n    const programInputs = [\n        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),\n        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag),\n    ];\n    return backend.runWebGLProgram(program, programInputs, programInputs[0].dtype);\n}\nexport const complexAbsConfig = {\n    kernelName: ComplexAbs,\n    backendName: 'webgl',\n    kernelFunc: complexAbs\n};\n//# sourceMappingURL=ComplexAbs.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Concat, util } from '@tensorflow/tfjs-core';\nimport { concatImpl } from './Concat_impl';\nimport { identity } from './Identity';\nexport function concat(args) {\n    const { inputs, backend, attrs } = args;\n    const { axis } = attrs;\n    const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n    const outShape = backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n    if (util.sizeFromShape(outShape) === 0) {\n        return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n    }\n    // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n    const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n    if ($inputs.length === 1) {\n        return identity({ inputs: { x: $inputs[0] }, backend });\n    }\n    const shapes = $inputs.map(t => t.shape);\n    backend_util.assertParamsConsistent(shapes, $axis);\n    return concatImpl($inputs, $axis, backend);\n}\nexport const concatConfig = {\n    kernelName: Concat,\n    backendName: 'webgl',\n    kernelFunc: concat\n};\n//# sourceMappingURL=Concat.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, util } from '@tensorflow/tfjs-core';\nimport { ConcatProgram } from '../concat_gpu';\nimport { ConcatPackedProgram } from '../concat_packed_gpu';\nimport { concatImplCPU } from '../kernel_utils/shared';\nimport { complex } from './Complex';\nimport { imag } from './Imag';\nimport { real } from './Real';\nimport { reshape } from './Reshape';\nexport function concatImpl(inputs, axis, backend) {\n    const dtype = inputs[0].dtype;\n    if (dtype === 'complex64') {\n        const reals = inputs.map((t) => real({ inputs: { input: t }, backend }));\n        const imags = inputs.map((t) => imag({ inputs: { input: t }, backend }));\n        const realConcated = concatImpl(reals, axis, backend);\n        const imagConcated = concatImpl(imags, axis, backend);\n        const result = complex({ inputs: { real: realConcated, imag: imagConcated }, backend });\n        reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n        imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n        backend.disposeIntermediateTensorInfo(realConcated);\n        backend.disposeIntermediateTensorInfo(imagConcated);\n        return result;\n    }\n    // Run on cpu if dtype is string. For string, the backend represents it\n    // as Uint8Array[], where each Uint8Array is a character. Given that the\n    // computation is only on the outer array, uploading the whole data onto\n    // gpu is wasteful. Also, currently webgl doesn't have a design to\n    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n    // just run the kernel on cpu if dtype is string.\n    if (dtype === 'string') {\n        const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend);\n        const inputsValShapes = tensors2D.map(t => {\n            return { vals: backend.readSync(t.dataId), shape: t.shape };\n        });\n        const simplyConcat = tensors2D[0].shape[0] === 1;\n        const outVals = concatImplCPU(inputsValShapes, outShape, dtype, simplyConcat);\n        const finalOutShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n        const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);\n        tensors2D.forEach(t => backend.disposeIntermediateTensorInfo(t));\n        return outInfo;\n    }\n    if (inputs.length > env().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n        const midIndex = Math.floor(inputs.length / 2);\n        const leftSide = concatImpl(inputs.slice(0, midIndex), axis, backend);\n        const rightSide = concatImpl(inputs.slice(midIndex), axis, backend);\n        const result = concatImpl([leftSide, rightSide], axis, backend);\n        backend.disposeIntermediateTensorInfo(leftSide);\n        backend.disposeIntermediateTensorInfo(rightSide);\n        return result;\n    }\n    if (env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') &&\n        inputs[0].shape.length > 1) {\n        const program = new ConcatPackedProgram(inputs.map(t => t.shape), axis);\n        return backend.runWebGLProgram(program, inputs, dtype);\n    }\n    const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend);\n    const program = new ConcatProgram(tensors2D.map(t => t.shape));\n    const result = backend.runWebGLProgram(program, tensors2D, dtype);\n    tensors2D.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    const reshapedResult = reshape({ inputs: { x: result }, attrs: { shape: outShape }, backend });\n    backend.disposeIntermediateTensorInfo(result);\n    return reshapedResult;\n}\nfunction computeTensors2D(inputs, axis, backend) {\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    const outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n    const tensors2D = inputs.map(x => reshape({\n        inputs: { x },\n        attrs: { shape: [-1, util.sizeFromShape(x.shape.slice(axis))] },\n        backend\n    }));\n    return { tensors2D, outShape };\n}\n//# sourceMappingURL=Concat_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv2D, env } from '@tensorflow/tfjs-core';\nimport { Conv2DProgram } from '../conv_gpu';\nimport { conv2dByMatMul, conv2dWithIm2Row } from './Conv2D_impl';\nimport { reshape } from './Reshape';\nexport function conv2d(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, filter } = inputs;\n    const { strides, pad, dataFormat, dilations, dimRoundingMode } = attrs;\n    const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    let out;\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n        out = conv2dByMatMul({ x, filter, convInfo, backend });\n    }\n    else if (env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n        out = conv2dWithIm2Row({ x, filter, convInfo, backend });\n    }\n    else {\n        const program = new Conv2DProgram(convInfo);\n        out = backend.runWebGLProgram(program, [x, filter], 'float32');\n    }\n    const outReshaped = reshape({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });\n    backend.disposeIntermediateTensorInfo(out);\n    return outReshaped;\n}\nexport const conv2DConfig = {\n    kernelName: Conv2D,\n    backendName: 'webgl',\n    kernelFunc: conv2d,\n};\n//# sourceMappingURL=Conv2D.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv2DBackpropFilter } from '@tensorflow/tfjs-core';\nimport { Conv2DDerFilterProgram } from '../conv_backprop_gpu';\nexport function conv2DBackpropFilter(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, dy } = inputs;\n    const { strides, pad, dataFormat, dimRoundingMode, filterShape } = attrs;\n    const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    const program = new Conv2DDerFilterProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\nexport const conv2DBackpropFilterConfig = {\n    kernelName: Conv2DBackpropFilter,\n    backendName: 'webgl',\n    kernelFunc: conv2DBackpropFilter,\n};\n//# sourceMappingURL=Conv2DBackpropFilter.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv2DBackpropInput } from '@tensorflow/tfjs-core';\nimport { Conv2DDerInputProgram } from '../conv_backprop_gpu';\nexport function conv2DBackpropInput(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, filter } = inputs;\n    const { inputShape, strides, pad, dataFormat, dimRoundingMode } = attrs;\n    const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n    const convInfo = backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n    const program = new Conv2DDerInputProgram(convInfo);\n    return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\nexport const conv2DBackpropInputConfig = {\n    kernelName: Conv2DBackpropInput,\n    backendName: 'webgl',\n    kernelFunc: conv2DBackpropInput,\n};\n//# sourceMappingURL=Conv2DBackpropInput.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { Im2ColPackedProgram } from '../im2col_packed_gpu';\nimport { mapActivationToShaderProgram } from '../kernel_utils/kernel_funcs_utils';\nimport { MatMulPackedProgram } from '../mulmat_packed_gpu';\nimport * as webgl_util from '../webgl_util';\nimport { batchMatMulImpl, MATMUL_SHARED_DIM_THRESHOLD } from './BatchMatMul_impl';\nimport { identity } from './Identity';\nimport { reshape } from './Reshape';\n// For 1x1 kernels that iterate through every point in the input, convolution\n// can be expressed as matrix multiplication (without need for memory\n// remapping).\nexport function conv2dByMatMul({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {\n    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the\n    // result from 2D to 4D.\n    const xShape = x.shape;\n    const xTexData = backend.texData.get(x.dataId);\n    const sharedMatMulDim = convInfo.inChannels;\n    const outerShapeX = xShape[0] * xShape[1] * xShape[2];\n    const outerShapeFilter = convInfo.outChannels;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    const transposeA = false;\n    const transposeB = false;\n    let out;\n    const intermediates = [];\n    // TODO: Once reduction ops are packed, batchMatMul will always be packed\n    // and we can remove this condition.\n    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) &&\n        sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;\n    const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;\n    if (batchMatMulWillBeUnpacked || !env().getBool('WEBGL_LAZILY_UNPACK') ||\n        !env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ||\n        !reshapeWillBeExpensive) {\n        const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :\n            xShape[0] * xShape[2] * xShape[3];\n        const xReshaped = reshape({\n            inputs: { x },\n            backend,\n            attrs: { shape: [1, targetShape, convInfo.inChannels] }\n        });\n        const filterReshaped = reshape({\n            inputs: { x: filter },\n            backend,\n            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }\n        });\n        const result = batchMatMulImpl({\n            a: xReshaped,\n            b: filterReshaped,\n            transposeA,\n            transposeB,\n            backend,\n            bias,\n            activation,\n            preluActivationWeights,\n            leakyreluAlpha\n        });\n        out = reshape({ inputs: { x: result }, backend, attrs: { shape: convInfo.outShape } });\n        intermediates.push(xReshaped);\n        intermediates.push(filterReshaped);\n        intermediates.push(result);\n    }\n    else {\n        // Following optimization is specific to packed |x| with odd row count\n        // (For example, in channelLast mode, 'row count' refers to x.shape[2]):\n        // we avoid expensive packed 2x2 reshape by padding row count to next,\n        // even number. When x.shape[2] is odd, the result of packed batchMatMul is\n        // the same (has the same texture layout and and values in the texture) as\n        // it is for even x.shape[2] + 1. We make the odd-rows tensor to look like\n        // even-rows tensor before the operation and, after the batchMatMul,\n        // fix the even-rows result to have odd number of rows.\n        const targetShape = isChannelsLast ?\n            xShape[0] * xShape[1] * (xShape[2] + 1) :\n            xShape[0] * xShape[2] * (xShape[3] + 1);\n        const xReshaped = {\n            dataId: x.dataId,\n            shape: [1, targetShape, convInfo.inChannels],\n            dtype: x.dtype\n        };\n        // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.\n        // Decrementing row count, after batchMatMul->...->compileProgram leads to\n        // invalid row count within the reference in GPGPUBinary.inShapeInfos.\n        // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos\n        // in compileProgram method, but that would affect compilation of all\n        // programs - instead, provide a copy here, with even row count, before\n        // calling batchMatMul->...->compileProgram and after that, the original\n        // xTexData.shape is restored.\n        const originalXTexDataShape = xTexData.shape;\n        xTexData.shape = xTexData.shape.slice();\n        xTexData.shape[xTexData.shape.length - 2]++;\n        util.assert(webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);\n        const filterReshaped = reshape({\n            inputs: { x: filter },\n            backend,\n            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }\n        });\n        intermediates.push(filterReshaped);\n        const pointwiseConv = batchMatMulImpl({\n            a: xReshaped,\n            b: filterReshaped,\n            backend,\n            transposeA,\n            transposeB,\n            bias,\n            activation,\n            preluActivationWeights,\n            leakyreluAlpha\n        });\n        const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);\n        util.assert(pointwiseConvTexData.isPacked, () => 'batchMatMul result is expected to be packed');\n        // Restore the input shape to original.\n        xTexData.shape = originalXTexDataShape;\n        // Set the output shape - there is no need for expensive reshape as data\n        // layout is already correct.\n        pointwiseConvTexData.shape = convInfo.outShape;\n        out = identity({ inputs: { x: pointwiseConv }, backend });\n        out.shape = convInfo.outShape;\n        intermediates.push(pointwiseConv);\n    }\n    for (const i of intermediates) {\n        backend.disposeIntermediateTensorInfo(i);\n    }\n    return out;\n}\n// Implements the im2row algorithm as outlined in \"High Performance\n// Convolutional Neural Networks for Document Processing\" (Suvisoft, 2006)\nexport function conv2dWithIm2Row({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {\n    // Rearranges conv2d input so each block to be convolved over forms the\n    // column of a new matrix with shape [filterWidth * filterHeight *\n    // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n    // output channel forms a row of a new matrix with shape [outChannels,\n    // filterWidth * filterHeight * inChannels]. The convolution is then\n    // computed by multiplying these matrices and reshaping the result.\n    const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;\n    const isChannelsLast = dataFormat === 'channelsLast';\n    const sharedDim = filterWidth * filterHeight * inChannels;\n    const numCols = outHeight * outWidth;\n    const x2ColShape = [sharedDim, numCols];\n    const transposeA = true;\n    const transposeB = false;\n    const intermediates = [];\n    const xSqueezed = reshape({ inputs: { x }, backend, attrs: { shape: x.shape.slice(1) } });\n    const w2Row = reshape({\n        inputs: { x: filter },\n        backend,\n        attrs: { shape: [1, sharedDim, util.sizeFromShape(filter.shape) / sharedDim] }\n    });\n    intermediates.push(xSqueezed);\n    intermediates.push(w2Row);\n    const im2ColProgram = new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);\n    const im2Col = backend.runWebGLProgram(im2ColProgram, [xSqueezed], 'float32');\n    const im2ColReshaped = reshape({\n        inputs: { x: im2Col },\n        backend,\n        attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }\n    });\n    intermediates.push(im2Col);\n    intermediates.push(im2ColReshaped);\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const hasLeakyreluAlpha = activation === 'leakyrelu';\n    const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;\n    const matmulProgram = new MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n    const inputs = [im2ColReshaped, w2Row];\n    if (bias) {\n        inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n        inputs.push(preluActivationWeights);\n    }\n    if (hasLeakyreluAlpha) {\n        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(leakyreluAlpha, 'float32'));\n        inputs.push($leakyreluAlpha);\n        intermediates.push($leakyreluAlpha);\n    }\n    const product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');\n    const outShape = isChannelsLast ?\n        [1, outHeight, outWidth, convInfo.outChannels] :\n        [1, convInfo.outChannels, outHeight, outWidth];\n    const out = reshape({ inputs: { x: product }, backend, attrs: { shape: outShape } });\n    intermediates.push(product);\n    for (const i of intermediates) {\n        backend.disposeIntermediateTensorInfo(i);\n    }\n    return out;\n}\n//# sourceMappingURL=Conv2D_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv3D } from '@tensorflow/tfjs-core';\nimport { Conv3DProgram } from '../conv_gpu';\nexport function conv3D(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, filter } = inputs;\n    const { strides, pad, dilations } = attrs;\n    const convInfo = backend_util.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad);\n    const program = new Conv3DProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, filter], 'float32');\n}\nexport const conv3DConfig = {\n    kernelName: Conv3D,\n    backendName: 'webgl',\n    kernelFunc: conv3D,\n};\n//# sourceMappingURL=Conv3D.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv3DBackpropFilterV2 } from '@tensorflow/tfjs-core';\nimport { Conv3DDerFilterProgram } from '../conv_backprop_gpu';\nexport function conv3DBackpropFilterV2(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, dy } = inputs;\n    const { strides, pad, filterShape } = attrs;\n    const convInfo = backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad);\n    const program = new Conv3DDerFilterProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\nexport const conv3DBackpropFilterV2Config = {\n    kernelName: Conv3DBackpropFilterV2,\n    backendName: 'webgl',\n    kernelFunc: conv3DBackpropFilterV2\n};\n//# sourceMappingURL=Conv3DBackpropFilterV2.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv3DBackpropInputV2 } from '@tensorflow/tfjs-core';\nimport { Conv3DDerInputProgram } from '../conv_backprop_gpu';\nexport function conv3DBackpropInput(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, filter } = inputs;\n    const { pad, strides, inputShape } = attrs;\n    const convInfo = backend_util.computeConv3DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad);\n    const program = new Conv3DDerInputProgram(convInfo);\n    return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\nexport const conv3DBackpropInputConfig = {\n    kernelName: Conv3DBackpropInputV2,\n    backendName: 'webgl',\n    kernelFunc: conv3DBackpropInput,\n};\n//# sourceMappingURL=Conv3DBackpropInputV2.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Cos } from '@tensorflow/tfjs-core';\nimport { CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst COS = CHECK_NAN_SNIPPET_UNARY + `\n  return cos(x);\n`;\nexport const cos = unaryKernelFunc({ opSnippet: COS });\nexport const cosConfig = {\n    kernelName: Cos,\n    backendName: 'webgl',\n    kernelFunc: cos,\n};\n//# sourceMappingURL=Cos.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Cosh } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst COSH = `\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\nexport const cosh = unaryKernelFunc({ opSnippet: COSH });\nexport const coshConfig = {\n    kernelName: Cosh,\n    backendName: 'webgl',\n    kernelFunc: cosh,\n};\n//# sourceMappingURL=Cosh.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { CropAndResize } from '@tensorflow/tfjs-core';\nimport { CropAndResizeProgram } from '../crop_and_resize_gpu';\nexport const cropAndResize = (args) => {\n    const { inputs, backend, attrs } = args;\n    const { image, boxes, boxInd } = inputs;\n    const { cropSize, method, extrapolationValue } = attrs;\n    const program = new CropAndResizeProgram(image.shape, boxes.shape, cropSize, method, extrapolationValue);\n    return backend.runWebGLProgram(program, [image, boxes, boxInd], 'float32');\n};\nexport const cropAndResizeConfig = {\n    kernelName: CropAndResize,\n    backendName: 'webgl',\n    kernelFunc: cropAndResize\n};\n//# sourceMappingURL=CropAndResize.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Cumsum } from '@tensorflow/tfjs-core';\nimport { CumSumProgram } from '../cumsum_gpu';\nimport { identity } from './Identity';\nimport { transpose } from './Transpose';\nexport function cumsum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, exclusive, reverse } = attrs;\n    const xRank = x.shape.length;\n    const permutation = backend_util.getAxesPermutation([axis], xRank);\n    let permutedX = x;\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutation } });\n    }\n    const permutedAxis = backend_util.getInnerMostAxes(1, xRank)[0];\n    if (permutedAxis !== xRank - 1) {\n        throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.shape.length - 1} ` +\n            `but got axis=${axis}`);\n    }\n    const size = permutedX.shape[permutedAxis];\n    let result = identity({ inputs: { x: permutedX }, backend });\n    // Use cumsum parallel algorithm, ref:\n    // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda\n    for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {\n        const program = new CumSumProgram(permutedX.shape, false, reverse);\n        const customSetup = program.getCustomSetupFunc(i);\n        const prevResult = result;\n        result =\n            backend.runWebGLProgram(program, [result], result.dtype, customSetup);\n        backend.disposeIntermediateTensorInfo(prevResult);\n    }\n    // For exclusive cumsum, shift the end result in the direction of sum\n    // and add 0 to the front index.\n    if (exclusive) {\n        const program = new CumSumProgram(permutedX.shape, exclusive, reverse);\n        const prevResult = result;\n        result = backend.runWebGLProgram(program, [result], result.dtype);\n        backend.disposeIntermediateTensorInfo(prevResult);\n    }\n    if (permutation != null) {\n        const reversePermutation = backend_util.getUndoAxesPermutation(permutation);\n        const reverseTransposedResult = transpose({ inputs: { x: result }, backend, attrs: { perm: reversePermutation } });\n        backend.disposeIntermediateTensorInfo(result);\n        backend.disposeIntermediateTensorInfo(permutedX);\n        return reverseTransposedResult;\n    }\n    return result;\n}\nexport const cumsumConfig = {\n    kernelName: Cumsum,\n    backendName: 'webgl',\n    kernelFunc: cumsum\n};\n//# sourceMappingURL=Cumsum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { DenseBincount } from '@tensorflow/tfjs-core';\nimport { bincountImplCPU, bincountReduceImplCPU } from '../kernel_utils/shared';\nexport function denseBincount(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, weights } = inputs;\n    const { size, binaryOutput } = attrs;\n    if (x.shape.length === 1) {\n        const xVals = backend.readSync(x.dataId);\n        const weightsVals = backend.readSync(weights.dataId);\n        const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n        return backend.makeTensorInfo([size], weights.dtype, outVals);\n    }\n    else if (x.shape.length === 2) {\n        const xBuf = backend.bufferSync(x);\n        const weightsBuf = backend.bufferSync(weights);\n        const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);\n        return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);\n    }\n    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank` +\n        `${x.shape.length}.`);\n}\nexport const denseBincountConfig = {\n    kernelName: DenseBincount,\n    backendName: 'webgl',\n    kernelFunc: denseBincount\n};\n//# sourceMappingURL=DenseBincount.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { DepthToSpace, util } from '@tensorflow/tfjs-core';\nimport { DepthToSpaceProgram } from '../depth_to_space_gpu';\nexport function depthToSpace(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { blockSize, dataFormat } = attrs;\n    util.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n    const batchSize = x.shape[0];\n    const inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];\n    const inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];\n    const inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];\n    const outputHeight = inputHeight * blockSize;\n    const outputWidth = inputWidth * blockSize;\n    const outputDepth = inputDepth / (blockSize * blockSize);\n    const outputShape = (dataFormat === 'NHWC') ?\n        [batchSize, outputHeight, outputWidth, outputDepth] :\n        [batchSize, outputDepth, outputHeight, outputWidth];\n    const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nexport const depthToSpaceConfig = {\n    kernelName: DepthToSpace,\n    backendName: 'webgl',\n    kernelFunc: depthToSpace\n};\n//# sourceMappingURL=DepthToSpace.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, DepthwiseConv2dNative, env, util } from '@tensorflow/tfjs-core';\nimport { DepthwiseConv2DProgram } from '../conv_gpu_depthwise';\nimport { DepthwiseConvPacked2DProgram } from '../conv_packed_gpu_depthwise';\nexport function depthwiseConv2dNative(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, filter } = inputs;\n    const { strides, pad, dilations, dimRoundingMode } = attrs;\n    let $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1];\n    }\n    util.assert(backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n        `1. Got strides ${strides} and dilations '${$dilations}'`);\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);\n    let program;\n    if (env().getBool('WEBGL_PACK_DEPTHWISECONV') && convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1) {\n        program = new DepthwiseConvPacked2DProgram(convInfo);\n    }\n    else {\n        program = new DepthwiseConv2DProgram(convInfo);\n    }\n    return backend.runWebGLProgram(program, [x, filter], 'float32');\n}\nexport const depthwiseConv2dNativeConfig = {\n    kernelName: DepthwiseConv2dNative,\n    backendName: 'webgl',\n    kernelFunc: depthwiseConv2dNative,\n};\n//# sourceMappingURL=DepthwiseConv2dNative.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, DepthwiseConv2dNativeBackpropFilter } from '@tensorflow/tfjs-core';\nimport { DepthwiseConv2DDerFilterProgram } from '../conv_backprop_gpu_depthwise';\nexport function depthwiseConv2dNativeBackpropFilter(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, dy } = inputs;\n    const { strides, dilations, pad, dimRoundingMode, filterShape } = attrs;\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    const program = new DepthwiseConv2DDerFilterProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\nexport const depthwiseConv2dNativeBackpropFilterConfig = {\n    kernelName: DepthwiseConv2dNativeBackpropFilter,\n    backendName: 'webgl',\n    kernelFunc: depthwiseConv2dNativeBackpropFilter\n};\n//# sourceMappingURL=DepthwiseConv2dNativeBackpropFilter.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, DepthwiseConv2dNativeBackpropInput } from '@tensorflow/tfjs-core';\nimport { DepthwiseConv2DDerInputProgram } from '../conv_backprop_gpu_depthwise';\nexport function depthwiseConv2dNativeBackpropInput(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, filter } = inputs;\n    const { strides, dilations, pad, dimRoundingMode, inputShape } = attrs;\n    const convInfo = backend_util.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    const program = new DepthwiseConv2DDerInputProgram(convInfo);\n    return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\nexport const depthwiseConv2dNativeBackpropInputConfig = {\n    kernelName: DepthwiseConv2dNativeBackpropInput,\n    backendName: 'webgl',\n    kernelFunc: depthwiseConv2dNativeBackpropInput\n};\n//# sourceMappingURL=DepthwiseConv2dNativeBackpropInput.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Diag, util } from '@tensorflow/tfjs-core';\nimport { DiagProgram } from '../diag_gpu';\nimport { reshape } from './Reshape';\nexport function diag(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    const outShape = [...x.shape, ...x.shape];\n    const xSize = util.sizeFromShape(x.shape);\n    const flat = reshape({ inputs: { x }, backend, attrs: { shape: [xSize] } });\n    const program = new DiagProgram(xSize);\n    const res = backend.runWebGLProgram(program, [flat], flat.dtype);\n    const out = reshape({ inputs: { x: res }, backend, attrs: { shape: outShape } });\n    backend.disposeIntermediateTensorInfo(flat);\n    backend.disposeIntermediateTensorInfo(res);\n    return out;\n}\nexport const diagConfig = {\n    kernelName: Diag,\n    backendName: 'webgl',\n    kernelFunc: diag\n};\n//# sourceMappingURL=Diag.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Dilation2D } from '@tensorflow/tfjs-core';\nimport { Dilation2DProgram } from '../dilation_gpu';\nimport { reshape } from './Reshape';\nexport function dilation2D(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, filter } = inputs;\n    const { strides, pad, dilations } = attrs;\n    const convInfo = backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations);\n    let out;\n    const program = new Dilation2DProgram(convInfo);\n    out = backend.runWebGLProgram(program, [x, filter], 'float32');\n    const outReshaped = reshape({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });\n    backend.disposeIntermediateTensorInfo(out);\n    return outReshaped;\n}\nexport const dilation2DConfig = {\n    kernelName: Dilation2D,\n    backendName: 'webgl',\n    kernelFunc: dilation2D,\n};\n//# sourceMappingURL=Dilation2D.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Elu } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\nconst ELU_PACKED = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\nconst elu = unaryKernelFunc({ opSnippet: ELU, packedOpSnippet: ELU_PACKED });\nexport const eluConfig = {\n    kernelName: Elu,\n    backendName: 'webgl',\n    kernelFunc: elu\n};\n//# sourceMappingURL=Elu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { EluGrad, env } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nconst ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\nconst ELU_DER_PACKED = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\nexport const eluGrad = (args) => {\n    const { inputs, backend } = args;\n    const { dy, y } = inputs;\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) :\n        new BinaryOpProgram(ELU_DER, dy.shape, y.shape);\n    return backend.runWebGLProgram(program, [dy, y], dy.dtype);\n};\nexport const eluGradConfig = {\n    kernelName: EluGrad,\n    backendName: 'webgl',\n    kernelFunc: eluGrad\n};\n//# sourceMappingURL=EluGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Equal } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst PACKED_EQUAL = `\n  return vec4(equal(a, b));\n`;\nconst EQUAL = `return float(a == b);`;\nexport const equal = binaryKernelFunc({ opSnippet: EQUAL, packedOpSnippet: PACKED_EQUAL, dtype: 'bool' });\nexport const equalConfig = {\n    kernelName: Equal,\n    backendName: 'webgl',\n    kernelFunc: equal\n};\n//# sourceMappingURL=Equal.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Erf } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${backend_util.ERF_P};\n  float a1 = ${backend_util.ERF_A1};\n  float a2 = ${backend_util.ERF_A2};\n  float a3 = ${backend_util.ERF_A3};\n  float a4 = ${backend_util.ERF_A4};\n  float a5 = ${backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;\nexport const erf = unaryKernelFunc({ opSnippet: ERF });\nexport const erfConfig = {\n    kernelName: Erf,\n    backendName: 'webgl',\n    kernelFunc: erf,\n};\n//# sourceMappingURL=Erf.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Exp } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { expImplCPU } from '../kernel_utils/shared';\nexport const EXP = `return exp(x);`;\nexport const exp = unaryKernelFunc({ opSnippet: EXP, packedOpSnippet: EXP, cpuKernelImpl: expImplCPU });\nexport const expConfig = {\n    kernelName: Exp,\n    backendName: 'webgl',\n    kernelFunc: exp\n};\n//# sourceMappingURL=Exp.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ExpandDims, util } from '@tensorflow/tfjs-core';\nimport { reshape } from './Reshape';\nexport function expandDims(args) {\n    const { inputs, attrs, backend } = args;\n    const { dim } = attrs;\n    const { input } = inputs;\n    const inputRank = input.shape.length;\n    const newShape = input.shape.slice();\n    let $dim = dim;\n    if (dim < 0) {\n        // Negative value is counted from the tail of rank.\n        util.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);\n        $dim = inputRank + dim + 1;\n    }\n    newShape.splice($dim, 0, 1);\n    return reshape({ inputs: { x: input }, backend, attrs: { shape: newShape } });\n}\nexport const expandDimsConfig = {\n    kernelName: ExpandDims,\n    backendName: 'webgl',\n    kernelFunc: expandDims,\n};\n//# sourceMappingURL=ExpandDims.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Expm1 } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { expm1ImplCPU } from '../kernel_utils/shared';\nconst EXPM1 = `return exp(x) - 1.0;`;\nexport const expm1 = unaryKernelFunc({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });\nexport const expm1Config = {\n    kernelName: Expm1,\n    backendName: 'webgl',\n    kernelFunc: expm1\n};\n//# sourceMappingURL=Expm1.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { FFT } from '@tensorflow/tfjs-core';\nimport { fftImpl } from './FFT_impl';\nexport function fft(args) {\n    const { inputs, backend } = args;\n    const { input } = inputs;\n    return fftImpl(input, false /* inverse */, backend);\n}\nexport const fftConfig = {\n    kernelName: FFT,\n    backendName: 'webgl',\n    kernelFunc: fft\n};\n//# sourceMappingURL=FFT.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { FFTProgram } from '../fft_gpu';\nimport { complex } from './Complex';\nimport { reshape } from './Reshape';\nexport function fftImpl(x, inverse, backend) {\n    const xData = backend.texData.get(x.dataId);\n    const inputSize = util.sizeFromShape(x.shape);\n    // Collapse all outer dimensions to a single batch dimension.\n    const innerDimensionSize = x.shape[x.shape.length - 1];\n    const batch = inputSize / innerDimensionSize;\n    const input2D = reshape({ inputs: { x }, backend, attrs: { shape: [batch, innerDimensionSize] } });\n    const xShape = input2D.shape;\n    const realProgram = new FFTProgram('real', xShape, inverse);\n    const imagProgram = new FFTProgram('imag', xShape, inverse);\n    const inputs = [\n        {\n            dataId: xData.complexTensorInfos.real.dataId,\n            dtype: xData.complexTensorInfos.real.dtype,\n            shape: xShape\n        },\n        {\n            dataId: xData.complexTensorInfos.imag.dataId,\n            dtype: xData.complexTensorInfos.imag.dtype,\n            shape: xShape\n        }\n    ];\n    const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n    const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n    const complexOutput = complex({ inputs: { real: realPart, imag: imagPart }, backend });\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(imagPart);\n    const complexOutputReshaped = reshape({ inputs: { x: complexOutput }, backend, attrs: { shape: x.shape } });\n    backend.disposeIntermediateTensorInfo(input2D);\n    backend.disposeIntermediateTensorInfo(complexOutput);\n    return complexOutputReshaped;\n}\n//# sourceMappingURL=FFT_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Fill, util } from '@tensorflow/tfjs-core';\nimport { FillProgram } from '../fill_gpu';\nexport function fill(args) {\n    const { backend, attrs } = args;\n    const { shape, value } = attrs;\n    let { dtype } = attrs;\n    dtype = dtype || util.inferDtype(value);\n    if (dtype === 'string') {\n        // String type should be handled in CPU memory.\n        const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n        values.fill(value);\n        return backend.makeTensorInfo(shape, dtype, values);\n    }\n    else {\n        const program = new FillProgram(shape, value);\n        const customSetup = program.getCustomSetupFunc(value);\n        return backend.runWebGLProgram(program, [], dtype, customSetup);\n    }\n}\nexport const fillConfig = {\n    kernelName: Fill,\n    backendName: 'webgl',\n    kernelFunc: fill\n};\n//# sourceMappingURL=Fill.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { FlipLeftRight } from '@tensorflow/tfjs-core';\nimport { FlipLeftRightProgram } from '../flip_left_right_gpu';\nexport const flipLeftRightConfig = {\n    kernelName: FlipLeftRight,\n    backendName: 'webgl',\n    kernelFunc: ({ inputs, backend }) => {\n        const { image } = inputs;\n        const webglBackend = backend;\n        const program = new FlipLeftRightProgram(image.shape);\n        const output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n        return output;\n    }\n};\n//# sourceMappingURL=FlipLeftRight.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Floor } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { floorImplCPU } from '../kernel_utils/shared';\nconst FLOOR = `return floor(x);`;\nexport const floor = unaryKernelFunc({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });\nexport const floorConfig = {\n    kernelName: Floor,\n    backendName: 'webgl',\n    kernelFunc: floor,\n};\n//# sourceMappingURL=Floor.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { FloorDiv } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\n// We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\nconst INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;\nconst INT_DIV_PACKED = `\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;\nexport const floorDiv = binaryKernelFunc({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: 'int32' });\nexport const floorDivConfig = {\n    kernelName: FloorDiv,\n    backendName: 'webgl',\n    kernelFunc: floorDiv\n};\n//# sourceMappingURL=FloorDiv.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { FromPixels } from '@tensorflow/tfjs-core';\nimport { TextureUsage } from '../tex_util';\nimport { FromPixelsProgram } from './FromPixels_utils/from_pixels_gpu';\nimport { FromPixelsPackedProgram } from './FromPixels_utils/from_pixels_packed_gpu';\nexport const fromPixelsConfig = {\n    kernelName: FromPixels,\n    backendName: 'webgl',\n    kernelFunc: fromPixels,\n};\nlet fromPixels2DContext;\nfunction fromPixels(args) {\n    const { inputs, backend, attrs } = args;\n    let { pixels } = inputs;\n    const { numChannels } = attrs;\n    const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n        pixels instanceof HTMLVideoElement;\n    const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n        pixels instanceof HTMLImageElement;\n    const isImageBitmap = typeof (ImageBitmap) !== 'undefined' &&\n        pixels instanceof ImageBitmap;\n    const [width, height] = isVideo ?\n        [\n            pixels.videoWidth,\n            pixels.videoHeight\n        ] :\n        [pixels.width, pixels.height];\n    const texShape = [height, width];\n    const outShape = [height, width, numChannels];\n    if (isImage || isVideo || isImageBitmap) {\n        if (fromPixels2DContext == null) {\n            fromPixels2DContext = document.createElement('canvas').getContext('2d');\n        }\n        fromPixels2DContext.canvas.width = width;\n        fromPixels2DContext.canvas.height = height;\n        fromPixels2DContext.drawImage(pixels, 0, 0, width, height);\n        pixels = fromPixels2DContext.canvas;\n    }\n    const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n    // This is a byte texture with pixels.\n    backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n    backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);\n    const program = env().getBool('WEBGL_PACK') ?\n        new FromPixelsPackedProgram(outShape) :\n        new FromPixelsProgram(outShape);\n    const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n    backend.disposeData(tempPixelHandle.dataId);\n    return res;\n}\n//# sourceMappingURL=FromPixels.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from '../../glsl_version';\nexport class FromPixelsProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        const glsl = getGlslDifferences();\n        const [height, width,] = outputShape;\n        this.outputShape = outputShape;\n        this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);\n\n        vec4 values = ${glsl.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=from_pixels_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from '../../glsl_version';\nexport class FromPixelsPackedProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        const glsl = getGlslDifferences();\n        const [height, width,] = outputShape;\n        this.outputShape = outputShape;\n        this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${width}.0, ${height}.0);\n            vec4 values = ${glsl.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=from_pixels_packed_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, FusedConv2D, util } from '@tensorflow/tfjs-core';\nimport { Conv2DProgram } from '../conv_gpu';\nimport { mapActivationToShaderProgram } from '../kernel_utils/kernel_funcs_utils';\nimport { conv2dByMatMul, conv2dWithIm2Row } from './Conv2D_impl';\nimport { reshape } from './Reshape';\nexport function fusedConv2d(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, filter, bias, preluActivationWeights } = inputs;\n    const { strides, pad, dataFormat, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;\n    const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    let out;\n    const intermediates = [];\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n        out = conv2dByMatMul({\n            x,\n            filter,\n            convInfo,\n            backend,\n            bias,\n            activation,\n            preluActivationWeights,\n            leakyreluAlpha\n        });\n    }\n    else if (env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n        out = conv2dWithIm2Row({\n            x,\n            filter,\n            convInfo,\n            backend,\n            bias,\n            activation,\n            preluActivationWeights,\n            leakyreluAlpha\n        });\n    }\n    else {\n        const hasBias = bias != null;\n        const hasPreluActivationWeights = preluActivationWeights != null;\n        const hasLeakyreluAlpha = activation === 'leakyrelu';\n        const fusedActivation = activation ? mapActivationToShaderProgram(activation, false) : null;\n        const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n        const inputs = [x, filter];\n        if (bias) {\n            inputs.push(bias);\n        }\n        if (preluActivationWeights) {\n            inputs.push(preluActivationWeights);\n        }\n        if (hasLeakyreluAlpha) {\n            const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(leakyreluAlpha, 'float32'));\n            inputs.push($leakyreluAlpha);\n            intermediates.push($leakyreluAlpha);\n        }\n        out = backend.runWebGLProgram(program, inputs, 'float32');\n    }\n    const outReshaped = reshape({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });\n    intermediates.push(out);\n    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return outReshaped;\n}\nexport const fusedConv2DConfig = {\n    kernelName: FusedConv2D,\n    backendName: 'webgl',\n    kernelFunc: fusedConv2d,\n};\n//# sourceMappingURL=FusedConv2D.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, FusedDepthwiseConv2D, util } from '@tensorflow/tfjs-core';\nimport { DepthwiseConv2DProgram } from '../conv_gpu_depthwise';\nimport { DepthwiseConvPacked2DProgram } from '../conv_packed_gpu_depthwise';\nimport { mapActivationToShaderProgram } from '../kernel_utils/kernel_funcs_utils';\nexport function fusedDepthwiseConv2D(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, filter, bias, preluActivationWeights } = inputs;\n    const { strides, pad, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;\n    const intermediates = [];\n    let $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1];\n    }\n    util.assert(backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n        `1. Got strides ${strides} and dilations '${$dilations}'`);\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);\n    const shouldPackDepthwiseConv = env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n        convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1;\n    const fusedActivation = activation ?\n        mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) :\n        null;\n    const programInputs = [x, filter];\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const hasLeakyreluAlpha = activation === 'leakyrelu';\n    if (hasBias) {\n        programInputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n        programInputs.push(preluActivationWeights);\n    }\n    if (hasLeakyreluAlpha) {\n        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(leakyreluAlpha, 'float32'));\n        programInputs.push($leakyreluAlpha);\n        intermediates.push($leakyreluAlpha);\n    }\n    let program;\n    if (shouldPackDepthwiseConv) {\n        program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n    }\n    else {\n        program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n    }\n    const result = backend.runWebGLProgram(program, programInputs, 'float32');\n    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const fusedDepthwiseConv2DConfig = {\n    kernelName: FusedDepthwiseConv2D,\n    backendName: 'webgl',\n    kernelFunc: fusedDepthwiseConv2D,\n};\n//# sourceMappingURL=FusedDepthwiseConv2D.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, GatherNd, util } from '@tensorflow/tfjs-core';\nimport { GatherNDProgram } from '../gather_nd_gpu';\nimport { reshape } from './Reshape';\nexport function gatherNd(args) {\n    const { inputs, backend } = args;\n    const { params, indices } = inputs;\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    const [resultShape, numSlices, sliceSize, strides] = backend_util.prepareAndValidate(params, indices);\n    const flattenIndices = reshape({ inputs: { x: indices }, backend, attrs: { shape: [numSlices, sliceRank] } });\n    const flattenX = reshape({\n        inputs: { x: params },\n        backend,\n        attrs: { shape: [(util.sizeFromShape(params.shape) / sliceSize), sliceSize] }\n    });\n    const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);\n    const res = backend.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);\n    const reshaped = reshape({ inputs: { x: res }, backend, attrs: { shape: resultShape } });\n    backend.disposeIntermediateTensorInfo(flattenIndices);\n    backend.disposeIntermediateTensorInfo(flattenX);\n    backend.disposeIntermediateTensorInfo(res);\n    return reshaped;\n}\nexport const gatherNdConfig = {\n    kernelName: GatherNd,\n    backendName: 'webgl',\n    kernelFunc: gatherNd\n};\n//# sourceMappingURL=GatherNd.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, GatherV2, util } from '@tensorflow/tfjs-core';\nimport { GatherProgram } from '../gather_gpu';\nimport { gatherV2ImplCPU } from '../kernel_utils/shared';\nimport { reshape } from './Reshape';\nexport function gatherV2(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, indices } = inputs;\n    const { axis, batchDims } = attrs;\n    const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n    const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);\n    const indicesSize = util.sizeFromShape(indices.shape);\n    const toDispose = [];\n    const flattenX = reshape({\n        inputs: { x },\n        backend,\n        attrs: {\n            shape: [\n                shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n                shapeInfo.sliceSize\n            ]\n        }\n    });\n    const flattenIndex = reshape({\n        inputs: { x: indices },\n        backend,\n        attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }\n    });\n    toDispose.push(flattenX);\n    toDispose.push(flattenIndex);\n    const flattenOutputShape = [\n        shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n        shapeInfo.sliceSize\n    ];\n    if (backend.shouldExecuteOnCPU([x, indices]) || x.dtype === 'string') {\n        const indicesBuf = backend.bufferSync(flattenIndex);\n        const xBuf = backend.bufferSync(flattenX);\n        const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);\n        toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n        return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);\n    }\n    const program = new GatherProgram(flattenX.shape, flattenOutputShape);\n    const res = backend.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);\n    toDispose.push(res);\n    const reshaped = reshape({ inputs: { x: res }, backend, attrs: { shape: shapeInfo.outputShape } });\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return reshaped;\n}\nexport const gatherV2Config = {\n    kernelName: GatherV2,\n    backendName: 'webgl',\n    kernelFunc: gatherV2\n};\n//# sourceMappingURL=GatherV2.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Greater } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { greaterImplCPU } from '../kernel_utils/shared';\nconst GREATER = `return float(a > b);`;\nconst GREATER_PACKED = `\n  return vec4(greaterThan(a, b));\n`;\nexport const greater = binaryKernelFunc({\n    opSnippet: GREATER,\n    packedOpSnippet: GREATER_PACKED,\n    cpuKernelImpl: greaterImplCPU,\n    dtype: 'bool'\n});\nexport const greaterConfig = {\n    kernelName: Greater,\n    backendName: 'webgl',\n    kernelFunc: greater\n};\n//# sourceMappingURL=Greater.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { GreaterEqual } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst GREATER_EQUAL = `return float(a >= b);`;\nconst GREATER_EQUAL_PACKED = `\n  return vec4(greaterThanEqual(a, b));\n`;\nexport const greaterEqual = binaryKernelFunc({\n    opSnippet: GREATER_EQUAL,\n    packedOpSnippet: GREATER_EQUAL_PACKED,\n    dtype: 'bool'\n});\nexport const greaterEqualConfig = {\n    kernelName: GreaterEqual,\n    backendName: 'webgl',\n    kernelFunc: greaterEqual\n};\n//# sourceMappingURL=GreaterEqual.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { IFFT } from '@tensorflow/tfjs-core';\nimport { fftImpl } from './FFT_impl';\nexport function ifft(args) {\n    const { inputs, backend } = args;\n    const { input } = inputs;\n    return fftImpl(input, true /* inverse */, backend);\n}\nexport const ifftConfig = {\n    kernelName: IFFT,\n    backendName: 'webgl',\n    kernelFunc: ifft\n};\n//# sourceMappingURL=IFFT.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Identity } from '@tensorflow/tfjs-core';\nexport function identity(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    backend.incRef(x.dataId);\n    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };\n}\nexport const identityConfig = {\n    kernelName: Identity,\n    backendName: 'webgl',\n    kernelFunc: identity\n};\n//# sourceMappingURL=Identity.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Imag } from '@tensorflow/tfjs-core';\nimport { identity } from './Identity';\nexport function imag(args) {\n    const { inputs, backend } = args;\n    const { input } = inputs;\n    const inputData = backend.texData.get(input.dataId);\n    return identity({ inputs: { x: inputData.complexTensorInfos.imag }, backend });\n}\nexport const imagConfig = {\n    kernelName: Imag,\n    backendName: 'webgl',\n    kernelFunc: imag\n};\n//# sourceMappingURL=Imag.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { IsFinite } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst IS_FINITE = `return float(!isnan(x) && !isinf(x));`;\nexport const isFinite = unaryKernelFunc({ opSnippet: IS_FINITE, dtype: 'bool' });\nexport const isFiniteConfig = {\n    kernelName: IsFinite,\n    backendName: 'webgl',\n    kernelFunc: isFinite,\n};\n//# sourceMappingURL=IsFinite.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { IsInf } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst IS_INF = `return float(isinf(x));`;\nexport const isInf = unaryKernelFunc({ opSnippet: IS_INF, dtype: 'bool' });\nexport const isInfConfig = {\n    kernelName: IsInf,\n    backendName: 'webgl',\n    kernelFunc: isInf,\n};\n//# sourceMappingURL=IsInf.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { IsNan } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst IS_NAN = `return float(isnan(x));`;\nexport const isNaN = unaryKernelFunc({ opSnippet: IS_NAN, dtype: 'bool' });\nexport const isNaNConfig = {\n    kernelName: IsNan,\n    backendName: 'webgl',\n    kernelFunc: isNaN,\n};\n//# sourceMappingURL=IsNaN.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, LRN } from '@tensorflow/tfjs-core';\nimport { LRNProgram } from '../lrn_gpu';\nimport { LRNPackedProgram } from '../lrn_packed_gpu';\nexport const lrn = (args) => {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { depthRadius, bias, alpha, beta } = attrs;\n    const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n        new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) :\n        new LRNProgram(x.shape, depthRadius, bias, alpha, beta);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n};\n// tslint:disable-next-line: variable-name\nexport const LRNConfig = {\n    kernelName: LRN,\n    backendName: 'webgl',\n    kernelFunc: lrn\n};\n//# sourceMappingURL=LRN.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad } from '@tensorflow/tfjs-core';\nimport { LRNGradProgram } from '../lrn_grad_gpu';\nexport const lrnGrad = (args) => {\n    const { inputs, backend, attrs } = args;\n    const { x, y, dy } = inputs;\n    const { depthRadius, bias, alpha, beta } = attrs;\n    const program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);\n    return backend.runWebGLProgram(program, [x, y, dy], x.dtype);\n};\n// tslint:disable-next-line: variable-name\nexport const LRNGradConfig = {\n    kernelName: LRNGrad,\n    backendName: 'webgl',\n    kernelFunc: lrnGrad\n};\n//# sourceMappingURL=LRNGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, LeakyRelu, util } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nexport const LEAKYRELU = `return (a < 0.) ? b * a : a;`;\nexport const LEAKYRELU_PACKED = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\nexport function leakyRelu(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { alpha } = attrs;\n    const $alpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(alpha, 'float32'));\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) :\n        new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);\n    const result = backend.runWebGLProgram(program, [x, $alpha], x.dtype);\n    backend.disposeIntermediateTensorInfo($alpha);\n    return result;\n}\nexport const leakyReluConfig = {\n    kernelName: LeakyRelu,\n    backendName: 'webgl',\n    kernelFunc: leakyRelu\n};\n//# sourceMappingURL=LeakyRelu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Less } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { lessImplCPU } from '../kernel_utils/shared';\nconst LESS = `return float(a < b);`;\nconst LESS_PACKED = `\n  return vec4(lessThan(a, b));\n`;\nexport const less = binaryKernelFunc({\n    opSnippet: LESS,\n    packedOpSnippet: LESS_PACKED,\n    cpuKernelImpl: lessImplCPU,\n    dtype: 'bool'\n});\nexport const lessConfig = {\n    kernelName: Less,\n    backendName: 'webgl',\n    kernelFunc: less\n};\n//# sourceMappingURL=Less.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LessEqual } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nexport const LESS_EQUAL = `return float(a <= b);`;\nexport const LESS_EQUAL_PACKED = `\n  return vec4(lessThanEqual(a, b));\n`;\nexport const lessEqual = binaryKernelFunc({ opSnippet: LESS_EQUAL, packedOpSnippet: LESS_EQUAL_PACKED, dtype: 'bool' });\nexport const lessEqualConfig = {\n    kernelName: LessEqual,\n    backendName: 'webgl',\n    kernelFunc: lessEqual\n};\n//# sourceMappingURL=LessEqual.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LinSpace } from '@tensorflow/tfjs-core';\nimport { linSpaceImplCPU } from '../kernel_utils/shared';\nexport function linSpace(args) {\n    const { backend, attrs } = args;\n    const { start, stop, num } = attrs;\n    // TODO: Use CPU implementation due to the precision problem in Safari.\n    const outVals = linSpaceImplCPU(start, stop, num);\n    return backend.makeTensorInfo([outVals.length], 'float32', outVals);\n}\nexport const linSpaceConfig = {\n    kernelName: LinSpace,\n    backendName: 'webgl',\n    kernelFunc: linSpace\n};\n//# sourceMappingURL=LinSpace.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Log } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { logImplCPU } from '../kernel_utils/shared';\nconst LOG = `if (x < 0.0) return NAN;\n  return log(x);`;\nconst LOG_PACKED = `\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n`;\nexport const log = unaryKernelFunc({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });\nexport const logConfig = {\n    kernelName: Log,\n    backendName: 'webgl',\n    kernelFunc: log\n};\n//# sourceMappingURL=Log.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Log1p } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst LOG1P = `return log(1.0 + x);`;\nexport const log1p = unaryKernelFunc({ opSnippet: LOG1P });\nexport const log1pConfig = {\n    kernelName: Log1p,\n    backendName: 'webgl',\n    kernelFunc: log1p,\n};\n//# sourceMappingURL=Log1p.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LogicalAnd } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\nconst LOGICAL_AND_PACKED = `\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;\nexport const logicalAnd = binaryKernelFunc({\n    opSnippet: LOGICAL_AND,\n    packedOpSnippet: LOGICAL_AND_PACKED,\n    dtype: 'bool'\n});\nexport const logicalAndConfig = {\n    kernelName: LogicalAnd,\n    backendName: 'webgl',\n    kernelFunc: logicalAnd\n};\n//# sourceMappingURL=LogicalAnd.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LogicalNot } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst LOGICAL_NOT = `return float(!(x >= 1.0));`;\nexport const logicalNot = unaryKernelFunc({ opSnippet: LOGICAL_NOT });\nexport const logicalNotConfig = {\n    kernelName: LogicalNot,\n    backendName: 'webgl',\n    kernelFunc: logicalNot,\n};\n//# sourceMappingURL=LogicalNot.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LogicalOr } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\nconst LOGICAL_OR_PACKED = `\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;\nexport const logicalOr = binaryKernelFunc({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: 'bool' });\nexport const logicalOrConfig = {\n    kernelName: LogicalOr,\n    backendName: 'webgl',\n    kernelFunc: logicalOr\n};\n//# sourceMappingURL=LogicalOr.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Max } from '@tensorflow/tfjs-core';\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { maxImplCPU } from '../kernel_utils/shared';\nimport { maxImpl } from './Max_impl';\nimport { transposeImpl, transposeImplCPU } from './Transpose_impl';\nexport function max(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { reductionIndices, keepDims } = attrs;\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const maxInputIsTransposed = permutedAxes != null;\n    const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x]);\n    let maxInput = x;\n    if (maxInputIsTransposed) {\n        if (shouldExecuteOnCPU) {\n            const xTexData = backend.texData.get(maxInput.dataId);\n            const values = xTexData.values;\n            const newShape = new Array(xRank);\n            for (let i = 0; i < newShape.length; i++) {\n                newShape[i] = x.shape[permutedAxes[i]];\n            }\n            const maxInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n            maxInput = backend.makeTensorInfo(newShape, x.dtype);\n            const maxInputData = backend.texData.get(maxInput.dataId);\n            maxInputData.values = maxInputValues;\n        }\n        else {\n            maxInput = transposeImpl(x, permutedAxes, backend);\n        }\n        axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n    const [maxOutShape, reduceShape] = backend_util.computeOutAndReduceShapes(maxInput.shape, axes);\n    let outShape = maxOutShape;\n    if (keepDims) {\n        // rather than reshape at the end, set the target shape here.\n        outShape = backend_util.expandShapeToKeepDim(maxOutShape, origAxes);\n    }\n    let out;\n    if (shouldExecuteOnCPU) {\n        const xTexData = backend.texData.get(maxInput.dataId);\n        const values = xTexData.values;\n        const outValues = maxImplCPU(values, util.sizeFromShape(reduceShape), outShape, x.dtype);\n        out = backend.makeTensorInfo(outShape, x.dtype);\n        const outData = backend.texData.get(out.dataId);\n        outData.values = outValues;\n    }\n    else {\n        out = maxImpl(maxInput, reduceShape, outShape, backend);\n    }\n    if (maxInputIsTransposed) {\n        backend.disposeIntermediateTensorInfo(maxInput);\n    }\n    return out;\n}\nexport const maxConfig = {\n    kernelName: Max,\n    backendName: 'webgl',\n    kernelFunc: max\n};\n//# sourceMappingURL=Max.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, MaxPool, util } from '@tensorflow/tfjs-core';\nimport { Pool2DProgram } from '../pool_gpu';\nimport { assertNotComplex } from '../webgl_util';\nimport { identity } from './Identity';\nexport function maxPool(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    assertNotComplex(x, 'maxPool');\n    const { filterSize, strides, pad, dimRoundingMode } = attrs;\n    const dilations = 1;\n    util.assert(backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    const convInfo = backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        return identity({ inputs: { x }, backend });\n    }\n    const maxPoolProgram = new Pool2DProgram(convInfo, 'max', false);\n    return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\nexport const maxPoolConfig = {\n    kernelName: MaxPool,\n    backendName: 'webgl',\n    kernelFunc: maxPool\n};\n//# sourceMappingURL=MaxPool.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, MaxPool3D } from '@tensorflow/tfjs-core';\nimport { Pool3DProgram } from '../pool_gpu';\nexport function maxPool3d(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { filterSize, strides, pad, dataFormat, dimRoundingMode } = attrs;\n    const dilations = [1, 1, 1];\n    const convInfo = backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n    const maxPoolProgram = new Pool3DProgram(convInfo, 'max', false);\n    return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\nexport const maxPool3DConfig = {\n    kernelName: MaxPool3D,\n    backendName: 'webgl',\n    kernelFunc: maxPool3d\n};\n//# sourceMappingURL=MaxPool3D.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, MaxPool3DGrad } from '@tensorflow/tfjs-core';\nimport { MaxPool3DBackpropProgram } from '../max_pool_backprop_gpu';\nimport { Pool3DProgram } from '../pool_gpu';\nexport function maxPool3DGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, input } = inputs;\n    const x = input;\n    const { filterSize, strides, pad, dimRoundingMode } = attrs;\n    const dilations = [1, 1, 1];\n    const convInfo = backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    const maxPool3dPositionsProgram = new Pool3DProgram(convInfo, 'max', true /* get positions */);\n    const maxPool3dPositions = backend.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);\n    const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);\n    const result = backend.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions], x.dtype);\n    backend.disposeIntermediateTensorInfo(maxPool3dPositions);\n    return result;\n}\nexport const maxPoolGrad3DConfig = {\n    kernelName: MaxPool3DGrad,\n    backendName: 'webgl',\n    kernelFunc: maxPool3DGrad\n};\n//# sourceMappingURL=MaxPool3DGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, MaxPoolGrad } from '@tensorflow/tfjs-core';\nimport { MaxPool2DBackpropProgram } from '../max_pool_backprop_gpu';\nimport { Pool2DProgram } from '../pool_gpu';\nimport { assertNotComplex } from '../webgl_util';\nexport function maxPoolGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, input, output } = inputs;\n    const x = input;\n    assertNotComplex([input, output], 'maxPoolGrad');\n    const { filterSize, strides, pad, dimRoundingMode } = attrs;\n    const convInfo = backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad, dimRoundingMode);\n    const getPositions = true;\n    const maxPoolPositionsProgram = new Pool2DProgram(convInfo, 'max', getPositions);\n    const maxPoolPositions = backend.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);\n    const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);\n    const result = backend.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);\n    backend.disposeIntermediateTensorInfo(maxPoolPositions);\n    return result;\n}\nexport const maxPoolGradConfig = {\n    kernelName: MaxPoolGrad,\n    backendName: 'webgl',\n    kernelFunc: maxPoolGrad\n};\n//# sourceMappingURL=MaxPoolGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { MaxPoolWithArgmax } from '@tensorflow/tfjs-core';\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { maxPoolWithArgmaxImpl } from './MaxPoolWithArgmax_impl';\nexport const maxPoolWithArgmaxConfig = {\n    kernelName: MaxPoolWithArgmax,\n    backendName: 'webgl',\n    kernelFunc: ({ inputs, attrs, backend }) => {\n        const { x } = inputs;\n        const { filterSize, strides, pad, includeBatchInIndex } = attrs;\n        const webglBackend = backend;\n        util.assert(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);\n        const dilations = [1, 1];\n        util.assert(backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n            `Got strides ${strides} and dilations '${dilations}'`);\n        const convInfo = backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad);\n        const [result, indexes] = maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend);\n        return [result, indexes];\n    }\n};\n//# sourceMappingURL=MaxPoolWithArgmax.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Pool2DProgram } from '../pool_gpu';\nexport function maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, backend) {\n    let program = new Pool2DProgram(convInfo, 'max', false);\n    const poolOutput = backend.runWebGLProgram(program, [x], 'float32');\n    program = new Pool2DProgram(convInfo, 'max', true, true, includeBatchInIndex);\n    const indexOutput = backend.runWebGLProgram(program, [x], 'float32');\n    return [poolOutput, indexOutput];\n}\n//# sourceMappingURL=MaxPoolWithArgmax_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { reshape } from '../kernels/Reshape';\nexport function maxImpl(x, reduceShape, outShape, backend) {\n    const inSize = util.sizeFromShape(reduceShape);\n    const xSize = util.sizeFromShape(x.shape);\n    const batchSize = xSize / inSize;\n    const reshapedInput = reshape({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend });\n    const reduced = reduce(reshapedInput, x.dtype, 'max', backend);\n    const reshapedOutput = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });\n    backend.disposeIntermediateTensorInfo(reshapedInput);\n    backend.disposeIntermediateTensorInfo(reduced);\n    return reshapedOutput;\n}\n//# sourceMappingURL=Max_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Maximum } from '@tensorflow/tfjs-core';\nimport { CHECK_NAN_SNIPPET } from '../binaryop_gpu';\nimport { CHECK_NAN_SNIPPET as CHECK_NAN_SNIPPET_PACKED } from '../binaryop_packed_gpu';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { maximumImplCPU } from '../kernel_utils/shared';\nconst MAXIMUM = CHECK_NAN_SNIPPET + `\n  return max(a, b);\n`;\nconst MAXIMUM_PACKED = `\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\nexport const maximum = binaryKernelFunc({\n    opSnippet: MAXIMUM,\n    packedOpSnippet: MAXIMUM_PACKED,\n    cpuKernelImpl: maximumImplCPU\n});\nexport const maximumConfig = {\n    kernelName: Maximum,\n    backendName: 'webgl',\n    kernelFunc: maximum\n};\n//# sourceMappingURL=Maximum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Mean, util } from '@tensorflow/tfjs-core';\nimport { meanImpl } from './Mean_impl';\nimport { transposeImpl, transposeImplCPU } from './Transpose_impl';\nexport const meanConfig = {\n    kernelName: Mean,\n    backendName: 'webgl',\n    kernelFunc: ({ inputs, attrs, backend }) => {\n        const { x } = inputs;\n        const { keepDims, axis } = attrs;\n        const webglBackend = backend;\n        const xRank = x.shape.length;\n        const origAxes = util.parseAxisParam(axis, x.shape);\n        let axes = origAxes;\n        const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n        const meanInputIsTransposed = permutedAxes != null;\n        const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n        const intermediates = [];\n        let meanInput = x;\n        if (meanInputIsTransposed) {\n            if (shouldExecuteOnCPU) {\n                const xTexData = webglBackend.texData.get(meanInput.dataId);\n                const values = xTexData.values;\n                const newShape = new Array(xRank);\n                for (let i = 0; i < newShape.length; i++) {\n                    newShape[i] = x.shape[permutedAxes[i]];\n                }\n                const meanInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n                meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n                const meanInputData = webglBackend.texData.get(meanInput.dataId);\n                meanInputData.values = meanInputValues;\n            }\n            else {\n                meanInput = transposeImpl(x, permutedAxes, webglBackend);\n            }\n            intermediates.push(meanInput);\n            axes = backend_util.getInnerMostAxes(axes.length, xRank);\n        }\n        backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n        const [meanOutShape, reduceShape] = backend_util.computeOutAndReduceShapes(meanInput.shape, axes);\n        let outShape = meanOutShape;\n        if (keepDims) {\n            // rather than reshape at the end, set the target shape here.\n            outShape = backend_util.expandShapeToKeepDim(meanOutShape, origAxes);\n        }\n        const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);\n        for (const i of intermediates) {\n            webglBackend.disposeIntermediateTensorInfo(i);\n        }\n        return out;\n    }\n};\n//# sourceMappingURL=Mean.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { reshape } from '../kernels/Reshape';\nexport function meanImpl(x, reduceShape, outShape, backend) {\n    const inSize = util.sizeFromShape(reduceShape);\n    const xSize = util.sizeFromShape(x.shape);\n    const batchSize = xSize / inSize;\n    const reshapedInput = reshape({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend });\n    const reduced = reduce(reshapedInput, 'float32', 'mean', backend);\n    const reshapedOutput = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });\n    backend.disposeIntermediateTensorInfo(reshapedInput);\n    backend.disposeIntermediateTensorInfo(reduced);\n    return reshapedOutput;\n}\n//# sourceMappingURL=Mean_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Min, util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport function min(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(axis, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    let permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });\n        axes = backend_util.getInnerMostAxes(axes.length, x.shape.length);\n    }\n    backend_util.assertAxesAreInnerMostDims('min', axes, xRank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = reshape({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });\n    const reduced = reduce(a2D, a2D.dtype, 'min', backend);\n    let res;\n    if (keepDims) {\n        const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n        res = reshape({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });\n    }\n    else {\n        res = reshape({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });\n    }\n    backend.disposeIntermediateTensorInfo(a2D);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo(permutedX);\n    }\n    return res;\n}\nexport const minConfig = {\n    kernelName: Min,\n    backendName: 'webgl',\n    kernelFunc: min\n};\n//# sourceMappingURL=Min.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Minimum } from '@tensorflow/tfjs-core';\nimport { CHECK_NAN_SNIPPET } from '../binaryop_gpu';\nimport { CHECK_NAN_SNIPPET as CHECK_NAN_SNIPPET_PACKED } from '../binaryop_packed_gpu';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { minimumImplCPU } from '../kernel_utils/shared';\nconst MINIMUM = CHECK_NAN_SNIPPET + `\n  return min(a, b);\n`;\nconst MINIMUM_PACKED = `\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\nexport const minimum = binaryKernelFunc({\n    opSnippet: MINIMUM,\n    packedOpSnippet: MINIMUM_PACKED,\n    cpuKernelImpl: minimumImplCPU\n});\nexport const minimumConfig = {\n    kernelName: Minimum,\n    backendName: 'webgl',\n    kernelFunc: minimum\n};\n//# sourceMappingURL=Minimum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, MirrorPad } from '@tensorflow/tfjs-core';\nimport { MirrorPadProgram } from '../mirror_pad_gpu';\nimport { MirrorPadPackedProgram } from '../mirror_pad_packed_gpu';\nexport const mirrorPadKernelFunc = ({ inputs, backend, attrs }) => {\n    const { x } = inputs;\n    const { paddings, mode } = attrs;\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new MirrorPadPackedProgram(x.shape, paddings, mode) :\n        new MirrorPadProgram(x.shape, paddings, mode);\n    const output = backend.runWebGLProgram(program, [x], x.dtype);\n    return output;\n};\nexport const mirrorPadConfig = {\n    kernelName: MirrorPad,\n    backendName: 'webgl',\n    kernelFunc: mirrorPadKernelFunc,\n};\n//# sourceMappingURL=MirrorPad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Mod } from '@tensorflow/tfjs-core';\nimport { CHECK_NAN_SNIPPET } from '../binaryop_packed_gpu';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst MOD = `if (b == 0.0) return NAN;\n  return mod(a, b);`;\nconst MOD_PACKED = `\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\nexport const mod = binaryKernelFunc({\n    opSnippet: MOD,\n    packedOpSnippet: MOD_PACKED,\n});\nexport const modConfig = {\n    kernelName: Mod,\n    backendName: 'webgl',\n    kernelFunc: mod\n};\n//# sourceMappingURL=Mod.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Multinomial } from '@tensorflow/tfjs-core';\nimport { MultinomialProgram } from '../multinomial_gpu';\nimport { softmax } from './Softmax';\nexport function multinomial(args) {\n    const { inputs, backend, attrs } = args;\n    const { logits } = inputs;\n    const { numSamples, seed, normalized } = attrs;\n    const probs = normalized ?\n        logits :\n        softmax({ inputs: { logits }, backend, attrs: { dim: logits.shape.length - 1 } });\n    const batchSize = probs.shape[0];\n    const numOutcomes = probs.shape[1];\n    const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);\n    const customSetup = program.getCustomSetupFunc(seed);\n    const res = backend.runWebGLProgram(program, [probs], 'int32', customSetup);\n    if (!normalized) {\n        backend.disposeIntermediateTensorInfo(probs);\n    }\n    return res;\n}\nexport const multinomialConfig = {\n    kernelName: Multinomial,\n    backendName: 'webgl',\n    kernelFunc: multinomial\n};\n//# sourceMappingURL=Multinomial.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, Multiply } from '@tensorflow/tfjs-core';\nimport * as binaryop_complex_gpu from '../binaryop_complex_gpu';\nimport { BinaryOpComplexProgram } from '../binaryop_complex_gpu';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { multiplyImplCPU as cpuMultiply } from '../kernel_utils/shared';\nimport { complex } from './Complex';\nconst MUL = 'return a * b;';\nexport function multiply(args) {\n    const { inputs, backend } = args;\n    const { a, b } = inputs;\n    const dtype = backend_util.upcastType(a.dtype, b.dtype);\n    if (a.dtype === 'complex64') {\n        const aData = backend.texData.get(a.dataId);\n        const bData = backend.texData.get(b.dataId);\n        const realProgram = new BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n        const imagProgram = new BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n        const inputs = [\n            {\n                dataId: aData.complexTensorInfos.real.dataId,\n                dtype: aData.complexTensorInfos.real.dtype,\n                shape: a.shape\n            },\n            {\n                dataId: aData.complexTensorInfos.imag.dataId,\n                dtype: aData.complexTensorInfos.imag.dtype,\n                shape: a.shape\n            },\n            {\n                dataId: bData.complexTensorInfos.real.dataId,\n                dtype: bData.complexTensorInfos.real.dtype,\n                shape: b.shape\n            },\n            {\n                dataId: bData.complexTensorInfos.imag.dataId,\n                dtype: bData.complexTensorInfos.imag.dtype,\n                shape: b.shape\n            }\n        ];\n        const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n        const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n        const complexOutput = complex({ inputs: { real: realPart, imag: imagPart }, backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        // TODO(annxingyuan): CPU forwarding for complex inputs.\n        return complexOutput;\n    }\n    if (backend.shouldExecuteOnCPU([a, b])) {\n        const aData = backend.texData.get(a.dataId);\n        const bData = backend.texData.get(b.dataId);\n        const [outValues, outShape] = cpuMultiply(a.shape, b.shape, aData.values, bData.values, dtype);\n        const out = backend.makeTensorInfo(outShape, dtype);\n        const outData = backend.texData.get(out.dataId);\n        outData.values = outValues;\n        return out;\n    }\n    let program;\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n        program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);\n    }\n    else {\n        program = new BinaryOpProgram(MUL, a.shape, b.shape);\n    }\n    return backend.runWebGLProgram(program, [a, b], dtype);\n}\nexport const multiplyConfig = {\n    kernelName: Multiply,\n    backendName: 'webgl',\n    kernelFunc: multiply\n};\n//# sourceMappingURL=Multiply.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Neg } from '@tensorflow/tfjs-core';\nimport { negImplCPU } from '../kernel_utils/shared';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nimport { UnaryOpPackedProgram } from '../unaryop_packed_gpu';\nconst NEG = `return -x;`;\n// This doesn't use unaryKernelFunc because negImplCPU is not of type\n// SimpleUnaryKernelImplCPU.\nexport function neg(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    if (backend.shouldExecuteOnCPU([x])) {\n        const xData = backend.texData.get(x.dataId);\n        const [outValues, newShape] = negImplCPU(xData.values, x.shape, x.dtype);\n        return backend.makeTensorInfo(newShape, x.dtype, outValues);\n    }\n    let program;\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n        program = new UnaryOpPackedProgram(x.shape, NEG);\n    }\n    else {\n        program = new UnaryOpProgram(x.shape, NEG);\n    }\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nexport const negConfig = {\n    kernelName: Neg,\n    backendName: 'webgl',\n    kernelFunc: neg\n};\n//# sourceMappingURL=Neg.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, kernel_impls, NonMaxSuppressionV3 } from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV3Impl = kernel_impls.nonMaxSuppressionV3Impl;\nexport function nonMaxSuppressionV3(args) {\n    backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n    const { inputs, backend, attrs } = args;\n    const { boxes, scores } = inputs;\n    const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;\n    const boxesVals = backend.readSync(boxes.dataId);\n    const scoresVals = backend.readSync(scores.dataId);\n    const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n    return backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices));\n}\nexport const nonMaxSuppressionV3Config = {\n    kernelName: NonMaxSuppressionV3,\n    backendName: 'webgl',\n    kernelFunc: nonMaxSuppressionV3\n};\n//# sourceMappingURL=NonMaxSuppressionV3.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, kernel_impls, NonMaxSuppressionV4 } from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV4Impl = kernel_impls.nonMaxSuppressionV4Impl;\nexport function nonMaxSuppressionV4(args) {\n    backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n    const { inputs, backend, attrs } = args;\n    const { boxes, scores } = inputs;\n    const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;\n    const boxesVals = backend.readSync(boxes.dataId);\n    const scoresVals = backend.readSync(scores.dataId);\n    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);\n    return [\n        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n        backend.makeTensorInfo([], 'int32', new Int32Array([validOutputs]))\n    ];\n}\nexport const nonMaxSuppressionV4Config = {\n    kernelName: NonMaxSuppressionV4,\n    backendName: 'webgl',\n    kernelFunc: nonMaxSuppressionV4\n};\n//# sourceMappingURL=NonMaxSuppressionV4.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, kernel_impls, NonMaxSuppressionV5 } from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV5Impl = kernel_impls.nonMaxSuppressionV5Impl;\nexport function nonMaxSuppressionV5(args) {\n    backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n    const { inputs, backend, attrs } = args;\n    const { boxes, scores } = inputs;\n    const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;\n    const boxesVals = backend.readSync(boxes.dataId);\n    const scoresVals = backend.readSync(scores.dataId);\n    const maxOutputSizeVal = maxOutputSize;\n    const iouThresholdVal = iouThreshold;\n    const scoreThresholdVal = scoreThreshold;\n    const softNmsSigmaVal = softNmsSigma;\n    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);\n    return [\n        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n        backend.makeTensorInfo([selectedScores.length], 'float32', new Float32Array(selectedScores))\n    ];\n}\nexport const nonMaxSuppressionV5Config = {\n    kernelName: NonMaxSuppressionV5,\n    backendName: 'webgl',\n    kernelFunc: nonMaxSuppressionV5\n};\n//# sourceMappingURL=NonMaxSuppressionV5.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { NotEqual } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst NOT_EQUAL = `return float(a != b);`;\nexport const notEqual = binaryKernelFunc({ opSnippet: NOT_EQUAL, dtype: 'bool' });\nexport const notEqualConfig = {\n    kernelName: NotEqual,\n    backendName: 'webgl',\n    kernelFunc: notEqual,\n};\n//# sourceMappingURL=NotEqual.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { OneHot, util } from '@tensorflow/tfjs-core';\nimport { OneHotProgram } from '../onehot_gpu';\nimport { reshape } from './Reshape';\nexport const oneHot = (args) => {\n    const { inputs, backend, attrs } = args;\n    const { indices } = inputs;\n    const { depth, onValue, offValue } = attrs;\n    const indicesSize = util.sizeFromShape(indices.shape);\n    const program = new OneHotProgram(indicesSize, depth, onValue, offValue);\n    const reshaped = reshape({ inputs: { x: indices }, backend, attrs: { shape: [indicesSize] } });\n    const result = backend.runWebGLProgram(program, [reshaped], indices.dtype);\n    backend.disposeIntermediateTensorInfo(reshaped);\n    const outShape = [...indices.shape, depth];\n    const out = reshape({ inputs: { x: result }, backend, attrs: { shape: outShape } });\n    backend.disposeIntermediateTensorInfo(result);\n    return out;\n};\nexport const oneHotConfig = {\n    kernelName: OneHot,\n    backendName: 'webgl',\n    kernelFunc: oneHot\n};\n//# sourceMappingURL=OneHot.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { OnesLike } from '@tensorflow/tfjs-core';\nimport { complex } from './Complex';\nimport { fill } from './Fill';\nimport { imag } from './Imag';\nimport { real } from './Real';\nimport { zerosLike } from './ZerosLike';\nexport function onesLike(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    if (x.dtype === 'string') {\n        throw new Error('onesLike is not supported under string dtype');\n    }\n    else if (x.dtype === 'complex64') {\n        const realPart = real({ inputs: { input: x }, backend });\n        const r = onesLike({ inputs: { x: realPart }, backend });\n        const imagPart = imag({ inputs: { input: x }, backend });\n        const i = zerosLike({ inputs: { x: imagPart }, backend });\n        const result = complex({ inputs: { real: r, imag: i }, backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(r);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        backend.disposeIntermediateTensorInfo(i);\n        return result;\n    }\n    else {\n        // TODO(cais, smilkov): Add WebGL shader for onesLike:\n        //   https://github.com/tensorflow/tfjs/issues/1293\n        return fill({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend });\n    }\n}\nexport const onesLikeConfig = {\n    kernelName: OnesLike,\n    backendName: 'webgl',\n    kernelFunc: onesLike\n};\n//# sourceMappingURL=OnesLike.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Pack, util } from '@tensorflow/tfjs-core';\nimport { concat } from './Concat';\nimport { expandDims } from './ExpandDims';\nexport function pack(args) {\n    const { inputs, backend, attrs } = args;\n    const { axis } = attrs;\n    if (inputs.length === 1) {\n        return expandDims({ inputs: { input: inputs[0] }, backend, attrs: { dim: axis } });\n    }\n    const shape = inputs[0].shape;\n    const dtype = inputs[0].dtype;\n    inputs.forEach(t => {\n        util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');\n        util.assert(dtype === t.dtype, () => 'All tensors passed to stack must have matching dtypes');\n    });\n    const intermediateTensorInfos = [];\n    const expandedTensors = inputs.map(t => {\n        const expandedT = expandDims({ inputs: { input: t }, backend, attrs: { dim: axis } });\n        intermediateTensorInfos.push(expandedT);\n        return expandedT;\n    });\n    const result = concat({ inputs: expandedTensors, backend, attrs: { axis } });\n    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const packConfig = {\n    kernelName: Pack,\n    backendName: 'webgl',\n    kernelFunc: pack\n};\n//# sourceMappingURL=Pack.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, PadV2 } from '@tensorflow/tfjs-core';\nimport { PadProgram } from '../pad_gpu';\nimport { PadPackedProgram } from '../pad_packed_gpu';\nexport const padV2 = (args) => {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { paddings, constantValue } = attrs;\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new PadPackedProgram(x.shape, paddings, constantValue) :\n        new PadProgram(x.shape, paddings, constantValue);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n};\nexport const padV2Config = {\n    kernelName: PadV2,\n    backendName: 'webgl',\n    kernelFunc: padV2\n};\n//# sourceMappingURL=PadV2.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Pow } from '@tensorflow/tfjs-core';\nimport { CHECK_NAN_SNIPPET } from '../binaryop_packed_gpu';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst POW = `\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;\nconst POW_PACKED = `\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\nexport const pow = binaryKernelFunc({ opSnippet: POW, packedOpSnippet: POW_PACKED });\nexport const powConfig = {\n    kernelName: Pow,\n    backendName: 'webgl',\n    kernelFunc: pow\n};\n//# sourceMappingURL=Pow.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Prelu } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\nexport const PRELU_PACKED = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\nexport function prelu(args) {\n    const { inputs, backend } = args;\n    const { x, alpha } = inputs;\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) :\n        new BinaryOpProgram(PRELU, x.shape, alpha.shape);\n    return backend.runWebGLProgram(program, [x, alpha], x.dtype);\n}\nexport const preluConfig = {\n    kernelName: Prelu,\n    backendName: 'webgl',\n    kernelFunc: prelu\n};\n//# sourceMappingURL=Prelu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, sumOutType, util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { prodImplCPU } from '../kernel_utils/shared';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport function prod(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    const xRank = x.shape.length;\n    const toDispose = [];\n    const origAxes = util.parseAxisParam(axis, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    let permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });\n        axes = backend_util.getInnerMostAxes(axes.length, xRank);\n        toDispose.push(permutedX);\n    }\n    backend_util.assertAxesAreInnerMostDims('prod', axes, xRank);\n    let res;\n    if (backend.shouldExecuteOnCPU([permutedX])) {\n        const xVals = backend.texData.get(permutedX.dataId).values;\n        const { outVals, outShape, outDtype } = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);\n        res = backend.makeTensorInfo(outShape, outDtype, outVals);\n    }\n    else {\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n        const inSize = util.sizeFromShape(reduceShape);\n        const a2D = reshape({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });\n        const outputDType = sumOutType(x.dtype);\n        const reduced = reduce(a2D, outputDType, 'prod', backend);\n        res = reshape({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });\n        toDispose.push(a2D);\n        toDispose.push(reduced);\n    }\n    if (keepDims) {\n        toDispose.push(res);\n        const newShape = backend_util.expandShapeToKeepDim(res.shape, origAxes);\n        res = reshape({ inputs: { x: res }, backend, attrs: { shape: newShape } });\n    }\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return res;\n}\nexport const prodConfig = {\n    kernelName: Prod,\n    backendName: 'webgl',\n    kernelFunc: prod\n};\n//# sourceMappingURL=Prod.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Range } from '@tensorflow/tfjs-core';\nimport { rangeImplCPU } from '../kernel_utils/shared';\nexport const range = (args) => {\n    const { backend, attrs } = args;\n    const { start, stop, step, dtype } = attrs;\n    const values = rangeImplCPU(start, stop, step, dtype);\n    return backend.makeTensorInfo([values.length], dtype, values);\n};\nexport const rangeConfig = {\n    kernelName: Range,\n    backendName: 'webgl',\n    kernelFunc: range\n};\n//# sourceMappingURL=Range.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Real } from '@tensorflow/tfjs-core';\nimport { identity } from './Identity';\nexport function real(args) {\n    const { inputs, backend } = args;\n    const { input } = inputs;\n    const inputData = backend.texData.get(input.dataId);\n    return identity({ inputs: { x: inputData.complexTensorInfos.real }, backend });\n}\nexport const realConfig = {\n    kernelName: Real,\n    backendName: 'webgl',\n    kernelFunc: real\n};\n//# sourceMappingURL=Real.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { RealDiv } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\n// Without the equality check div produces 0.9999 for a = b, which when\n// floored can cause errors.\nconst DIV = `\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;\n// We do the same as in ./binaryop_gpu, with vec4 and ivec4.\n// On Linux, the vectorized implementation produces NaNs when a and b are 0.\nconst DIV_PACKED = `\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;\nexport const realDiv = binaryKernelFunc({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });\nexport const realDivConfig = {\n    kernelName: RealDiv,\n    backendName: 'webgl',\n    kernelFunc: realDiv,\n};\n//# sourceMappingURL=RealDiv.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Reciprocal } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst RECIPROCAL = `return 1.0 / x;`;\nexport const reciprocal = unaryKernelFunc({ opSnippet: RECIPROCAL });\nexport const reciprocalConfig = {\n    kernelName: Reciprocal,\n    backendName: 'webgl',\n    kernelFunc: reciprocal,\n};\n//# sourceMappingURL=Reciprocal.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Relu } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\nconst RELU_PACKED = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const relu = unaryKernelFunc({ opSnippet: RELU, packedOpSnippet: RELU_PACKED });\nexport const reluConfig = {\n    kernelName: Relu,\n    backendName: 'webgl',\n    kernelFunc: relu\n};\n//# sourceMappingURL=Relu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Relu6 } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { CHECK_NAN_SNIPPET } from '../unaryop_gpu';\nconst RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\nconst RELU6_PACKED = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const relu6 = unaryKernelFunc({ opSnippet: RELU6, packedOpSnippet: RELU6_PACKED });\nexport const relu6Config = {\n    kernelName: Relu6,\n    backendName: 'webgl',\n    kernelFunc: relu6\n};\n//# sourceMappingURL=Relu6.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Reshape, util } from '@tensorflow/tfjs-core';\nimport { packedReshape } from '../kernel_utils/reshape';\nimport { isReshapeFree } from '../webgl_util';\nexport function reshape(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { shape } = attrs;\n    const webglBackend = backend;\n    const xSize = util.sizeFromShape(x.shape);\n    const $shape = util.inferFromImplicitShape(shape, xSize);\n    const $xSize = util.sizeFromShape($shape);\n    util.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old ` +\n        `shape (${x.shape}) has ${xSize} elements. The new shape and old ` +\n        `shape must have the same number of elements.`);\n    const xTexData = webglBackend.texData.get(x.dataId);\n    if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) &&\n        !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {\n        return packedReshape(x, $shape, webglBackend);\n    }\n    webglBackend.incRef(x.dataId);\n    return { dataId: x.dataId, shape: $shape, dtype: x.dtype };\n}\nexport const reshapeConfig = {\n    kernelName: Reshape,\n    backendName: 'webgl',\n    kernelFunc: reshape\n};\n//# sourceMappingURL=Reshape.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, ResizeBilinear } from '@tensorflow/tfjs-core';\nimport { ResizeBilinearProgram } from '../resize_bilinear_gpu';\nimport { ResizeBilinearPackedProgram } from '../resize_bilinear_packed_gpu';\nexport function resizeBilinear(args) {\n    const { inputs, backend, attrs } = args;\n    const { images } = inputs;\n    const { alignCorners, halfPixelCenters, size } = attrs;\n    const [newHeight, newWidth] = size;\n    const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n        new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) :\n        new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);\n    return backend.runWebGLProgram(program, [images], 'float32');\n}\nexport const resizeBilinearConfig = {\n    kernelName: ResizeBilinear,\n    backendName: 'webgl',\n    kernelFunc: resizeBilinear\n};\n//# sourceMappingURL=ResizeBilinear.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad } from '@tensorflow/tfjs-core';\nimport { ResizeBilinearBackpropProgram } from '../resize_bilinear_backprop_gpu';\nexport function resizeBilinearGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { images, dy } = inputs;\n    const { alignCorners } = attrs;\n    const program = new ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);\n    return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\nexport const resizeBilinearGradConfig = {\n    kernelName: ResizeBilinearGrad,\n    backendName: 'webgl',\n    kernelFunc: resizeBilinearGrad\n};\n//# sourceMappingURL=ResizeBilinearGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighbor } from '@tensorflow/tfjs-core';\nimport { ResizeNearestNeighborProgram } from '../resize_nearest_neighbor_gpu';\nexport function resizeNearestNeighbor(args) {\n    const { inputs, backend, attrs } = args;\n    const { images } = inputs;\n    const { alignCorners, halfPixelCenters, size } = attrs;\n    const [newHeight, newWidth] = size;\n    const program = new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);\n    return backend.runWebGLProgram(program, [images], images.dtype);\n}\nexport const resizeNearestNeighborConfig = {\n    kernelName: ResizeNearestNeighbor,\n    backendName: 'webgl',\n    kernelFunc: resizeNearestNeighbor\n};\n//# sourceMappingURL=ResizeNearestNeighbor.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighborGrad } from '@tensorflow/tfjs-core';\nimport { ResizeNearestNeigborBackpropProgram } from '../resize_nearest_neighbor_backprop_gpu';\nexport function resizeNearestNeighborGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { images, dy } = inputs;\n    const { alignCorners } = attrs;\n    const program = new ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);\n    return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\nexport const resizeNearestNeighborGradConfig = {\n    kernelName: ResizeNearestNeighborGrad,\n    backendName: 'webgl',\n    kernelFunc: resizeNearestNeighborGrad\n};\n//# sourceMappingURL=ResizeNearestNeighborGrad.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Reverse, util } from '@tensorflow/tfjs-core';\nimport { ReverseProgram } from '../reverse_gpu';\nimport { ReversePackedProgram } from '../reverse_packed_gpu';\nimport { identity } from './Identity';\nexport function reverse(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { dims } = attrs;\n    const xRank = x.shape.length;\n    const $dims = util.parseAxisParam(dims, x.shape);\n    if (xRank === 0) {\n        return identity({ inputs: { x }, backend });\n    }\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new ReversePackedProgram(x.shape, $dims) :\n        new ReverseProgram(x.shape, $dims);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nexport const reverseConfig = {\n    kernelName: Reverse,\n    backendName: 'webgl',\n    kernelFunc: reverse\n};\n//# sourceMappingURL=Reverse.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { RotateWithOffset } from '@tensorflow/tfjs-core';\nimport { RotateProgram } from '../rotate_gpu';\nexport const rotateWithOffsetConfig = {\n    kernelName: RotateWithOffset,\n    backendName: 'webgl',\n    kernelFunc: ({ inputs, attrs, backend }) => {\n        const { image } = inputs;\n        const { radians, fillValue, center } = attrs;\n        const webglBackend = backend;\n        const program = new RotateProgram(image.shape, radians, fillValue, center);\n        const output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n        return output;\n    }\n};\n//# sourceMappingURL=RotateWithOffset.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Round } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst ROUND = `\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;\nexport const round = unaryKernelFunc({ opSnippet: ROUND });\nexport const roundConfig = {\n    kernelName: Round,\n    backendName: 'webgl',\n    kernelFunc: round,\n};\n//# sourceMappingURL=Round.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Rsqrt } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { rsqrtImplCPU } from '../kernel_utils/shared';\nconst RSQRT = `return inversesqrt(x);`;\nexport const rsqrt = unaryKernelFunc({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });\nexport const rsqrtConfig = {\n    kernelName: Rsqrt,\n    backendName: 'webgl',\n    kernelFunc: rsqrt\n};\n//# sourceMappingURL=Rsqrt.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, ScatterNd } from '@tensorflow/tfjs-core';\nimport { ScatterProgram } from '../scatter_gpu';\nimport { reshape } from './Reshape';\nexport function scatterNd(args) {\n    const { inputs, backend, attrs } = args;\n    const { indices, updates } = inputs;\n    const { shape } = attrs;\n    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(updates, indices, shape);\n    const flattenShape = [outputSize / sliceSize, sliceSize];\n    if (outputSize === 0) {\n        return backend.makeTensorInfo(shape, indices.dtype);\n    }\n    const flattenIndices = reshape({ inputs: { x: indices }, backend, attrs: { shape: [numUpdates, sliceRank] } });\n    const flattenX = reshape({ inputs: { x: updates }, backend, attrs: { shape: [numUpdates, sliceSize] } });\n    const defaultValue = backend.makeTensorInfo([], 'float32', new Float32Array([0])); // scalar(0)\n    const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);\n    const res = backend.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);\n    const reshaped = reshape({ inputs: { x: res }, backend, attrs: { shape } });\n    backend.disposeIntermediateTensorInfo(flattenIndices);\n    backend.disposeIntermediateTensorInfo(flattenX);\n    backend.disposeIntermediateTensorInfo(res);\n    backend.disposeIntermediateTensorInfo(defaultValue);\n    return reshaped;\n}\nexport const scatterNdConfig = {\n    kernelName: ScatterNd,\n    backendName: 'webgl',\n    kernelFunc: scatterNd\n};\n//# sourceMappingURL=ScatterNd.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Select, upcastType } from '@tensorflow/tfjs-core';\nimport { SelectProgram } from '../select_gpu';\nexport function select(args) {\n    const { inputs, backend } = args;\n    const { condition, t, e } = inputs;\n    const program = new SelectProgram(condition.shape.length, t.shape, t.shape.length);\n    return backend.runWebGLProgram(program, [condition, t, e], upcastType(t.dtype, e.dtype));\n}\nexport const selectConfig = {\n    kernelName: Select,\n    backendName: 'webgl',\n    kernelFunc: select\n};\n//# sourceMappingURL=Select.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Selu } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SELU = `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${backend_util.SELU_SCALEALPHA};\n  float scale = ${backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;\nexport const selu = unaryKernelFunc({ opSnippet: SELU });\nexport const seluConfig = {\n    kernelName: Selu,\n    backendName: 'webgl',\n    kernelFunc: selu,\n};\n//# sourceMappingURL=Selu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sigmoid } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\nexport const sigmoid = unaryKernelFunc({ opSnippet: SIGMOID });\nexport const sigmoidConfig = {\n    kernelName: Sigmoid,\n    backendName: 'webgl',\n    kernelFunc: sigmoid,\n};\n//# sourceMappingURL=Sigmoid.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sign } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\n// Sign does not propagate NANs.\nconst SIGN = `\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;\nexport const sign = unaryKernelFunc({ opSnippet: SIGN });\nexport const signConfig = {\n    kernelName: Sign,\n    backendName: 'webgl',\n    kernelFunc: sign,\n};\n//# sourceMappingURL=Sign.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sin } from '@tensorflow/tfjs-core';\nimport { CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SIN = CHECK_NAN_SNIPPET_UNARY + `\n  return sin(x);\n`;\nexport const sin = unaryKernelFunc({ opSnippet: SIN });\nexport const sinConfig = {\n    kernelName: Sin,\n    backendName: 'webgl',\n    kernelFunc: sin,\n};\n//# sourceMappingURL=Sin.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sinh } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SINH = `\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\nexport const sinh = unaryKernelFunc({ opSnippet: SINH });\nexport const sinhConfig = {\n    kernelName: Sinh,\n    backendName: 'webgl',\n    kernelFunc: sinh,\n};\n//# sourceMappingURL=Sinh.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nimport { SliceProgram } from '../slice_gpu';\nimport { SlicePackedProgram } from '../slice_packed_gpu';\nfunction shallowSlice(x, begin, size, backend) {\n    const xTexData = backend.texData.get(x.dataId);\n    const t = backend.makeTensorInfo(size, x.dtype);\n    const newTexData = backend.texData.get(t.dataId);\n    // Copy texture data from the original tensor.\n    Object.assign(newTexData, xTexData);\n    newTexData.complexParentRefCount = 0;\n    newTexData.refCount = 1;\n    newTexData.shape = size;\n    newTexData.dtype = x.dtype;\n    let flatOffset = slice_util.computeFlatOffset(begin, util.computeStrides(x.shape));\n    if (xTexData.slice) {\n        // We are slicing an already sliced tensor, so we have to accumulate\n        // the offset.\n        flatOffset += xTexData.slice.flatOffset;\n    }\n    newTexData.slice = {\n        flatOffset,\n        // Point to the original dataId, which is used to do ref counting.\n        origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n    };\n    // Increase the ref count for that data bucket.\n    const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n    backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n    return t;\n}\nexport function slice(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { begin, size } = attrs;\n    const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n    slice_util.assertParamsValid(x, $begin, $size);\n    if (util.sizeFromShape($size) === 0) {\n        return backend.makeTensorInfo($size, x.dtype, []);\n    }\n    // Run on cpu if dtype is string. For string, the backend represents it\n    // as Uint8Array[], where each Uint8Array is a character. Given that the\n    // computation is only on the outer array, uploading the whole data onto\n    // gpu is wasteful. Also, currently webgl doesn't have a design to\n    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n    // just run the kernel on cpu if dtype is string.\n    if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n        const xTexData = backend.texData.get(x.dataId);\n        const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);\n        return backend.makeTensorInfo($size, x.dtype, outValues);\n    }\n    const { isPacked } = backend.texData.get(x.dataId);\n    const isContinous = slice_util.isSliceContinous(x.shape, $begin, $size);\n    if (isPacked || !isContinous) {\n        const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n            new SlicePackedProgram($size) :\n            new SliceProgram($size);\n        const customSetup = program.getCustomSetupFunc($begin);\n        return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n    }\n    backend.uploadToGPU(x.dataId);\n    return shallowSlice(x, $begin, $size, backend);\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'webgl',\n    kernelFunc: slice\n};\n//# sourceMappingURL=Slice.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Softmax, util } from '@tensorflow/tfjs-core';\nimport { exp } from './Exp';\nimport { max } from './Max';\nimport { realDiv } from './RealDiv';\nimport { reshape } from './Reshape';\nimport { sub } from './Sub';\nimport { sum } from './Sum';\nexport function softmax(args) {\n    const { inputs, backend, attrs } = args;\n    const { logits } = inputs;\n    const { dim } = attrs;\n    const axes = util.parseAxisParam([dim], logits.shape);\n    const maxLogit = max({\n        inputs: { x: logits },\n        backend,\n        attrs: { reductionIndices: axes, keepDims: false }\n    });\n    const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n    const maxLogitsReshaped = reshape({ inputs: { x: maxLogit }, backend, attrs: { shape: expandedShape } });\n    const a = sub({ inputs: { a: logits, b: maxLogitsReshaped }, backend });\n    const b = exp({ inputs: { x: a }, backend });\n    const sumExp = sum({ inputs: { x: b }, backend, attrs: { axis: axes, keepDims: false } });\n    const sumExpReshaped = reshape({ inputs: { x: sumExp }, backend, attrs: { shape: expandedShape } });\n    const res = realDiv({ inputs: { a: b, b: sumExpReshaped }, backend });\n    backend.disposeIntermediateTensorInfo(maxLogit);\n    backend.disposeIntermediateTensorInfo(maxLogitsReshaped);\n    backend.disposeIntermediateTensorInfo(a);\n    backend.disposeIntermediateTensorInfo(b);\n    backend.disposeIntermediateTensorInfo(sumExp);\n    backend.disposeIntermediateTensorInfo(sumExpReshaped);\n    return res;\n}\nexport const softmaxConfig = {\n    kernelName: Softmax,\n    backendName: 'webgl',\n    kernelFunc: softmax\n};\n//# sourceMappingURL=Softmax.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Softplus } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SOFTPLUS = `\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;\nexport const softplus = unaryKernelFunc({ opSnippet: SOFTPLUS });\nexport const softplusConfig = {\n    kernelName: Softplus,\n    backendName: 'webgl',\n    kernelFunc: softplus,\n};\n//# sourceMappingURL=Softplus.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SpaceToBatchND, util } from '@tensorflow/tfjs-core';\nimport { padV2 } from './PadV2';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport const spaceToBatchND = (args) => {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { blockShape, paddings } = attrs;\n    util.assert(x.shape.length <= 4, () => 'spaceToBatchND for rank > 4 with a WebGL backend not ' +\n        'implemented yet');\n    const prod = blockShape.reduce((a, b) => a * b);\n    const completePaddings = [[0, 0]];\n    completePaddings.push(...paddings);\n    for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n        completePaddings.push([0, 0]);\n    }\n    const toDispose = [];\n    const paddedX = padV2({\n        inputs: { x },\n        backend,\n        attrs: { paddings: completePaddings, constantValue: 0 }\n    });\n    const reshapedPaddedShape = backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n    const permutedReshapedPaddedPermutation = backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);\n    const flattenShape = backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n    const reshapedPaddedX = reshape({ inputs: { x: paddedX }, backend, attrs: { shape: reshapedPaddedShape } });\n    const paddedXT = transpose({\n        inputs: { x: reshapedPaddedX },\n        backend,\n        attrs: { perm: permutedReshapedPaddedPermutation }\n    });\n    const result = reshape({ inputs: { x: paddedXT }, backend, attrs: { shape: flattenShape } });\n    toDispose.push(paddedX);\n    toDispose.push(reshapedPaddedX);\n    toDispose.push(paddedXT);\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n};\nexport const spaceToBatchNDConfig = {\n    kernelName: SpaceToBatchND,\n    backendName: 'webgl',\n    kernelFunc: spaceToBatchND\n};\n//# sourceMappingURL=SpaceToBatchND.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SparseToDense } from '@tensorflow/tfjs-core';\nimport { ScatterProgram } from '../scatter_gpu';\nimport { reshape } from './Reshape';\nexport function sparseToDense(args) {\n    const { inputs, backend, attrs } = args;\n    const { sparseIndices, sparseValues, defaultValue } = inputs;\n    const { outputShape } = attrs;\n    const { sliceRank, numUpdates, strides, outputSize } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n    const sumDupeIndices = false;\n    const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);\n    const res = backend.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);\n    const reshaped = reshape({ inputs: { x: res }, backend, attrs: { shape: outputShape } });\n    backend.disposeIntermediateTensorInfo(res);\n    return reshaped;\n}\nexport const sparseToDenseConfig = {\n    kernelName: SparseToDense,\n    backendName: 'webgl',\n    kernelFunc: sparseToDense\n};\n//# sourceMappingURL=SparseToDense.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SplitV, util } from '@tensorflow/tfjs-core';\nimport { slice } from './Slice';\nexport function splitV(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { numOrSizeSplits, axis } = attrs;\n    const $axis = util.parseAxisParam(axis, x.shape)[0];\n    const splitSizes = backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);\n    const xRank = x.shape.length;\n    const begin = new Array(xRank).fill(0);\n    const size = x.shape.slice();\n    return splitSizes.map(s => {\n        const sliceSize = [...size];\n        sliceSize[$axis] = s;\n        const sliceT = slice({ inputs: { x }, backend, attrs: { begin, size: sliceSize } });\n        begin[$axis] += s;\n        return sliceT;\n    });\n}\nexport const splitVConfig = {\n    kernelName: SplitV,\n    backendName: 'webgl',\n    kernelFunc: splitV\n};\n//# sourceMappingURL=SplitV.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sqrt } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SQRT = `return sqrt(x);`;\nexport const sqrt = unaryKernelFunc({ opSnippet: SQRT });\nexport const sqrtConfig = {\n    kernelName: Sqrt,\n    backendName: 'webgl',\n    kernelFunc: sqrt\n};\n//# sourceMappingURL=Sqrt.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Square } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SQUARE = `return x * x;`;\nexport const square = unaryKernelFunc({ opSnippet: SQUARE });\nexport const squareConfig = {\n    kernelName: Square,\n    backendName: 'webgl',\n    kernelFunc: square,\n};\n//# sourceMappingURL=Square.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SquaredDifference } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport const squaredDifference = binaryKernelFunc({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });\nexport const squaredDifferenceConfig = {\n    kernelName: SquaredDifference,\n    backendName: 'webgl',\n    kernelFunc: squaredDifference,\n};\n//# sourceMappingURL=SquaredDifference.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Step } from '@tensorflow/tfjs-core';\nimport { CHECK_NAN_SNIPPET, UnaryOpProgram } from '../unaryop_gpu';\nexport function step({ inputs, attrs, backend }) {\n    const { x } = inputs;\n    const opSnippet = CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${attrs.alpha});\n  `;\n    const program = new UnaryOpProgram(x.shape, opSnippet);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nexport const stepConfig = {\n    kernelName: Step,\n    backendName: 'webgl',\n    kernelFunc: step,\n};\n//# sourceMappingURL=Step.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, slice_util, StridedSlice } from '@tensorflow/tfjs-core';\nimport { stridedSliceImplCPU } from '../kernel_utils/shared';\nimport { StridedSliceProgram } from '../strided_slice_gpu';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\nexport function stridedSlice(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;\n    const { nonStrided, $begin, $strides, size, newShape, outShape } = slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n    const $x = reshape({ inputs: { x }, backend, attrs: { shape: newShape } });\n    let result;\n    if (nonStrided) {\n        const sliced = slice({ inputs: { x: $x }, backend, attrs: { begin: $begin, size } });\n        result = reshape({ inputs: { x: sliced }, backend, attrs: { shape: outShape } });\n        backend.disposeIntermediateTensorInfo(sliced);\n    }\n    else if (outShape.some(axis => axis === 0)) {\n        result = backend.makeTensorInfo(outShape, x.dtype, []);\n    }\n    else {\n        const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([$x]);\n        if (shouldExecuteOnCPU) {\n            const xTexData = backend.texData.get($x.dataId);\n            const values = xTexData.values;\n            const xBuf = buffer($x.shape, $x.dtype, values);\n            const resultValues = stridedSliceImplCPU(outShape, xBuf, $strides, $begin);\n            result = backend.makeTensorInfo(outShape, $x.dtype, resultValues.values);\n        }\n        else {\n            const program = new StridedSliceProgram($begin, $strides, outShape);\n            result = backend.runWebGLProgram(program, [$x], $x.dtype);\n        }\n    }\n    const resultReshaped = reshape({ inputs: { x: result }, backend, attrs: { shape: outShape } });\n    backend.disposeIntermediateTensorInfo($x);\n    backend.disposeIntermediateTensorInfo(result);\n    return resultReshaped;\n}\nexport const stridedSliceConfig = {\n    kernelName: StridedSlice,\n    backendName: 'webgl',\n    kernelFunc: stridedSlice\n};\n//# sourceMappingURL=StridedSlice.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sub } from '@tensorflow/tfjs-core';\nimport { binaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nimport { subImplCPU as cpuSub } from '../kernel_utils/shared';\nconst SUB = 'return a - b;';\nexport const sub = binaryKernelFunc({\n    opSnippet: SUB,\n    packedOpSnippet: SUB,\n    supportsComplex: true,\n    cpuKernelImpl: cpuSub\n});\nexport const subConfig = {\n    kernelName: Sub,\n    backendName: 'webgl',\n    kernelFunc: sub\n};\n//# sourceMappingURL=Sub.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Sum } from '@tensorflow/tfjs-core';\nimport { sumImpl } from './Sum_impl';\nexport function sum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    return sumImpl(x, axis, keepDims, backend);\n}\nexport const sumConfig = {\n    kernelName: Sum,\n    backendName: 'webgl',\n    kernelFunc: sum\n};\n//# sourceMappingURL=Sum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, sumOutType, util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { reshape } from './Reshape';\nimport { transposeImpl } from './Transpose_impl';\nexport function sumImpl(x, axis, keepDims, backend) {\n    const reductionIndices = axis;\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const sumInputIsTransposed = permutedAxes != null;\n    let sumInput = x;\n    if (sumInputIsTransposed) {\n        sumInput = transposeImpl(x, permutedAxes, backend);\n        axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n    const [sumOutShape, reduceShape] = backend_util.computeOutAndReduceShapes(sumInput.shape, axes);\n    let outShape = sumOutShape;\n    if (keepDims) {\n        // rather than reshape at the end, set the target shape here.\n        outShape = backend_util.expandShapeToKeepDim(sumOutShape, origAxes);\n    }\n    const inSize = util.sizeFromShape(reduceShape);\n    const xSize = util.sizeFromShape(x.shape);\n    const batchSize = xSize / inSize;\n    const reshapedInput = reshape({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend });\n    const outType = sumOutType(x.dtype);\n    const reduced = reduce(reshapedInput, outType, 'sum', backend);\n    const out = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });\n    backend.disposeIntermediateTensorInfo(reshapedInput);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (sumInputIsTransposed) {\n        backend.disposeIntermediateTensorInfo(sumInput);\n    }\n    return out;\n}\n//# sourceMappingURL=Sum_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tan } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst TAN = `return tan(x);`;\nexport const tan = unaryKernelFunc({ opSnippet: TAN });\nexport const tanConfig = {\n    kernelName: Tan,\n    backendName: 'webgl',\n    kernelFunc: tan,\n};\n//# sourceMappingURL=Tan.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tanh } from '@tensorflow/tfjs-core';\nimport { unaryKernelFunc } from '../kernel_utils/kernel_funcs_utils';\nconst TANH = `\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;\nexport const tanh = unaryKernelFunc({ opSnippet: TANH });\nexport const tanhConfig = {\n    kernelName: Tanh,\n    backendName: 'webgl',\n    kernelFunc: tanh,\n};\n//# sourceMappingURL=Tanh.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, Tile, util } from '@tensorflow/tfjs-core';\nimport { tileImplCPU } from '../kernel_utils/shared';\nimport { TileProgram } from '../tile_gpu';\nexport function tile(params) {\n    const { inputs, backend, attrs } = params;\n    const { x } = inputs;\n    const { reps } = attrs;\n    if (x.dtype === 'string') {\n        // Even thought string tensor is always on CPU, just to be consistent on how\n        // to access tensor data.\n        const data = backend.readSync(x.dataId);\n        const decodedData = data.map(d => util.decodeString(d));\n        const buf = buffer(x.shape, x.dtype, decodedData);\n        const outBuf = tileImplCPU(buf, reps);\n        return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n    }\n    const program = new TileProgram(x.shape, reps);\n    const output = backend.runWebGLProgram(program, [x], x.dtype);\n    return output;\n}\nexport const tileConfig = {\n    kernelName: Tile,\n    backendName: 'webgl',\n    kernelFunc: tile,\n};\n//# sourceMappingURL=Tile.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TopK } from '@tensorflow/tfjs-core';\nimport { topKImplCPU } from '../kernel_utils/shared';\nexport function topK(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { k, sorted } = attrs;\n    const xVals = backend.readSync(x.dataId);\n    const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, x.shape, x.dtype, k, sorted);\n    return [\n        backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n        backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n    ];\n}\nexport const topKConfig = {\n    kernelName: TopK,\n    backendName: 'webgl',\n    kernelFunc: topK\n};\n//# sourceMappingURL=TopK.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transpose } from '@tensorflow/tfjs-core';\nimport { transposeImpl } from './Transpose_impl';\nimport { transposeImplCPU as cpuTranspose } from './Transpose_impl';\nexport function transpose(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { perm } = attrs;\n    const webglBackend = backend;\n    const xRank = x.shape.length;\n    const newShape = new Array(xRank);\n    for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = x.shape[perm[i]];\n    }\n    let out;\n    if (webglBackend.shouldExecuteOnCPU([x])) {\n        const xTexData = webglBackend.texData.get(x.dataId);\n        const values = xTexData.values;\n        const outValues = cpuTranspose(values, x.shape, x.dtype, perm, newShape);\n        out = webglBackend.makeTensorInfo(newShape, x.dtype);\n        const outData = webglBackend.texData.get(out.dataId);\n        outData.values = outValues;\n    }\n    else {\n        out = transposeImpl(x, perm, webglBackend);\n    }\n    return out;\n}\nexport const transposeConfig = {\n    kernelName: Transpose,\n    backendName: 'webgl',\n    kernelFunc: transpose\n};\n//# sourceMappingURL=Transpose.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { transposeImplCPU } from '../kernel_utils/shared';\nimport { TransposeProgram } from '../transpose_gpu';\nimport { TransposePackedProgram } from '../transpose_packed_gpu';\nexport function transposeImpl(x, perm, backend) {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new TransposePackedProgram(x.shape, perm) :\n        new TransposeProgram(x.shape, perm);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nexport { transposeImplCPU };\n//# sourceMappingURL=Transpose_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Unique } from '@tensorflow/tfjs-core';\nimport { uniqueImplCPU } from '../kernel_utils/shared';\nimport { assertNotComplex } from '../webgl_util';\nexport function unique(args) {\n    const { inputs, attrs, backend } = args;\n    const { axis } = attrs;\n    const { x } = inputs;\n    assertNotComplex(x, 'unique');\n    // For now, always forward calculation to the CPU backend.\n    console.warn('WARNING: ', 'UI might be locked temporarily as data is being downloaded');\n    const values = backend.readSync(x.dataId);\n    const { outputValues, outputShape, indices } = uniqueImplCPU(values, axis, x.shape, x.dtype);\n    return [\n        backend.makeTensorInfo(outputShape, x.dtype, outputValues),\n        backend.makeTensorInfo([indices.length], 'int32', indices),\n    ];\n}\nexport const uniqueConfig = {\n    kernelName: Unique,\n    backendName: 'webgl',\n    kernelFunc: unique,\n};\n//# sourceMappingURL=Unique.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Unpack } from '@tensorflow/tfjs-core';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\nexport function unpack(args) {\n    const { inputs, backend, attrs } = args;\n    const { value } = inputs;\n    let { axis } = attrs;\n    if (axis < 0) {\n        axis += value.shape.length;\n    }\n    const x = value;\n    const xRank = x.shape.length;\n    const num = value.shape[axis];\n    const outShape = new Array(xRank - 1);\n    let outIndex = 0;\n    for (let i = 0; i < xRank; i++) {\n        if (i !== axis) {\n            outShape[outIndex++] = x.shape[i];\n        }\n    }\n    const toDispose = [];\n    const begin = new Array(xRank).fill(0);\n    const size = x.shape.slice();\n    size[axis] = 1;\n    const res = new Array(num);\n    for (let i = 0; i < res.length; i++) {\n        begin[axis] = i;\n        const sliced = slice({ inputs: { x }, backend, attrs: { begin, size } });\n        const reshaped = reshape({ inputs: { x: sliced }, backend, attrs: { shape: outShape } });\n        res[i] = reshaped;\n        toDispose.push(sliced);\n    }\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return res;\n}\nexport const unpackConfig = {\n    kernelName: Unpack,\n    backendName: 'webgl',\n    kernelFunc: unpack\n};\n//# sourceMappingURL=Unpack.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, sumOutType, UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { SegmentOpProgram } from '../segment_gpu';\nimport { range } from './Range';\nimport { reshape } from './Reshape';\nimport { tile } from './Tile';\nimport { transpose } from './Transpose';\nexport function unsortedSegmentSum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, segmentIds } = inputs;\n    const { numSegments } = attrs;\n    const xRank = x.shape.length;\n    const toDispose = [];\n    let axis = 0;\n    const permutation = backend_util.getAxesPermutation([axis], xRank);\n    let permutedX = x;\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutation } });\n        toDispose.push(permutedX);\n        axis = backend_util.getInnerMostAxes(1, xRank)[0];\n    }\n    const outShape = backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n    const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n    const a2D = reshape({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });\n    toDispose.push(a2D);\n    const outputDType = sumOutType(x.dtype);\n    const segOpCompute = (x, segOpType, segmentIds, dtype, numSegments) => {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize = backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n        const segOpInfo = { windowSize, inSize, batchSize, numSegments };\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n            return output;\n        }\n        const rangeInfo = range({\n            backend,\n            attrs: { start: 0, stop: numSegments, step: 1, dtype: 'float32' }\n        });\n        const tileInfo = tile({\n            inputs: { x: rangeInfo },\n            backend,\n            attrs: { reps: [inSize / windowSize] }\n        });\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n        const result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n    };\n    const segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n    const reshaped = reshape({ inputs: { x: segOpResult }, backend, attrs: { shape: outShape } });\n    let result = reshaped;\n    if (permutation != null) {\n        toDispose.push(reshaped);\n        const perm = backend_util.getUndoAxesPermutation(permutation);\n        result = transpose({ inputs: { x: result }, backend, attrs: { perm } });\n    }\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const unsortedSegmentSumConfig = {\n    kernelName: UnsortedSegmentSum,\n    backendName: 'webgl',\n    kernelFunc: unsortedSegmentSum\n};\n//# sourceMappingURL=UnsortedSegmentSum.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ZerosLike } from '@tensorflow/tfjs-core';\nimport { complex } from './Complex';\nimport { fill } from './Fill';\nimport { imag } from './Imag';\nimport { real } from './Real';\nexport function zerosLike(args) {\n    const { inputs, backend } = args;\n    const { x } = inputs;\n    if (x.dtype === 'complex64') {\n        const realPart = real({ inputs: { input: x }, backend });\n        const r = zerosLike({ inputs: { x: realPart }, backend });\n        const imagPart = imag({ inputs: { input: x }, backend });\n        const i = zerosLike({ inputs: { x: imagPart }, backend });\n        const result = complex({ inputs: { real: r, imag: i }, backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(r);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        backend.disposeIntermediateTensorInfo(i);\n        return result;\n    }\n    else {\n        return fill({\n            attrs: {\n                shape: x.shape,\n                dtype: x.dtype,\n                value: x.dtype === 'string' ? '' : 0\n            },\n            backend\n        });\n    }\n}\nexport const zerosLikeConfig = {\n    kernelName: ZerosLike,\n    backendName: 'webgl',\n    kernelFunc: zerosLike\n};\n//# sourceMappingURL=ZerosLike.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { _FusedMatMul } from '@tensorflow/tfjs-core';\nimport { batchMatMulImpl } from './BatchMatMul_impl';\nexport function _fusedMatMul(args) {\n    const { inputs, backend, attrs } = args;\n    const { a, b, bias, preluActivationWeights } = inputs;\n    const { transposeA, transposeB, activation, leakyreluAlpha } = attrs;\n    return batchMatMulImpl({\n        a,\n        b,\n        transposeA,\n        transposeB,\n        backend,\n        bias,\n        preluActivationWeights,\n        leakyreluAlpha,\n        activation\n    });\n}\nexport const _fusedMatMulConfig = {\n    kernelName: _FusedMatMul,\n    backendName: 'webgl',\n    kernelFunc: _fusedMatMul,\n};\n//# sourceMappingURL=_FusedMatMul.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class LRNProgram {\n    constructor(xShape, radius, bias, alpha, beta) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        const rad = radius;\n        const maxD = xShape[3] - 1;\n        this.outputShape = xShape;\n        // optimize pow(bias + alpha * sum, -beta)\n        // src: https://github.com/tensorflow/tensorflow/..\n        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n        // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n        let powOperator;\n        const basis = `float(${bias}) + float(${alpha}) * sum`;\n        if (beta === 0.5) {\n            powOperator = `inversesqrt(${basis})`;\n        }\n        else if (beta === 1.0) {\n            powOperator = `1.0/(${basis})`;\n        }\n        else {\n            powOperator = `exp(log(${basis}) * float(-${beta}));`;\n        }\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${rad}; j <= ${rad}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${maxD}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${powOperator};\n        setOutput(val);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=lrn_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class LRNGradProgram {\n    constructor(inputShape, depthRadius, bias, alpha, beta) {\n        this.variableNames = ['inputImage', 'outputImage', 'dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        this.depth = inputShape[3];\n        this.depthRadius = depthRadius;\n        this.bias = bias;\n        this.alpha = alpha;\n        this.beta = beta;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${depthRadius})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${depthRadius} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${alpha}) * norm + float(${bias});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${alpha})\n                * float(${beta})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${beta});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=lrn_grad_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class LRNPackedProgram {\n    constructor(xShape, radius, bias, alpha, beta) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const rad = radius;\n        const maxD = xShape[3] - 1;\n        this.outputShape = xShape;\n        // optimize pow(bias + alpha * sum, -beta)\n        // src: https://github.com/tensorflow/tensorflow/..\n        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n        // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n        let powOperator;\n        const basis = `float(${bias}) + float(${alpha}) * sum`;\n        if (beta === 0.5) {\n            powOperator = `inversesqrt(${basis})`;\n        }\n        else if (beta === 1.0) {\n            powOperator = `1.0/(${basis})`;\n        }\n        else {\n            powOperator = `exp(log(${basis}) * float(-${beta}));`;\n        }\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${rad};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${rad}; j <= ${rad}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${powOperator};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=lrn_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MaxPool2DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'maxPos'];\n        this.outputShape = convInfo.inShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n          wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${effectiveFilterWidth} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class MaxPool3DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'maxPos'];\n        this.outputShape = convInfo.inShape;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n           wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${lastIndex} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                  wR * ${effectiveFilterWidth} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=max_pool_backprop_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport class MeanProgram {\n    constructor(reduceInfo, divisor) {\n        this.variableNames = ['x'];\n        const { windowSize, batchSize, inSize, outSize } = reduceInfo;\n        this.outputShape = [batchSize, outSize];\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        let updateSnippet = `sumValue += dot(values, ones);`;\n        if (divisor != null) {\n            const denominator = 1 / divisor;\n            updateSnippet = `sumValue += dot(values * ${util.isInt(denominator) ? denominator.toPrecision(2) :\n                denominator}, ones);`;\n        }\n        let checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return 0.0;\n        }\n      `;\n        }\n        this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${updateSnippet}\n        }\n        setOutput(sumValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mean_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class MirrorPadProgram {\n    constructor(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        const offset = mode === 'reflect' ? 0 : 1;\n        if (rank === 1) {\n            this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${offset};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${offset};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;\n            return;\n        }\n        this.userCode = `\n      ${dtype} start = ${dtype}(${start});\n      ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outC = getOutputCoords();\n        for (int i = 0; i < ${rank}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${offset};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};\n          }\n        }\n        ${dtype} coords = outC - start;\n        setOutput(getX(${unpackedCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mirror_pad_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nexport class MirrorPadPackedProgram {\n    constructor(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const offset = mode === 'reflect' ? 0 : 1;\n        let mainLoop = '';\n        if (rank === 1) {\n            const padSetup = `\n        ${dtype} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${offset};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${offset};\n        }\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        else {\n            const padSetup = `\n        ${dtype} source = rc;\n        ${dtype} lt = ${dtype}(lessThan(source, start));\n        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));\n        ${dtype} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${offset}) +\n                gte * ((end - 1) * 2 - source + ${offset});\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n        rc = outputLoc;\n        ${coords[rank - 2]} += 1;\n        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {\n          ${padSetup}\n          result[2] = getChannel(getX(${source.join()}), ${innerDims});\n          ${coords[rank - 1]} += 1;\n          if(${cLimit}) {\n            ${padSetup}\n            result[3] = getChannel(getX(${source.join()}), ${innerDims});\n          }\n        }\n      `;\n        }\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mirror_pad_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MatMulPackedProgram {\n    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false) {\n        this.variableNames = ['matrixA', 'matrixB'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        const sharedDim = transposeA ? aShape[1] : aShape[2];\n        const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n        const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n        const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n        const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n        const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluActivation) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        let batchASnippet = 'rc.x';\n        let batchBSnippet = 'rc.x';\n        if (aShape[0] < bShape[0]) {\n            batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n        }\n        else if (bShape[0] < aShape[0]) {\n            batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mulmat_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MultinomialProgram {\n    constructor(batchSize, numOutcomes, numSamples) {\n        this.variableNames = ['probs'];\n        this.outputShape = [batchSize, numSamples];\n        this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${numOutcomes - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${numOutcomes - 1}));\n      }\n    `;\n    }\n    getCustomSetupFunc(seed) {\n        return (gpgpu, webGLProgram) => {\n            if (this.seedLoc == null) {\n                this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n            }\n            gpgpu.gl.uniform1f(this.seedLoc, seed);\n        };\n    }\n}\n//# sourceMappingURL=multinomial_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class OneHotProgram {\n    constructor(numIndices, depth, onValue, offValue) {\n        this.variableNames = ['indices'];\n        this.outputShape = [numIndices, depth];\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${offValue}), float(${onValue}),\n                      float(index == coords.y)));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=onehot_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PackProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        // Only input / output 3D tensors.\n        this.outputShape = outputShape;\n        const rank = outputShape.length;\n        if (rank === 0) {\n            this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n        }\n        else {\n            const channels = getChannels('rc', rank);\n            const dtype = getCoordsDataType(rank);\n            const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);\n            const setup = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);\n            const output = getOutput(outputShape, channels);\n            this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n        }\n    }\n}\nfunction getSourceCoordsArr(rank, dims) {\n    const coords = [];\n    for (let row = 0; row <= 1; row++) {\n        for (let col = 0; col <= 1; col++) {\n            let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n            for (let d = 2; d < rank; d++) {\n                coord = `${dims[dims.length - 1 - d]},` + coord;\n            }\n            coords.push(coord);\n        }\n    }\n    return coords;\n}\nfunction getOutOfBoundsCondition(rank, shape, dims) {\n    if (rank === 1) {\n        return `rc > ${shape[0]}`;\n    }\n    let cond = '';\n    for (let i = rank - 2; i < rank; i++) {\n        cond += `${dims[i]} >= ${shape[i]}`;\n        if (i < rank - 1) {\n            cond += '||';\n        }\n    }\n    return cond;\n}\nfunction getSetup(rank, cols, rows, dims) {\n    if (rank === 1) {\n        return '';\n    }\n    const innerDims = dims.slice(-2);\n    return `\n    int r = ${innerDims[0]};\n    int c = ${innerDims[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${cols};\n    bool rEdge = rp1 >= ${rows};\n  `;\n}\nfunction getOutput(shape, dims) {\n    const rank = shape.length;\n    const sourceCoords = getSourceCoordsArr(rank, dims);\n    if (rank === 1) {\n        return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n    }\n    return `getA(${sourceCoords[0]}),\n          cEdge ? 0. : getA(${sourceCoords[1]}),\n          rEdge ? 0. : getA(${sourceCoords[2]}),\n          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n}\n//# sourceMappingURL=pack_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport function getVecChannels(name, rank) {\n    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\nexport function getChannels(name, rank) {\n    if (rank === 1) {\n        return [name];\n    }\n    return getVecChannels(name, rank);\n}\nexport function getSourceCoords(rank, dims) {\n    if (rank === 1) {\n        return 'rc';\n    }\n    let coords = '';\n    for (let i = 0; i < rank; i++) {\n        coords += dims[i];\n        if (i < rank - 1) {\n            coords += ',';\n        }\n    }\n    return coords;\n}\n//# sourceMappingURL=packing_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const type = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        if (rank === 1) {\n            this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${constantValue}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n            return;\n        }\n        this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${constantValue}));\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=pad_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadPackedProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const componentSetup = [\n            `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n            rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n            rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n        ];\n        const paddingArea = rank === 1 ?\n            'rc < start || rc >= end' :\n            'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n        let mainLoop = '';\n        for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n            mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(${constantValue});\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        mainLoop += (rank === 1 ? `} ` : `}}`);\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=pad_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Pool2DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                flattenPositionStr) :\n                `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\nexport class Pool3DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${flattenPositions ?\n                (includeBatchInIndex ?\n                    `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` :\n                    `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n                `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=pool_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ReduceProgram {\n    constructor(reduceInfo, reduceType) {\n        this.variableNames = ['x'];\n        const { windowSize, batchSize, inSize, outSize } = reduceInfo;\n        this.outputShape = [batchSize, outSize];\n        let initializationValue = '0.0';\n        let compareOp = ``;\n        if (reduceType === 'prod') {\n            initializationValue = '1.0';\n        }\n        else if (reduceType === 'min') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '1.0 / 1e-20';\n            compareOp = `min`;\n        }\n        else if (reduceType === 'max') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n            compareOp = `max`;\n        }\n        let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (reduceType === 'sum') {\n            returnValue = `sumValue`;\n        }\n        else if (reduceType === 'prod') {\n            returnValue = `prodValue`;\n        }\n        else if (reduceType === 'all') {\n            returnValue = `allValue`;\n        }\n        else if (reduceType === 'any') {\n            returnValue = `anyValue`;\n        }\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        let vecType = `vec4`;\n        if (reduceType === 'all') {\n            initializationValue = '1.0';\n            updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        else if (reduceType === 'any') {\n            initializationValue = '0.0';\n            updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        let checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n        }\n        this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=reduce_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { registerKernel } from '@tensorflow/tfjs-core';\nimport { _fusedMatMulConfig } from './kernels/_FusedMatMul';\nimport { absConfig } from './kernels/Abs';\nimport { acosConfig } from './kernels/Acos';\nimport { acoshConfig } from './kernels/Acosh';\nimport { addConfig } from './kernels/Add';\nimport { addNConfig } from './kernels/AddN';\nimport { allConfig } from './kernels/All';\nimport { anyConfig } from './kernels/Any';\nimport { argMaxConfig } from './kernels/ArgMax';\nimport { argMinConfig } from './kernels/ArgMin';\nimport { asinConfig } from './kernels/Asin';\nimport { asinhConfig } from './kernels/Asinh';\nimport { atanConfig } from './kernels/Atan';\nimport { atan2Config } from './kernels/Atan2';\nimport { atanhConfig } from './kernels/Atanh';\nimport { avgPoolConfig } from './kernels/AvgPool';\nimport { avgPool3DConfig } from './kernels/AvgPool3D';\nimport { avgPoolGrad3DConfig } from './kernels/AvgPool3DGrad';\nimport { avgPoolGradConfig } from './kernels/AvgPoolGrad';\nimport { batchMatMulConfig } from './kernels/BatchMatMul';\nimport { batchNormConfig } from './kernels/BatchNorm';\nimport { batchToSpaceNDConfig } from './kernels/BatchToSpaceND';\nimport { bincountConfig } from './kernels/Bincount';\nimport { castConfig } from './kernels/Cast';\nimport { ceilConfig } from './kernels/Ceil';\nimport { clipByValueConfig } from './kernels/ClipByValue';\nimport { complexConfig } from './kernels/Complex';\nimport { complexAbsConfig } from './kernels/ComplexAbs';\nimport { concatConfig } from './kernels/Concat';\nimport { conv2DConfig } from './kernels/Conv2D';\nimport { conv2DBackpropFilterConfig } from './kernels/Conv2DBackpropFilter';\nimport { conv2DBackpropInputConfig } from './kernels/Conv2DBackpropInput';\nimport { conv3DConfig } from './kernels/Conv3D';\nimport { conv3DBackpropFilterV2Config } from './kernels/Conv3DBackpropFilterV2';\nimport { conv3DBackpropInputConfig } from './kernels/Conv3DBackpropInputV2';\nimport { cosConfig } from './kernels/Cos';\nimport { coshConfig } from './kernels/Cosh';\nimport { cropAndResizeConfig } from './kernels/CropAndResize';\nimport { cumsumConfig } from './kernels/Cumsum';\nimport { denseBincountConfig } from './kernels/DenseBincount';\nimport { depthToSpaceConfig } from './kernels/DepthToSpace';\nimport { depthwiseConv2dNativeConfig } from './kernels/DepthwiseConv2dNative';\nimport { depthwiseConv2dNativeBackpropFilterConfig } from './kernels/DepthwiseConv2dNativeBackpropFilter';\nimport { depthwiseConv2dNativeBackpropInputConfig } from './kernels/DepthwiseConv2dNativeBackpropInput';\nimport { diagConfig } from './kernels/Diag';\nimport { dilation2DConfig } from './kernels/Dilation2D';\nimport { eluConfig } from './kernels/Elu';\nimport { eluGradConfig } from './kernels/EluGrad';\nimport { equalConfig } from './kernels/Equal';\nimport { erfConfig } from './kernels/Erf';\nimport { expConfig } from './kernels/Exp';\nimport { expandDimsConfig } from './kernels/ExpandDims';\nimport { expm1Config } from './kernels/Expm1';\nimport { fftConfig } from './kernels/FFT';\nimport { fillConfig } from './kernels/Fill';\nimport { flipLeftRightConfig } from './kernels/FlipLeftRight';\nimport { floorConfig } from './kernels/Floor';\nimport { floorDivConfig } from './kernels/FloorDiv';\nimport { fromPixelsConfig } from './kernels/FromPixels';\nimport { fusedConv2DConfig } from './kernels/FusedConv2D';\nimport { fusedDepthwiseConv2DConfig } from './kernels/FusedDepthwiseConv2D';\nimport { gatherNdConfig } from './kernels/GatherNd';\nimport { gatherV2Config } from './kernels/GatherV2';\nimport { greaterConfig } from './kernels/Greater';\nimport { greaterEqualConfig } from './kernels/GreaterEqual';\nimport { identityConfig } from './kernels/Identity';\nimport { ifftConfig } from './kernels/IFFT';\nimport { imagConfig } from './kernels/Imag';\nimport { isFiniteConfig } from './kernels/IsFinite';\nimport { isInfConfig } from './kernels/IsInf';\nimport { isNaNConfig } from './kernels/IsNaN';\nimport { leakyReluConfig } from './kernels/LeakyRelu';\nimport { lessConfig } from './kernels/Less';\nimport { lessEqualConfig } from './kernels/LessEqual';\nimport { linSpaceConfig } from './kernels/LinSpace';\nimport { logConfig } from './kernels/Log';\nimport { log1pConfig } from './kernels/Log1p';\nimport { logicalAndConfig } from './kernels/LogicalAnd';\nimport { logicalNotConfig } from './kernels/LogicalNot';\nimport { logicalOrConfig } from './kernels/LogicalOr';\nimport { LRNConfig } from './kernels/LRN';\nimport { LRNGradConfig } from './kernels/LRNGrad';\nimport { maxConfig } from './kernels/Max';\nimport { maximumConfig } from './kernels/Maximum';\nimport { maxPoolConfig } from './kernels/MaxPool';\nimport { maxPool3DConfig } from './kernels/MaxPool3D';\nimport { maxPoolGrad3DConfig } from './kernels/MaxPool3DGrad';\nimport { maxPoolGradConfig } from './kernels/MaxPoolGrad';\nimport { maxPoolWithArgmaxConfig } from './kernels/MaxPoolWithArgmax';\nimport { meanConfig } from './kernels/Mean';\nimport { minConfig } from './kernels/Min';\nimport { minimumConfig } from './kernels/Minimum';\nimport { mirrorPadConfig } from './kernels/MirrorPad';\nimport { modConfig } from './kernels/Mod';\nimport { multinomialConfig } from './kernels/Multinomial';\nimport { multiplyConfig } from './kernels/Multiply';\nimport { negConfig } from './kernels/Neg';\nimport { nonMaxSuppressionV3Config } from './kernels/NonMaxSuppressionV3';\nimport { nonMaxSuppressionV4Config } from './kernels/NonMaxSuppressionV4';\nimport { nonMaxSuppressionV5Config } from './kernels/NonMaxSuppressionV5';\nimport { notEqualConfig } from './kernels/NotEqual';\nimport { oneHotConfig } from './kernels/OneHot';\nimport { onesLikeConfig } from './kernels/OnesLike';\nimport { packConfig } from './kernels/Pack';\nimport { padV2Config } from './kernels/PadV2';\nimport { powConfig } from './kernels/Pow';\nimport { preluConfig } from './kernels/Prelu';\nimport { prodConfig } from './kernels/Prod';\nimport { rangeConfig } from './kernels/Range';\nimport { realConfig } from './kernels/Real';\nimport { realDivConfig } from './kernels/RealDiv';\nimport { reciprocalConfig } from './kernels/Reciprocal';\nimport { reluConfig } from './kernels/Relu';\nimport { relu6Config } from './kernels/Relu6';\nimport { reshapeConfig } from './kernels/Reshape';\nimport { resizeBilinearConfig } from './kernels/ResizeBilinear';\nimport { resizeBilinearGradConfig } from './kernels/ResizeBilinearGrad';\nimport { resizeNearestNeighborConfig } from './kernels/ResizeNearestNeighbor';\nimport { resizeNearestNeighborGradConfig } from './kernels/ResizeNearestNeighborGrad';\nimport { reverseConfig } from './kernels/Reverse';\nimport { rotateWithOffsetConfig } from './kernels/RotateWithOffset';\nimport { roundConfig } from './kernels/Round';\nimport { rsqrtConfig } from './kernels/Rsqrt';\nimport { scatterNdConfig } from './kernels/ScatterNd';\nimport { selectConfig } from './kernels/Select';\nimport { seluConfig } from './kernels/Selu';\nimport { sigmoidConfig } from './kernels/Sigmoid';\nimport { signConfig } from './kernels/Sign';\nimport { sinConfig } from './kernels/Sin';\nimport { sinhConfig } from './kernels/Sinh';\nimport { sliceConfig } from './kernels/Slice';\nimport { softmaxConfig } from './kernels/Softmax';\nimport { softplusConfig } from './kernels/Softplus';\nimport { spaceToBatchNDConfig } from './kernels/SpaceToBatchND';\nimport { sparseToDenseConfig } from './kernels/SparseToDense';\nimport { splitVConfig } from './kernels/SplitV';\nimport { sqrtConfig } from './kernels/Sqrt';\nimport { squareConfig } from './kernels/Square';\nimport { squaredDifferenceConfig } from './kernels/SquaredDifference';\nimport { stepConfig } from './kernels/Step';\nimport { stridedSliceConfig } from './kernels/StridedSlice';\nimport { subConfig } from './kernels/Sub';\nimport { sumConfig } from './kernels/Sum';\nimport { tanConfig } from './kernels/Tan';\nimport { tanhConfig } from './kernels/Tanh';\nimport { tileConfig } from './kernels/Tile';\nimport { topKConfig } from './kernels/TopK';\nimport { transposeConfig } from './kernels/Transpose';\nimport { uniqueConfig } from './kernels/Unique';\nimport { unpackConfig } from './kernels/Unpack';\nimport { unsortedSegmentSumConfig } from './kernels/UnsortedSegmentSum';\nimport { zerosLikeConfig } from './kernels/ZerosLike';\n// List all kernel configs here\nconst kernelConfigs = [\n    LRNConfig,\n    LRNGradConfig,\n    _fusedMatMulConfig,\n    absConfig,\n    acosConfig,\n    acoshConfig,\n    addConfig,\n    addNConfig,\n    allConfig,\n    anyConfig,\n    argMaxConfig,\n    argMinConfig,\n    asinConfig,\n    asinhConfig,\n    atan2Config,\n    atanConfig,\n    atanhConfig,\n    avgPool3DConfig,\n    avgPoolConfig,\n    avgPoolGrad3DConfig,\n    avgPoolGradConfig,\n    batchMatMulConfig,\n    batchNormConfig,\n    batchToSpaceNDConfig,\n    bincountConfig,\n    castConfig,\n    ceilConfig,\n    clipByValueConfig,\n    complexAbsConfig,\n    complexConfig,\n    concatConfig,\n    conv2DBackpropFilterConfig,\n    conv2DBackpropInputConfig,\n    conv2DConfig,\n    conv3DBackpropFilterV2Config,\n    conv3DBackpropInputConfig,\n    conv3DConfig,\n    cosConfig,\n    coshConfig,\n    cropAndResizeConfig,\n    cumsumConfig,\n    denseBincountConfig,\n    depthToSpaceConfig,\n    depthwiseConv2dNativeBackpropFilterConfig,\n    depthwiseConv2dNativeBackpropInputConfig,\n    depthwiseConv2dNativeConfig,\n    diagConfig,\n    dilation2DConfig,\n    eluConfig,\n    eluGradConfig,\n    equalConfig,\n    erfConfig,\n    expConfig,\n    expandDimsConfig,\n    expm1Config,\n    fftConfig,\n    fillConfig,\n    flipLeftRightConfig,\n    floorConfig,\n    floorDivConfig,\n    fromPixelsConfig,\n    fusedConv2DConfig,\n    fusedDepthwiseConv2DConfig,\n    gatherNdConfig,\n    gatherV2Config,\n    greaterConfig,\n    greaterEqualConfig,\n    identityConfig,\n    ifftConfig,\n    imagConfig,\n    isFiniteConfig,\n    isInfConfig,\n    isNaNConfig,\n    leakyReluConfig,\n    lessConfig,\n    lessEqualConfig,\n    linSpaceConfig,\n    log1pConfig,\n    logConfig,\n    logicalAndConfig,\n    logicalNotConfig,\n    logicalOrConfig,\n    maxConfig,\n    maxPool3DConfig,\n    maxPoolConfig,\n    maxPoolGrad3DConfig,\n    maxPoolGradConfig,\n    maxPoolWithArgmaxConfig,\n    maximumConfig,\n    meanConfig,\n    minConfig,\n    minimumConfig,\n    mirrorPadConfig,\n    modConfig,\n    multinomialConfig,\n    multiplyConfig,\n    negConfig,\n    nonMaxSuppressionV3Config,\n    nonMaxSuppressionV4Config,\n    nonMaxSuppressionV5Config,\n    notEqualConfig,\n    oneHotConfig,\n    onesLikeConfig,\n    packConfig,\n    padV2Config,\n    powConfig,\n    preluConfig,\n    prodConfig,\n    rangeConfig,\n    realConfig,\n    realDivConfig,\n    reciprocalConfig,\n    relu6Config,\n    reluConfig,\n    reshapeConfig,\n    resizeBilinearConfig,\n    resizeBilinearGradConfig,\n    resizeNearestNeighborConfig,\n    resizeNearestNeighborGradConfig,\n    reverseConfig,\n    rotateWithOffsetConfig,\n    roundConfig,\n    rsqrtConfig,\n    scatterNdConfig,\n    selectConfig,\n    seluConfig,\n    sigmoidConfig,\n    signConfig,\n    sinConfig,\n    sinhConfig,\n    sliceConfig,\n    softmaxConfig,\n    softplusConfig,\n    spaceToBatchNDConfig,\n    sparseToDenseConfig,\n    splitVConfig,\n    sqrtConfig,\n    squareConfig,\n    squaredDifferenceConfig,\n    stepConfig,\n    stridedSliceConfig,\n    subConfig,\n    sumConfig,\n    tanConfig,\n    tanhConfig,\n    tileConfig,\n    topKConfig,\n    transposeConfig,\n    uniqueConfig,\n    unpackConfig,\n    unsortedSegmentSumConfig,\n    zerosLikeConfig\n];\nfor (const kernelConfig of kernelConfigs) {\n    registerKernel(kernelConfig);\n}\n//# sourceMappingURL=register_all_kernels.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as shader_util from './shader_compiler_util';\nexport class ReshapePackedProgram {\n    constructor(outputShape, inputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        let mainLoop = ``;\n        for (let i = 0; i < 4; i++) {\n            let thisRC = `thisRC = rc;`;\n            if (i % 2 === 1) {\n                thisRC += `thisRC.z += 1;`;\n            }\n            if (i > 1) {\n                thisRC += `thisRC.y += 1;`;\n            }\n            mainLoop += `\n        ${thisRC}\n        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i > 0 ? '}' : ''}\n      `;\n        }\n        this.userCode = `\n      ${getReshapedInputCoords(inputShape)}\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${outputShape[1]};\n        int cols = ${outputShape[2]};\n\n        ${mainLoop}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\nfunction getReshapedInputCoords(shape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n//# sourceMappingURL=reshape_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearBackpropProgram {\n    constructor(dyShape, inputShape, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        const [, xHeight, xWidth,] = inputShape;\n        const [, yHeight, yWidth] = dyShape;\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_backprop_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        let sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC =\n                `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n                    ` - vec2(0.5)`;\n        }\n        else {\n            sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n        }\n        this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearPackedProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        let sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * ` +\n                `effectiveInputOverOutputRatioRC - vec3(0.5)`;\n        }\n        else {\n            sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;\n        }\n        this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeNearestNeigborBackpropProgram {\n    constructor(dyShape, inputShape, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        const [, xHeight, xWidth,] = inputShape;\n        const [, yHeight, yWidth] = dyShape;\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${effectiveXSize[0]}) *\n                (float(dyR) / float(${effectiveYSize[0]}));\n\n            float sourceFracCol =\n                float(${effectiveXSize[1]}) *\n                  (float(dyC) / float(${effectiveYSize[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${xHeight}) - 1),\n                ${alignCorners} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${xWidth}) - 1),\n                ${alignCorners} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_nearest_neighbor_backprop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeNearestNeighborProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        // When align corners is false, we rounds the value with floor.\n        const roundBase = alignCorners ? '0.5' : '0.0';\n        let sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC =\n                `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n                    `, vec2(0.0))`;\n        }\n        else {\n            sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n        }\n        this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_nearest_neighbor_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReverseProgram {\n    constructor(xShape, axis) {\n        this.variableNames = ['x'];\n        const rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n        }\n        this.outputShape = xShape;\n        if (rank === 1) {\n            this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${xShape[0]} - coord - 1));\n        }\n      `;\n            return;\n        }\n        const getInCoord = (i) => {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return `${xShape[i]} - coords[${i}] - 1`;\n            }\n            return `coords[${i}]`;\n        };\n        const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');\n        const type = getCoordsDataType(rank);\n        this.userCode = `\n      void main() {\n        ${type} coords = getOutputCoords();\n        setOutput(getX(${inCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=reverse_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReversePackedProgram {\n    constructor(xShape, axis) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n        }\n        this.outputShape = xShape;\n        const channels = getChannels('rc', rank);\n        const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n        const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n        const type = getCoordsDataType(rank);\n        if (rank === 1) {\n            this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n        }\n        else {\n            this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n        }\n        function getR(channels) {\n            return getChannel(channels);\n        }\n        function getG(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getB(channels) {\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getA(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getChannel(channels) {\n            const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n            const inCoords = inCoordsArray.join(',');\n            const innerDims = inCoordsArray.slice(-2).join(',');\n            return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n        }\n        function getInCoord(i, channels1) {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return `${xShape[i]} - ${channels1[i]} - 1`;\n            }\n            else {\n                return `${channels1[i]}`;\n            }\n        }\n    }\n}\n//# sourceMappingURL=reverse_packed_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class RotateProgram {\n    constructor(imageShape, radians, fillValue, center) {\n        this.variableNames = ['Image'];\n        this.outputShape = [];\n        const imageHeight = imageShape[1];\n        const imageWidth = imageShape[2];\n        const sinFactor = Math.sin(radians).toFixed(3);\n        const cosFactor = Math.cos(radians).toFixed(3);\n        this.outputShape = imageShape;\n        const [centerX, centerY] = backend_util.getImageCenter(center, imageHeight, imageWidth);\n        const centerXString = centerX.toFixed(3);\n        const centerYString = centerY.toFixed(3);\n        let fillSnippet = '';\n        if (typeof fillValue === 'number') {\n            fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;\n        }\n        else {\n            fillSnippet = `\n        vec3 fill = vec3(${fillValue.join(',')});\n        float outputValue = fill[coords[3]];`;\n        }\n        this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${centerXString}) * ${cosFactor} - (float(y) - ${centerYString}) * ${sinFactor};\n          float coordYFloat = (float(x) - ${centerXString}) * ${sinFactor} + (float(y) - ${centerYString}) * ${cosFactor};\n          int coordX = int(round(coordXFloat + ${centerXString}));\n          int coordY = int(round(coordYFloat + ${centerYString}));\n          ${fillSnippet}\n          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n    }\n}\n//# sourceMappingURL=rotate_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class ScatterProgram {\n    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {\n        this.variableNames = ['updates', 'indices', 'defaultValue'];\n        this.outputShape = shape;\n        const stridesType = getCoordsDataType(strides.length);\n        const dtype = getCoordsDataType(shape.length);\n        let indicesString = '';\n        if (indicesRank === 1) {\n            indicesString = 'i';\n        }\n        else if (indicesRank === 2) {\n            indicesString = 'i, j';\n        }\n        const indicesSnippet = `getIndices(${indicesString})`;\n        let updatesString = '';\n        if (updatesRank === 1) {\n            updatesString = 'i';\n        }\n        else if (updatesRank === 2) {\n            updatesString = 'i, coords[1]';\n        }\n        const updatesSnippet = `getUpdates(${updatesString})`;\n        const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = `\n        ${stridesType} strides = ${stridesType}(${strides});\n\n        void main() {\n          ${dtype} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${updateSize}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${sliceDim}; j++) {\n              int index = round(${indicesSnippet});\n              flattenedIndex += index * ${strideString};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${updatesSnippet};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;\n    }\n}\n//# sourceMappingURL=scatter_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class SegmentOpProgram {\n    constructor(segOpInfo, segOpType) {\n        this.variableNames = ['x', 'segmentIds'];\n        const windowSize = segOpInfo.windowSize;\n        const batchSize = segOpInfo.batchSize;\n        const inSize = segOpInfo.inSize;\n        const numSegments = segOpInfo.numSegments;\n        const outSize = numSegments * Math.ceil(inSize / windowSize);\n        this.outputShape = [batchSize, outSize];\n        const initializationValue = '0.0';\n        const returnValue = `sumValue`;\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n        let checkValueOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n        }\n        let checkSegmentIdOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n        }\n        this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=segment_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SelectProgram {\n    constructor(cRank, shape, rank) {\n        this.variableNames = ['c', 'a', 'b'];\n        this.outputShape = shape;\n        let cCoords;\n        let abCoords;\n        if (rank > 4) {\n            throw Error(`Where for rank ${rank} is not yet supported`);\n        }\n        if (rank === 1) {\n            abCoords = `resRC`;\n            cCoords = `resRC`;\n        }\n        else {\n            const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n            const cCoordVars = [];\n            const abCoordVars = [];\n            for (let i = 0; i < shape.length; i++) {\n                abCoordVars.push(`${currentCoords[i]}`);\n                if (i < cRank) {\n                    cCoordVars.push(`${currentCoords[i]}`);\n                }\n            }\n            cCoords = cCoordVars.join();\n            abCoords = abCoordVars.join();\n        }\n        const dtype = getCoordsDataType(rank);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        float cVal = getC(${cCoords});\n        if (cVal >= 1.0) {\n          setOutput(getA(${abCoords}));\n        } else {\n          setOutput(getB(${abCoords}));\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=select_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nconst { getBroadcastDims } = backend_util;\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nexport function makeShader(inputsInfo, outputShape, userCode, usesPackedTextures) {\n    const prefixSnippets = [];\n    inputsInfo.forEach(x => {\n        const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n        // Snippet when we decided to upload the values as uniform.\n        if (x.shapeInfo.isUniform) {\n            prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);\n        }\n        else {\n            prefixSnippets.push(`uniform sampler2D ${x.name};`);\n            prefixSnippets.push(`uniform int offset${x.name};`);\n        }\n    });\n    const inputPrefixSnippet = prefixSnippets.join('\\n');\n    const inputSamplingSnippet = inputsInfo\n        .map(x => getInputSamplingSnippet(x, outputShape, usesPackedTextures))\n        .join('\\n');\n    const outTexShape = outputShape.texShape;\n    const glsl = getGlslDifferences();\n    const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n    let outputSamplingSnippet;\n    let floatTextureSetOutputSnippet;\n    let shaderPrefix = getShaderPrefix(glsl);\n    if (outputShape.isPacked) {\n        outputSamplingSnippet =\n            getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n    }\n    else {\n        outputSamplingSnippet =\n            getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n    }\n    if (usesPackedTextures) {\n        shaderPrefix += SHADER_PACKED_PREFIX;\n    }\n    const source = [\n        shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n        inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode\n    ].join('\\n');\n    return source;\n}\nfunction getSamplerFromInInfo(inInfo) {\n    const shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getSamplerScalar(inInfo);\n        case 1:\n            return getSampler1D(inInfo);\n        case 2:\n            return getSampler2D(inInfo);\n        case 3:\n            return getSampler3D(inInfo);\n        case 4:\n            return getSampler4D(inInfo);\n        case 5:\n            return getSampler5D(inInfo);\n        case 6:\n            return getSampler6D(inInfo);\n        default:\n            throw new Error(`${shape.length}-D input sampling` +\n                ` is not yet supported`);\n    }\n}\nfunction getPackedSamplerFromInInfo(inInfo) {\n    const shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getPackedSamplerScalar(inInfo);\n        case 1:\n            return getPackedSampler1D(inInfo);\n        case 2:\n            return getPackedSampler2D(inInfo);\n        case 3:\n            return getPackedSampler3D(inInfo);\n        default:\n            return getPackedSamplerND(inInfo);\n    }\n}\nfunction getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false) {\n    let res = '';\n    if (usesPackedTextures) {\n        res += getPackedSamplerFromInInfo(inInfo);\n    }\n    else {\n        res += getSamplerFromInInfo(inInfo);\n    }\n    const inShape = inInfo.shapeInfo.logicalShape;\n    const outShape = outShapeInfo.logicalShape;\n    if (inShape.length <= outShape.length) {\n        if (usesPackedTextures) {\n            res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n        else {\n            res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n    }\n    return res;\n}\nfunction getPackedOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutputPacked1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutputPacked2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutputPacked3DCoords(outShape, outTexShape);\n        default:\n            return getOutputPackedNDCoords(outShape, outTexShape);\n    }\n}\nfunction getOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutput1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutput2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutput3DCoords(outShape, outTexShape);\n        case 4:\n            return getOutput4DCoords(outShape, outTexShape);\n        case 5:\n            return getOutput5DCoords(outShape, outTexShape);\n        case 6:\n            return getOutput6DCoords(outShape, outTexShape);\n        default:\n            throw new Error(`${outShape.length}-D output sampling is not yet supported`);\n    }\n}\nfunction getFloatTextureSampleSnippet(glsl) {\n    return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${glsl.texture2D}(textureSampler, uv).r;\n    }\n  `;\n}\nfunction getFloatTextureSetRSnippet(glsl) {\n    return `\n    void setOutput(float val) {\n      ${glsl.output} = vec4(val, 0, 0, 0);\n    }\n  `;\n}\nfunction getFloatTextureSetRGBASnippet(glsl) {\n    return `\n    void setOutput(vec4 val) {\n      ${glsl.output} = val;\n    }\n  `;\n}\nfunction getShaderPrefix(glsl) {\n    const SHADER_PREFIX = `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFs} vec2 resultUV;\n    ${glsl.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${glsl.defineSpecialNaN}\n    ${glsl.defineSpecialInf}\n    ${glsl.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;\n    return SHADER_PREFIX;\n}\nconst SAMPLE_1D_SNIPPET = `\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SAMPLE_2D_SNIPPET = `\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SAMPLE_3D_SNIPPET = `\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SHADER_PACKED_PREFIX = `\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;\nfunction getOutputScalarCoords() {\n    return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\nfunction getOutputPacked1DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (packedTexShape[0] === 1) {\n        return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);\n      }\n    `;\n    }\n    if (packedTexShape[1] === 1) {\n        return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);\n      }\n    `;\n    }\n    return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);\n    }\n  `;\n}\nfunction getOutput1DCoords(shape, texShape) {\n    if (texShape[0] === 1) {\n        return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n    }\n    if (texShape[1] === 1) {\n        return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n    }\n    return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\nfunction getOutputPacked3DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n}\nfunction getOutput3DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\nfunction getOutputPackedNDCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    let texelsInBatchN = texelsInBatch;\n    let batches = ``;\n    let coords = 'b, r, c';\n    for (let b = 2; b < shape.length - 1; b++) {\n        texelsInBatchN *= shape[shape.length - b - 1];\n        batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n        coords = `b${b}, ` + coords;\n    }\n    return `\n    ivec${shape.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      ${batches}\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec${shape.length}(${coords});\n    }\n  `;\n}\nfunction getOutput4DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2'], shape);\n    return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\nfunction getOutput5DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3'], shape);\n    return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\nfunction getOutput6DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n    return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `;\n}\nfunction getOutputPacked2DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (util.arraysEqual(shape, texShape)) {\n        return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      }\n    `;\n    }\n    // texels needed to accommodate a logical row\n    const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n}\nfunction getOutput2DCoords(shape, texShape) {\n    if (util.arraysEqual(shape, texShape)) {\n        return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n    }\n    if (shape[1] === 1) {\n        return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n    }\n    if (shape[0] === 1) {\n        return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n    }\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\nfunction getFlatOffsetUniformName(texName) {\n    return `offset${texName}`;\n}\nfunction getPackedSamplerScalar(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}() {\n      return ${glsl.texture2D}(${texName}, halfCR);\n    }\n  `;\n}\nfunction getSamplerScalar(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        return `float ${funcName}() {return ${texName};}`;\n    }\n    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;\n    if (texNumR === 1 && texNumC === 1) {\n        return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n    }\n    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getPackedSampler1D(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler1D(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int index) {\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texShape = inputInfo.shapeInfo.texShape;\n    const tNumR = texShape[0];\n    const tNumC = texShape[1];\n    if (tNumC === 1 && tNumR === 1) {\n        return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    if (tNumC === 1) {\n        return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (tNumR === 1) {\n        return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getPackedSampler2D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const glsl = getGlslDifferences();\n    if (texShape != null && util.arraysEqual(shape, texShape)) {\n        return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n    }\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const valuesPerRow = Math.ceil(shape[1] / 2);\n    return `\n    vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler2D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    if (texShape != null && util.arraysEqual(shape, texShape)) {\n        const texNumR = texShape[0];\n        const texNumC = texShape[1];\n        return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['row', 'col'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const offset = getFlatOffsetUniformName(texName);\n    if (texNumC === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    if (texNumR === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    return `\n  float ${funcName}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${shape[1]} + col + ${offset};\n    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\nfunction getPackedSampler3D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (shape[0] === 1) {\n        const squeezedShape = shape.slice(1);\n        const keptDims = [1, 2];\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['b', 'row', 'col'];\n        return `\n        ${getPackedSamplerFromInInfo(newInputInfo)}\n        vec4 ${funcName}(int b, int row, int col) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n    }\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n    const valuesPerRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler3D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride0 = shape[1] * shape[2];\n    const stride1 = shape[2];\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['row', 'col', 'depth'];\n        return `\n        ${getSamplerFromInInfo(newInputInfo)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${stride0}, ${stride1}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n        float ${funcName}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n    }\n    if (texNumC === stride1 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};\n        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\nfunction getPackedSamplerND(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const rank = shape.length;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    let params = `int b, int row, int col`;\n    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n    for (let b = 2; b < rank - 1; b++) {\n        params = `int b${b}, ` + params;\n        texelsInBatch *= shape[rank - b - 1];\n        index = `b${b} * ${texelsInBatch} + ` + index;\n    }\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler4D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride2 = shape[3];\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${stride1}, ${stride2}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride2 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} +\n          depth * ${stride2} + depth2;\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler5D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride3 = shape[4];\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          depth3;\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${stride1}, ${stride2}, ${stride3}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride3 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3]},\n               ${shape[2] * shape[3]}, ${shape[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler6D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    const stride4 = shape[5];\n    const stride3 = shape[4] * stride4;\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${stride4}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride4 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},\n               ${shape[2] * shape[3] * shape[4]},\n               ${shape[3] * shape[4]},\n               ${shape[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getUniformSampler(inputInfo) {\n    const texName = inputInfo.name;\n    const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    if (inSize < 2) {\n        return `return ${texName};`;\n    }\n    return `\n    for (int i = 0; i < ${inSize}; i++) {\n      if (i == index) {\n        return ${texName}[i];\n      }\n    }\n  `;\n}\nfunction getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    const texName = inputInfo.name;\n    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    const inRank = inputInfo.shapeInfo.logicalShape.length;\n    const outRank = outShapeInfo.logicalShape.length;\n    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    const type = getCoordsDataType(outRank);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet;\n    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n                .join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map((s, i) => `coords.${fields[i + rankDiff]}`)\n            .join(', ');\n    }\n    let output = `return outputValue;`;\n    const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    const isInputScalar = inSize === 1;\n    const outSize = util.sizeFromShape(outShapeInfo.logicalShape);\n    const isOutputScalar = outSize === 1;\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n        output = `\n      return vec4(outputValue.xy, outputValue.xy);\n    `;\n    }\n    else if (isInputScalar && !isOutputScalar) {\n        if (outRank === 1) {\n            output = `\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;\n        }\n        else {\n            output = `\n        return vec4(outputValue.x);\n      `;\n        }\n    }\n    else if (broadcastDims.length) {\n        const rows = inRank - 2;\n        const cols = inRank - 1;\n        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n            output = `return vec4(outputValue.x);`;\n        }\n        else if (broadcastDims.indexOf(rows) > -1) {\n            output = `return vec4(outputValue.x, outputValue.y, ` +\n                `outputValue.x, outputValue.y);`;\n        }\n        else if (broadcastDims.indexOf(cols) > -1) {\n            output = `return vec4(outputValue.xx, outputValue.zz);`;\n        }\n    }\n    return `\n    vec4 ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});\n      ${output}\n    }\n  `;\n}\nfunction getSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    const texName = inputInfo.name;\n    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    const outTexShape = outShapeInfo.texShape;\n    const inTexShape = inputInfo.shapeInfo.texShape;\n    const inRank = inputInfo.shapeInfo.logicalShape.length;\n    const outRank = outShapeInfo.logicalShape.length;\n    if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n        inputInfo.shapeInfo.flatOffset == null &&\n        util.arraysEqual(inTexShape, outTexShape)) {\n        return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n    }\n    const type = getCoordsDataType(outRank);\n    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet;\n    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n                .join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map((s, i) => `coords.${fields[i + rankDiff]}`)\n            .join(', ');\n    }\n    return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\nexport function getCoordsDataType(rank) {\n    if (rank <= 1) {\n        return 'int';\n    }\n    else if (rank === 2) {\n        return 'ivec2';\n    }\n    else if (rank === 3) {\n        return 'ivec3';\n    }\n    else if (rank === 4) {\n        return 'ivec4';\n    }\n    else if (rank === 5) {\n        return 'ivec5';\n    }\n    else if (rank === 6) {\n        return 'ivec6';\n    }\n    else {\n        throw Error(`GPU for rank ${rank} is not yet supported`);\n    }\n}\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(inInfo, squeezedShape) {\n    // Deep copy.\n    const newInputInfo = JSON.parse(JSON.stringify(inInfo));\n    newInputInfo.shapeInfo.logicalShape = squeezedShape;\n    return newInputInfo;\n}\nfunction getSqueezedParams(params, keptDims) {\n    return keptDims.map(d => params[d]).join(', ');\n}\n//# sourceMappingURL=shader_compiler.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {\n    const strides = util.computeStrides(shape);\n    return strides\n        .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n    })\n        .join('');\n}\nfunction buildVec(x) {\n    if (x.length === 1) {\n        return `${x[0]}`;\n    }\n    return `vec${x.length}(${x.join(',')})`;\n}\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(`Vectors to be dotted must be of the same length -` +\n            `got ${x.length} and ${y.length}`);\n    }\n    const slices = [];\n    const nearestVec4 = Math.floor(x.length / 4);\n    const nearestVec4Remainder = x.length % 4;\n    for (let i = 0; i < nearestVec4; i++) {\n        const xSlice = x.slice(i * 4, i * 4 + 4);\n        const ySlice = y.slice(i * 4, i * 4 + 4);\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    if (nearestVec4Remainder !== 0) {\n        let xSlice = x.slice(nearestVec4 * 4);\n        let ySlice = y.slice(nearestVec4 * 4);\n        if (xSlice.length === 1) {\n            xSlice = xSlice.map(d => `float(${d})`);\n            ySlice = ySlice.map(d => `float(${d})`);\n        }\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    return slices.map((d, i) => `dot(${d})`).join('+');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape) {\n    const strides = util.computeStrides(shape).map(d => d.toString());\n    return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n//# sourceMappingURL=shader_compiler_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SliceProgram {\n    constructor(destSize) {\n        this.variableNames = ['source'];\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        const dtype = getCoordsDataType(this.rank);\n        const uniformPart = `uniform int start[${this.rank}];`;\n        const sourceCoords = getCoords(this.rank);\n        let body;\n        const coordSum = destSize.map((_, i) => {\n            return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n        });\n        body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n        this.userCode = `\n      ${uniformPart}\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n    }\n    getCustomSetupFunc(start) {\n        if (start.length !== this.rank) {\n            throw Error(`The rank (${this.rank}) of the program must match the ` +\n                `length of start (${start.length})`);\n        }\n        return (gpgpu, webGLProgram) => {\n            if (this.startLoc == null) {\n                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(this.startLoc, start);\n        };\n    }\n}\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\nfunction getCoords(rank) {\n    if (rank === 1) {\n        return 'sourceLoc';\n    }\n    else if (rank <= 6) {\n        return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n    }\n    else {\n        throw Error(`Slicing for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=slice_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class SlicePackedProgram {\n    constructor(destSize) {\n        this.variableNames = ['source'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        const dtype = getCoordsDataType(this.rank);\n        const coords = getChannels('coords', this.rank);\n        const sourceLoc = getChannels('sourceLoc', this.rank);\n        const innerDims = this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;\n        const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;\n        const upperRow = `\n      result.x = ${getChannel};\n      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n        ++${sourceLoc[this.rank - 1]};\n        result.y = ${getChannel};\n        --${sourceLoc[this.rank - 1]};\n      }\n    `;\n        const lowerRow = this.rank === 1 ? '' : `\n      --${coords[this.rank - 1]};\n      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {\n        ++${sourceLoc[this.rank - 2]};\n        result.z = ${getChannel};\n        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n          ++${sourceLoc[this.rank - 1]};\n          result.w = ${getChannel};\n        }\n      }\n    `;\n        const sourceLocSetup = this.rank <= 4 ?\n            `sourceLoc = coords +\n            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :\n            destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)\n                .join('\\n');\n        this.userCode = `\n      uniform int start[${this.rank}];\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        ${dtype} sourceLoc;\n        ${sourceLocSetup}\n        vec4 result = vec4(0.);\n        ${upperRow}\n        ${lowerRow}\n        setOutput(result);\n      }\n    `;\n    }\n    getCustomSetupFunc(start) {\n        if (start.length !== this.rank) {\n            throw Error(`The rank (${this.rank}) of the program must match the ` +\n                `length of start (${start.length})`);\n        }\n        return (gpgpu, webGLProgram) => {\n            if (this.startLoc == null) {\n                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(this.startLoc, start);\n        };\n    }\n}\n//# sourceMappingURL=slice_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class StridedSliceProgram {\n    constructor(begin, strides, size) {\n        this.variableNames = ['x'];\n        this.outputShape = size;\n        const rank = size.length;\n        const inputDtype = getCoordsDataType(size.length);\n        const dtype = getCoordsDataType(size.length);\n        let newCoords = '';\n        if (rank === 1) {\n            newCoords = 'coords * strides + begin';\n        }\n        else {\n            let outputAxis = 0;\n            newCoords =\n                size.map((_, i) => {\n                    outputAxis++;\n                    return size.length === 1 ?\n                        `coords * strides[${i}] + begin[${i}]` :\n                        `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n                })\n                    .join(',');\n        }\n        this.userCode = `\n      ${inputDtype} begin = ${inputDtype}(${begin});\n      ${inputDtype} strides = ${inputDtype}(${strides});\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        setOutput(getX(${newCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=strided_slice_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nexport var PackingScheme;\n(function (PackingScheme) {\n    /**\n     * All values in a single texel are densely packed without any constraints.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 4]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   010|011   020|021\n     * -------   -------   -------\n     * 002|003   012|013   022|023\n     *\n     * 100|101   110|111   120|121\n     * -------   -------   -------\n     * 102|103   112|113   122|123\n     *\n     */\n    PackingScheme[PackingScheme[\"DENSE\"] = 0] = \"DENSE\";\n    /**\n     * Single texels contain only values from the same batch, and from adjacent\n     * rows and columns.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 5]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     */\n    PackingScheme[PackingScheme[\"SHARED_BATCH\"] = 1] = \"SHARED_BATCH\";\n})(PackingScheme || (PackingScheme = {}));\nexport var TextureUsage;\n(function (TextureUsage) {\n    TextureUsage[TextureUsage[\"RENDER\"] = 0] = \"RENDER\";\n    TextureUsage[TextureUsage[\"UPLOAD\"] = 1] = \"UPLOAD\";\n    TextureUsage[TextureUsage[\"PIXELS\"] = 2] = \"PIXELS\";\n    TextureUsage[TextureUsage[\"DOWNLOAD\"] = 3] = \"DOWNLOAD\";\n})(TextureUsage || (TextureUsage = {}));\nexport var PhysicalTextureType;\n(function (PhysicalTextureType) {\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT16\"] = 0] = \"UNPACKED_FLOAT16\";\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT32\"] = 1] = \"UNPACKED_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_4X1_UNSIGNED_BYTE\"] = 2] = \"PACKED_4X1_UNSIGNED_BYTE\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT32\"] = 3] = \"PACKED_2X2_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT16\"] = 4] = \"PACKED_2X2_FLOAT16\";\n})(PhysicalTextureType || (PhysicalTextureType = {}));\nexport function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns, rows];\n}\nexport function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {\n    return matrixSize * channelsPerTexture;\n}\nexport function getColorMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns * 4, rows];\n}\n/**\n * Get shape for densely packed RGBA texture.\n */\nexport function getDenseTexShape(shape) {\n    const size = util.sizeFromShape(shape);\n    const texelsNeeded = Math.ceil(size / 4);\n    return util.sizeToSquarishShape(texelsNeeded);\n}\nexport function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {\n    if (unpackedSize % channelsPerTexture !== 0) {\n        throw new Error(`unpackedSize (${unpackedSize}) must be a multiple of ` +\n            `${channelsPerTexture}`);\n    }\n    return unpackedSize / channelsPerTexture;\n}\nexport function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {\n    const requiredSize = unpackedArray.length * channels / 4;\n    if (matrix.length < requiredSize) {\n        throw new Error(`matrix length (${matrix.length}) must be >= ${requiredSize}`);\n    }\n    let dst = 0;\n    for (let src = 0; src < unpackedArray.length; src += 4) {\n        for (let c = 0; c < channels; c++) {\n            matrix[dst++] = unpackedArray[src + c];\n        }\n    }\n}\nexport function getPackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [\n        Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n    ];\n}\nexport function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {\n    const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return w * h * 4;\n}\nexport function getTextureConfig(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    let internalFormatFloat;\n    let internalFormatHalfFloat;\n    let internalFormatPackedHalfFloat;\n    let internalFormatPackedFloat;\n    let textureFormatFloat;\n    let downloadTextureFormat;\n    let downloadUnpackNumChannels;\n    let defaultNumChannels;\n    let textureTypeHalfFloat;\n    let textureTypeFloat;\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        internalFormatFloat = glany.R32F;\n        internalFormatHalfFloat = glany.R16F;\n        internalFormatPackedHalfFloat = glany.RGBA16F;\n        internalFormatPackedFloat = glany.RGBA32F;\n        textureFormatFloat = glany.RED;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 1;\n        textureTypeHalfFloat = glany.HALF_FLOAT;\n        textureTypeFloat = glany.FLOAT;\n    }\n    else {\n        internalFormatFloat = gl.RGBA;\n        internalFormatHalfFloat = gl.RGBA;\n        internalFormatPackedHalfFloat = gl.RGBA;\n        internalFormatPackedFloat = glany.RGBA;\n        textureFormatFloat = gl.RGBA;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 4;\n        textureTypeHalfFloat = textureHalfFloatExtension != null ?\n            textureHalfFloatExtension.HALF_FLOAT_OES :\n            null;\n        textureTypeFloat = gl.FLOAT;\n    }\n    downloadTextureFormat = gl.RGBA;\n    return {\n        internalFormatFloat,\n        internalFormatHalfFloat,\n        internalFormatPackedHalfFloat,\n        internalFormatPackedFloat,\n        textureFormatFloat,\n        downloadTextureFormat,\n        downloadUnpackNumChannels,\n        defaultNumChannels,\n        textureTypeHalfFloat,\n        textureTypeFloat\n    };\n}\n//# sourceMappingURL=tex_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n    constructor(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0; // How many bytes that have been allocated\n        // are available for reuse.\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    acquireTexture(shapeRC, usage, isPacked) {\n        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this._numBytesFree -= texBytes;\n            this.log();\n            const newTexture = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture);\n            return newTexture;\n        }\n        let newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        this.numUsedTextures++;\n        this._numBytesAllocated += texBytes;\n        this.log();\n        return newTexture;\n    }\n    releaseTexture(texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n        if (deleteTexThreshold !== -1 &&\n            this._numBytesAllocated > deleteTexThreshold) {\n            this.gpgpu.deleteMatrixTexture(texture);\n            this._numBytesAllocated -= texBytes;\n        }\n        else {\n            this.freeTextures[shapeKey].push(texture);\n            this.numFreeTextures++;\n            this._numBytesFree += texBytes;\n        }\n        this.numUsedTextures--;\n        const texList = this.usedTextures[shapeKey];\n        const texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    }\n    log() {\n        if (!this.logEnabled) {\n            return;\n        }\n        const total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n        const freeRatio = this._numBytesFree / this._numBytesAllocated;\n        console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n    }\n    get numBytesAllocated() {\n        return this._numBytesAllocated;\n    }\n    get numBytesFree() {\n        return this._numBytesFree;\n    }\n    getNumUsedTextures() {\n        return this.numUsedTextures;\n    }\n    getNumFreeTextures() {\n        return this.numFreeTextures;\n    }\n    dispose() {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (const texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        for (const texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0;\n    }\n}\nfunction numBytesForInternalFormat(gl, internalFormat) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    if (internalFormat === glany.R32F) {\n        return 4;\n    }\n    else if (internalFormat === glany.R16F) {\n        return 2;\n    }\n    else if (internalFormat === glany.RGBA32F) {\n        return 16;\n    }\n    else if (internalFormat === gl.RGBA) {\n        return 16;\n    }\n    else if (internalFormat === glany.RGBA16F) {\n        return 8;\n    }\n    throw new Error(`Unknown internal format ${internalFormat}`);\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n    // It is not possible to infer packed status from the texture type because\n    // depending on the textureConfig, different  texture types may resolve to the\n    // same internal format (e.g. in WebGL1, the internal format for\n    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n    // explicitly.\n    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n    let numElements;\n    if (isPacked) {\n        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = packedWidth * packedHeight;\n    }\n    else {\n        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = width * height;\n    }\n    const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n    return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n    switch (physicalTexType) {\n        case PhysicalTextureType.PACKED_2X2_FLOAT32:\n            return getInternalFormatForPackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_2X2_FLOAT16:\n            return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT32:\n            return getInternalFormatForFloat32MatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT16:\n            return getInternalFormatForFloat16MatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n            return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n        default:\n            throw new Error(`Unknown physical texture type ${physicalTexType}`);\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n//# sourceMappingURL=texture_manager.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class TileProgram {\n    constructor(aShape, reps) {\n        this.variableNames = ['A'];\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[i] * reps[i];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const sourceCoords = getSourceCoords(aShape);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n    }\n}\nfunction getSourceCoords(aShape) {\n    const rank = aShape.length;\n    if (rank > 5) {\n        throw Error(`Tile for rank ${rank} is not yet supported`);\n    }\n    if (rank === 1) {\n        return `imod(resRC, ${aShape[0]})`;\n    }\n    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n    const sourceCoords = [];\n    for (let i = 0; i < aShape.length; i++) {\n        sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);\n    }\n    return sourceCoords.join();\n}\n//# sourceMappingURL=tile_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class TransposeProgram {\n    constructor(aShape, newDim) {\n        this.variableNames = ['A'];\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const switched = getSwitchedCoords(newDim);\n        this.userCode = `\n    void main() {\n      ${dtype} resRC = getOutputCoords();\n      setOutput(getA(${switched}));\n    }\n    `;\n    }\n}\nfunction getSwitchedCoords(newDim) {\n    const rank = newDim.length;\n    if (rank > 6) {\n        throw Error(`Transpose for rank ${rank} is not yet supported`);\n    }\n    const originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n    const switchedCoords = new Array(rank);\n    for (let i = 0; i < newDim.length; i++) {\n        switchedCoords[newDim[i]] = originalOrder[i];\n    }\n    return switchedCoords.join();\n}\n//# sourceMappingURL=transpose_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getVecChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class TransposePackedProgram {\n    constructor(aShape, newDim) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        if (this.rank > 6) {\n            throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);\n        }\n        const dtype = getCoordsDataType(this.rank);\n        const outputOrder = getVecChannels('rc', this.rank);\n        const switchedOrder = new Array(this.rank);\n        for (let i = 0; i < newDim.length; i++) {\n            switchedOrder[newDim[i]] = outputOrder[i];\n        }\n        const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;\n        const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;\n        const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;\n        this.userCode = `\n    void main() {\n      ${dtype} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${getc};\n      if(${nextColumn}) {\n        result[1] = ${getc};\n      }\n      --${outputOrder[this.rank - 1]};\n      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {\n        result[2] = ${getc};\n        if(${nextColumn}) {\n          result[3] = ${getc};\n        }\n      }\n      setOutput(result);\n    }\n    `;\n    }\n}\n//# sourceMappingURL=transpose_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class UnaryOpProgram {\n    constructor(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n    }\n}\nexport const CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;\nexport const LINEAR = `return x;`;\nexport const ABS = `return abs(x);`;\nexport function STEP(alpha = 0.0) {\n    return CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${alpha});\n  `;\n}\nexport const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\nexport const RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\nexport const RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\nexport const CLONE = 'return x;';\n//# sourceMappingURL=unaryop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const LINEAR = `return x;`;\nexport const ELU = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\nexport const RELU = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const RELU6 = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport class UnaryOpPackedProgram {\n    constructor(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=unaryop_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels, getSourceCoords } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class UnpackProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outputShape = outputShape;\n        const rank = outputShape.length;\n        const channels = getChannels('rc', rank);\n        const dtype = getCoordsDataType(rank);\n        const sourceCoords = getSourceCoords(rank, channels);\n        const innerDims = channels.slice(-2);\n        const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n        this.userCode = `\n      void main() {\n        ${dtype} rc = getOutputCoords();\n        vec4 packedInput = getA(${sourceCoords});\n\n        setOutput(getChannel(packedInput, ${coords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=unpack_gpu.js.map","/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nconst version = '2.8.6';\nexport { version };\n//# sourceMappingURL=version.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as webgl_util from './webgl_util';\nexport { MathBackendWebGL } from './backend_webgl';\nexport { setWebGLContext } from './canvas_util';\nexport { GPGPUContext } from './gpgpu_context';\n// WebGL specific utils.\nexport { gpgpu_util, webgl_util };\n/**\n * Enforce use of half precision textures if available on the platform.\n *\n * @doc {heading: 'Environment', namespace: 'webgl'}\n */\nexport function forceHalfFloat() {\n    env().set('WEBGL_FORCE_F16_TEXTURES', true);\n}\n//# sourceMappingURL=webgl.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n    const returnValue = func();\n    if (env().getBool('DEBUG')) {\n        checkWebGLError(gl);\n    }\n    return returnValue;\n}\nfunction checkWebGLError(gl) {\n    const error = gl.getError();\n    if (error !== gl.NO_ERROR) {\n        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n    }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n        return true;\n    }\n    return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return `Unknown error code ${status}`;\n    }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n    callAndCheck(gl, () => gl.compileShader(vertexShader));\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n    callAndCheck(gl, () => gl.compileShader(fragmentShader));\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n        console.log(shaderSource);\n        return;\n    }\n    const lineNumber = +lineNumberRegexResult[1];\n    const shaderLines = shaderSource.split('\\n');\n    const pad = shaderLines.length.toString().length + 2;\n    const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n    let maxLineLength = 0;\n    for (let i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n    return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n    callAndCheck(gl, () => gl.linkProgram(program));\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nexport function validateProgram(gl, program) {\n    callAndCheck(gl, () => gl.validateProgram(program));\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nexport function createStaticVertexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function getNumChannels() {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nexport function createTexture(gl) {\n    return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n    const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if ((width <= 0) || (height <= 0)) {\n        const requested = `[${width}x${height}]`;\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        const requested = `[${width}x${height}]`;\n        const max = `[${maxTextureSize}x${maxTextureSize}]`;\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nexport function createFramebuffer(gl) {\n    return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n    const loc = gl.getAttribLocation(program, attribute);\n    if (loc === -1) {\n        // The GPU compiler decided to strip out this attribute because it's unused,\n        // thus no need to bind.\n        return false;\n    }\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n    return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n    return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return `unknown error ${status}`;\n    }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    const tOrNull = callAndCheck(gl, () => returnTOrNull());\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    const glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n        throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n    }\n}\nexport function getBatchDim(shape, dimsToSkip = 2) {\n    return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n    if (shape.length === 0) {\n        throw Error('Cannot get rows and columns of an empty shape array.');\n    }\n    return [\n        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n    ];\n}\nexport function getShapeAs3D(shape) {\n    let shapeAs3D = [1, 1, 1];\n    const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n    if (!isScalar) {\n        shapeAs3D =\n            [getBatchDim(shape), ...getRowsCols(shape)];\n    }\n    return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n    let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if (isPacked) {\n        maxTexSize = maxTexSize * 2;\n        // This logic ensures we accurately count the number of packed texels needed\n        // to accommodate the tensor. We can only pack values in the same texel if\n        // they are from adjacent pairs of rows/cols within the same batch. So if a\n        // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n        // fact that the texels containing the third row are half empty.\n        logShape = logShape.map((d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n        // Packed texture height is at least 2 (the channel height of a single\n        // texel).\n        if (logShape.length === 1) {\n            logShape = [2, logShape[0]];\n        }\n    }\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n        const squeezeResult = util.squeezeShape(logShape);\n        logShape = squeezeResult.newShape;\n    }\n    let size = util.sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        return [1, size];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        return logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n        logShape[2] <= maxTexSize) {\n        return [logShape[0] * logShape[1], logShape[2]];\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 &&\n        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n        logShape[3] <= maxTexSize) {\n        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    else {\n        if (isPacked) {\n            // For packed textures size equals the number of channels required to\n            // accommodate the texture data. However in order to squarify such that\n            // inner dimensions stay even, we rewrite size to equal the number of\n            // texels. Then in the return statement we rehydrate the squarified\n            // dimensions to channel units.\n            const batchDim = getBatchDim(logShape);\n            let rows = 2, cols = 2;\n            if (logShape.length) {\n                [rows, cols] = getRowsCols(logShape);\n            }\n            size = batchDim * (rows / 2) * (cols / 2);\n            return util.sizeToSquarishShape(size).map(d => d * 2);\n        }\n        return util.sizeToSquarishShape(size);\n    }\n}\nfunction isEven(n) {\n    return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n    shape1 = shape1.slice(-2);\n    shape2 = shape2.slice(-2);\n    if (util.arraysEqual(shape1, shape2)) {\n        return true;\n    }\n    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.\n        return true;\n    }\n    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n        shape2[1] === 0) {\n        return true;\n    }\n    if (shape1.length !== shape2.length) { // One of the shapes is a vector.\n        const shape1Cols = shape1.slice(-1)[0];\n        const shape2Cols = shape2.slice(-1)[0];\n        if (shape1Cols === shape2Cols) {\n            return true;\n        }\n        if (isEven(shape1Cols) && isEven(shape2Cols) &&\n            (shape1[0] === 1 || shape2[0] === 1)) {\n            return true;\n        }\n    }\n    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n    if (MAX_TEXTURE_SIZE == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n    return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n    MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n    MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n    if (MAX_TEXTURES_IN_SHADER == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n    return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    let queryTimerVersion;\n    const gl = getWebGLContext(webGLVersion);\n    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n        webGLVersion === 2) {\n        queryTimerVersion = 2;\n    }\n    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n        queryTimerVersion = 1;\n    }\n    else {\n        queryTimerVersion = 0;\n    }\n    return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n    const ext = gl.getExtension(extensionName);\n    return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n    try {\n        const gl = getWebGLContext(webGLVersion);\n        if (gl != null) {\n            return true;\n        }\n    }\n    catch (e) {\n        console.log('Error when getting WebGL context: ', e);\n        return false;\n    }\n    return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n    }\n    else {\n        if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n            return false;\n        }\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n            return false;\n        }\n    }\n    else {\n        if (hasExtension(gl, 'EXT_color_buffer_float')) {\n            return createFloatTextureAndBindToFramebuffer(gl);\n        }\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n        }\n        return false;\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n    const texConfig = getTextureConfig(gl);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n    if (webGLVersion !== 2) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    // tslint:disable-next-line:no-any\n    const isEnabled = gl.fenceSync != null;\n    return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(t => {\n        if (t != null) {\n            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +\n                'in the WebGL backend.');\n        }\n    });\n}\n//# sourceMappingURL=webgl_util.js.map"],"sourceRoot":""}