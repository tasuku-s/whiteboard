(self["webpackChunkprofilecard"] = self["webpackChunkprofilecard"] || []).push([["vendors-node_modules_tensorflow_tfjs-backend-webgl_dist_index_js"],{

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assertNotComplex": () => (/* binding */ assertNotComplex)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function assertNotComplex(tensor, opName) {
    if (!Array.isArray(tensor)) {
        tensor = [tensor];
    }
    tensor.forEach(t => {
        if (t != null) {
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors in the CPU backend.`);
        }
    });
}
//# sourceMappingURL=cpu_util.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "simpleAbsImpl": () => (/* binding */ simpleAbsImpl),
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "absConfig": () => (/* binding */ absConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cpu_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cpu_util */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function simpleAbsImpl(vals) {
    const resultValues = new Float32Array(vals.length);
    for (let i = 0; i < vals.length; ++i) {
        resultValues[i] = Math.abs(vals[i]);
    }
    return resultValues;
}
const abs = (args) => {
    const { x } = args.inputs;
    const cpuBackend = args.backend;
    (0,_cpu_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, 'abs');
    let resultValues = new Float32Array(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape));
    const values = cpuBackend.data.get(x.dataId).values;
    resultValues = simpleAbsImpl(values);
    return cpuBackend.makeOutput(resultValues, x.shape, 'float32');
};
const absConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Abs,
    backendName: 'cpu',
    kernelFunc: abs,
};
//# sourceMappingURL=Abs.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addImpl": () => (/* binding */ addImpl),
/* harmony export */   "addComplexImpl": () => (/* binding */ addComplexImpl),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "addConfig": () => (/* binding */ addConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const addImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)(((a, b) => a + b));
const addComplexImpl = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.createComplexBinaryKernelImpl)(((aReal, aImag, bReal, bImag) => {
    return { real: aReal + bReal, imag: aImag + bImag };
}));
const add = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Add, addImpl, addComplexImpl);
const addConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Add,
    backendName: 'cpu',
    kernelFunc: add
};
//# sourceMappingURL=Add.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bincountImpl": () => (/* binding */ bincountImpl),
/* harmony export */   "bincountReduceImpl": () => (/* binding */ bincountReduceImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {
    const weightsSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(weightsShape);
    const outVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.makeZerosTypedArray(size, weightsDtype);
    for (let i = 0; i < xVals.length; i++) {
        const value = xVals[i];
        if (value < 0) {
            throw new Error('Input x must be non-negative!');
        }
        if (value >= size) {
            continue;
        }
        if (weightsSize > 0) {
            outVals[value] += weightsVals[i];
        }
        else {
            outVals[value] += 1;
        }
    }
    return outVals;
}
function bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {
    const numRows = xBuf.shape[0];
    const numCols = xBuf.shape[1];
    const outBuf = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)([numRows, size], weightsBuf.dtype);
    for (let i = 0; i < numRows; i++) {
        for (let j = 0; j < numCols; j++) {
            const value = xBuf.get(i, j);
            if (value < 0) {
                throw new Error('Input x must be non-negative!');
            }
            if (value >= size) {
                continue;
            }
            if (binaryOutput) {
                outBuf.set(1, i, value);
            }
            else {
                if (weightsBuf.size > 0) {
                    outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);
                }
                else {
                    outBuf.set(outBuf.get(i, value) + 1, i, value);
                }
            }
        }
    }
    return outBuf;
}
//# sourceMappingURL=Bincount_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cast": () => (/* binding */ cast),
/* harmony export */   "castConfig": () => (/* binding */ castConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_zeros_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/zeros_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js");
/* harmony import */ var _Complex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Complex */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js");
/* harmony import */ var _Real__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Real */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */






function cast(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { dtype } = attrs;
    // Casting to complex64.
    if (dtype === 'complex64') {
        if (x.dtype === 'complex64') {
            return (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x }, backend });
        }
        const zerosTensorInfo = (0,_utils_zeros_impl__WEBPACK_IMPORTED_MODULE_2__.zeros)(backend, x.shape, x.dtype);
        const floatX = cast({ inputs: { x }, backend, attrs: { dtype: 'float32' } });
        const result = (0,_Complex__WEBPACK_IMPORTED_MODULE_3__.complex)({ inputs: { real: floatX, imag: zerosTensorInfo }, backend });
        backend.disposeIntermediateTensorInfo(zerosTensorInfo);
        backend.disposeIntermediateTensorInfo(floatX);
        return result;
    }
    // Casting from complex64
    if (x.dtype === 'complex64') {
        const realPart = (0,_Real__WEBPACK_IMPORTED_MODULE_4__.real)({ inputs: { input: x }, backend });
        const result = cast({ inputs: { x: realPart }, backend, attrs: { dtype } });
        backend.disposeIntermediateTensorInfo(realPart);
        return result;
    }
    if (!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.hasEncodingLoss(x.dtype, dtype)) {
        // We don't change the underlying data, since we cast to higher
        // precision.
        const result = (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x }, backend });
        return { dataId: result.dataId, shape: result.shape, dtype };
    }
    if (dtype === 'int32') {
        const values = backend.data.get(x.dataId).values;
        const resultValues = Int32Array.from(values);
        return backend.makeTensorInfo(x.shape, 'int32', resultValues);
    }
    if (dtype === 'bool') {
        // This is essentially the result of notEqual(x, 0). We avoid using
        // kernel notEqual to avoid circular dependency, i.e. binary_utils ->
        // cast -> notEqual -> binary_utils.
        const xVals = backend.data.get(x.dataId).values;
        const zero = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.toTypedArray([0], x.dtype);
        const [resultData, resultShape] = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_5__.createSimpleBinaryKernelImpl)((a, b) => (a !== b) ? 1 : 0)(x.shape, [], xVals, zero, 'bool');
        return backend.makeTensorInfo(resultShape, 'bool', resultData);
    }
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
}
const castConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Cast,
    backendName: 'cpu',
    kernelFunc: cast
};
//# sourceMappingURL=Cast.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ceilImpl": () => (/* binding */ ceilImpl),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "ceilConfig": () => (/* binding */ ceilConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/unary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js");
/* harmony import */ var _utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/unary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ceilImpl = (0,_utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleUnaryImpl)((xi) => Math.ceil(xi));
const ceil = (0,_utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFuncFromImpl)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Ceil, ceilImpl);
const ceilConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Ceil,
    backendName: 'cpu',
    kernelFunc: ceil,
};
//# sourceMappingURL=Ceil.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "complex": () => (/* binding */ complex),
/* harmony export */   "complexConfig": () => (/* binding */ complexConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function complex(args) {
    const { inputs, backend } = args;
    const { real, imag } = inputs;
    const realVals = backend.data.get(real.dataId).values;
    const imagVals = backend.data.get(imag.dataId).values;
    const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');
    const complex = backend.data.get(complexInfo.dataId);
    // The complex tensor owns the underlying real and imag tensorInfos, only the
    // complex tensor tracks refCount, when complexData is disposed the
    // underlying tensorData will be disposed.
    complex.complexTensorInfos = {
        real: backend.makeTensorInfo(real.shape, 'float32', realVals),
        imag: backend.makeTensorInfo(imag.shape, 'float32', imagVals)
    };
    return complexInfo;
}
const complexConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Complex,
    backendName: 'cpu',
    kernelFunc: complex
};
//# sourceMappingURL=Complex.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concatImpl": () => (/* binding */ concatImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function concatImpl(inputs, outShape, dtype, simplyConcat) {
    const outVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getArrayFromDType(dtype, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(outShape));
    if (simplyConcat && dtype !== 'string') {
        // Use built-in TypedArray.set() method for speed.
        let offset = 0;
        inputs.forEach(input => {
            const size = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(input.shape);
            outVals.set(input.vals, offset);
            offset += size;
        });
    }
    else {
        let colOffset = 0;
        inputs.forEach(input => {
            const decodedData = dtype === 'string' ?
                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.fromUint8ToStringArray(input.vals) :
                input.vals;
            let tIdx = 0;
            for (let row = 0; row < input.shape[0]; ++row) {
                const resIdx = row * outShape[1] + colOffset;
                for (let col = 0; col < input.shape[1]; ++col) {
                    outVals[resIdx + col] = decodedData[tIdx++];
                }
            }
            colOffset += input.shape[1];
        });
    }
    return outVals;
}
//# sourceMappingURL=Concat_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expImpl": () => (/* binding */ expImpl),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "expConfig": () => (/* binding */ expConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/unary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js");
/* harmony import */ var _utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/unary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const expImpl = (0,_utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleUnaryImpl)((xi) => Math.exp(xi));
const exp = (0,_utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFuncFromImpl)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Exp, expImpl);
const expConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Exp,
    backendName: 'cpu',
    kernelFunc: exp,
};
//# sourceMappingURL=Exp.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expm1Impl": () => (/* binding */ expm1Impl),
/* harmony export */   "expm1": () => (/* binding */ expm1),
/* harmony export */   "expm1Config": () => (/* binding */ expm1Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/unary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js");
/* harmony import */ var _utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/unary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const expm1Impl = (0,_utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleUnaryImpl)((xi) => Math.expm1(xi));
const expm1 = (0,_utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFuncFromImpl)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Expm1, expm1Impl);
const expm1Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Expm1,
    backendName: 'cpu',
    kernelFunc: expm1,
};
//# sourceMappingURL=Expm1.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "floorImpl": () => (/* binding */ floorImpl),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "floorConfig": () => (/* binding */ floorConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/unary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js");
/* harmony import */ var _utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/unary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const floorImpl = (0,_utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleUnaryImpl)((xi) => Math.floor(xi));
const floor = (0,_utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFuncFromImpl)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Floor, floorImpl);
const floorConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Floor,
    backendName: 'cpu',
    kernelFunc: floor,
};
//# sourceMappingURL=Floor.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gatherV2Impl": () => (/* binding */ gatherV2Impl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {
    const outBuf = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(flattenOutputShape, xBuf.dtype);
    for (let i = 0; i < outBuf.size; ++i) {
        const newLoc = outBuf.indexToLoc(i);
        const originalLoc = newLoc.slice();
        const batchIdx = originalLoc[0];
        const indicesIdx = originalLoc[2];
        const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);
        originalLoc[2] = indicesBuf.values[indicesIndex];
        const originalIndex = xBuf.locToIndex(originalLoc);
        outBuf.values[i] = xBuf.values[originalIndex];
    }
    return outBuf;
}
//# sourceMappingURL=GatherV2_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "greaterImpl": () => (/* binding */ greaterImpl),
/* harmony export */   "greater": () => (/* binding */ greater),
/* harmony export */   "greaterConfig": () => (/* binding */ greaterConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const greaterImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)((a, b) => (a > b) ? 1 : 0);
const greater = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Greater, greaterImpl, null /* complexImpl */, 'bool');
const greaterConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Greater,
    backendName: 'cpu',
    kernelFunc: greater
};
//# sourceMappingURL=Greater.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "identityConfig": () => (/* binding */ identityConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function identity(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    backend.incRef(x.dataId);
    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
}
const identityConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Identity,
    backendName: 'cpu',
    kernelFunc: identity
};
//# sourceMappingURL=Identity.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lessImpl": () => (/* binding */ lessImpl),
/* harmony export */   "less": () => (/* binding */ less),
/* harmony export */   "lessConfig": () => (/* binding */ lessConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const lessImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)((a, b) => (a < b) ? 1 : 0);
const less = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Less, lessImpl, null /* complexImpl */, 'bool');
const lessConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Less,
    backendName: 'cpu',
    kernelFunc: less
};
//# sourceMappingURL=Less.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linSpaceImpl": () => (/* binding */ linSpaceImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function linSpaceImpl(start, stop, num) {
    const step = (stop - start) / (num - 1);
    const values = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.makeZerosTypedArray(num, 'float32');
    values[0] = start;
    for (let i = 1; i < values.length; i++) {
        values[i] = values[i - 1] + step;
    }
    return values;
}
//# sourceMappingURL=LinSpace_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logImpl": () => (/* binding */ logImpl),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "logConfig": () => (/* binding */ logConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/unary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js");
/* harmony import */ var _utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/unary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const logImpl = (0,_utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleUnaryImpl)((xi) => Math.log(xi));
const log = (0,_utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFuncFromImpl)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Log, logImpl);
const logConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Log,
    backendName: 'cpu',
    kernelFunc: log,
};
//# sourceMappingURL=Log.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxImpl": () => (/* binding */ maxImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function maxImpl(aVals, reduceSize, outShape, dtype) {
    const vals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType(dtype, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(outShape));
    for (let i = 0; i < vals.length; ++i) {
        const offset = i * reduceSize;
        let max = aVals[offset];
        for (let j = 0; j < reduceSize; ++j) {
            const value = aVals[offset + j];
            if (value > max) {
                max = value;
            }
        }
        vals[i] = max;
    }
    return vals;
}
//# sourceMappingURL=Max_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maximumImpl": () => (/* binding */ maximumImpl),
/* harmony export */   "maximum": () => (/* binding */ maximum),
/* harmony export */   "maximumConfig": () => (/* binding */ maximumConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const maximumImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)(((aValue, bValue) => Math.max(aValue, bValue)));
const maximum = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Maximum, maximumImpl);
const maximumConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Maximum,
    backendName: 'cpu',
    kernelFunc: maximum
};
//# sourceMappingURL=Maximum.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "minimumImpl": () => (/* binding */ minimumImpl),
/* harmony export */   "minimum": () => (/* binding */ minimum),
/* harmony export */   "minimumConfig": () => (/* binding */ minimumConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const minimumImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)(((aValue, bValue) => Math.min(aValue, bValue)));
const minimum = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Minimum, minimumImpl);
const minimumConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Minimum,
    backendName: 'cpu',
    kernelFunc: minimum
};
//# sourceMappingURL=Minimum.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multiplyImpl": () => (/* binding */ multiplyImpl),
/* harmony export */   "multiplyComplexImpl": () => (/* binding */ multiplyComplexImpl),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "multiplyConfig": () => (/* binding */ multiplyConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const multiplyImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)(((aValue, bValue) => aValue * bValue));
const multiplyComplexImpl = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.createComplexBinaryKernelImpl)(((aReal, aImag, bReal, bImag) => {
    return {
        real: aReal * bReal - aImag * bImag,
        imag: aReal * bImag + aImag * bReal
    };
}));
const multiply = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Multiply, multiplyImpl, multiplyComplexImpl);
const multiplyConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Multiply,
    backendName: 'cpu',
    kernelFunc: multiply
};
//# sourceMappingURL=Multiply.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "negImpl": () => (/* binding */ negImpl),
/* harmony export */   "neg": () => (/* binding */ neg),
/* harmony export */   "negConfig": () => (/* binding */ negConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cpu_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cpu_util */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js");
/* harmony import */ var _Multiply__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Multiply */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function negImpl(xVals, xShape, xDtype) {
    const minusOne = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.createScalarValue(-1, xDtype);
    return (0,_Multiply__WEBPACK_IMPORTED_MODULE_1__.multiplyImpl)([], xShape, minusOne, xVals, xDtype);
}
function neg(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    (0,_cpu_util__WEBPACK_IMPORTED_MODULE_2__.assertNotComplex)(x, 'neg');
    const xVals = backend.data.get(x.dataId).values;
    const [res, newShape] = negImpl(xVals, x.shape, x.dtype);
    return backend.makeTensorInfo(newShape, x.dtype, res);
}
const negConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Neg,
    backendName: 'cpu',
    kernelFunc: neg
};
//# sourceMappingURL=Neg.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "notEqualImpl": () => (/* binding */ notEqualImpl),
/* harmony export */   "notEqual": () => (/* binding */ notEqual),
/* harmony export */   "notEqualConfig": () => (/* binding */ notEqualConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const notEqualImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)(((a, b) => (a !== b) ? 1 : 0));
const notEqual = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.NotEqual, notEqualImpl, null /* complexOp */, 'bool');
const notEqualConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.NotEqual,
    backendName: 'cpu',
    kernelFunc: notEqual
};
//# sourceMappingURL=NotEqual.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prodImpl": () => (/* binding */ prodImpl),
/* harmony export */   "prod": () => (/* binding */ prod),
/* harmony export */   "prodConfig": () => (/* binding */ prodConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cpu_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cpu_util */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function prodImpl(xShape, xDtype, xVals, reductionAxes) {
    const [outShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(xShape, reductionAxes);
    const outDtype = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.upcastType)(xDtype, 'int32');
    const outVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.makeZerosTypedArray(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(outShape), outDtype);
    const reduceSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
    for (let i = 0; i < outVals.length; ++i) {
        const offset = i * reduceSize;
        let prod = 1;
        for (let j = 0; j < reduceSize; ++j) {
            prod *= xVals[offset + j];
        }
        outVals[i] = prod;
    }
    return { outVals, outShape, outDtype };
}
function prod(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    (0,_cpu_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, 'prod');
    const xRank = x.shape.length;
    const axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
    const permutation = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
    let reductionAxes = axes;
    let permutedX = x;
    const intermediateTensorInfos = [];
    if (permutation != null) {
        permutedX = (0,_Transpose__WEBPACK_IMPORTED_MODULE_2__.transpose)({ inputs: { x }, backend, attrs: { perm: permutation } });
        intermediateTensorInfos.push(permutedX);
        reductionAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(reductionAxes.length, xRank);
    }
    const xVals = backend.data.get(permutedX.dataId).values;
    const { outVals, outShape, outDtype } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);
    let resultShape = outShape;
    if (keepDims) {
        resultShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(outShape, axes);
    }
    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return backend.makeTensorInfo(resultShape, outDtype, outVals);
}
const prodConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Prod,
    backendName: 'cpu',
    kernelFunc: prod
};
//# sourceMappingURL=Prod.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rangeImpl": () => (/* binding */ rangeImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function rangeImpl(start, stop, step, dtype) {
    const sameStartStop = start === stop;
    const increasingRangeNegativeStep = start < stop && step < 0;
    const decreasingRangePositiveStep = stop < start && step > 1;
    if (sameStartStop || increasingRangeNegativeStep ||
        decreasingRangePositiveStep) {
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.makeZerosTypedArray(0, dtype);
    }
    const numElements = Math.abs(Math.ceil((stop - start) / step));
    const values = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.makeZerosTypedArray(numElements, dtype);
    if (stop < start && step === 1) {
        // Auto adjust the step's sign if it hasn't been set
        // (or was set to 1)
        step = -1;
    }
    values[0] = start;
    for (let i = 1; i < values.length; i++) {
        values[i] = values[i - 1] + step;
    }
    return values;
}
//# sourceMappingURL=Range_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "real": () => (/* binding */ real),
/* harmony export */   "realConfig": () => (/* binding */ realConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function real(args) {
    const { inputs, backend } = args;
    const { input } = inputs;
    const real = backend.data.get(input.dataId).complexTensorInfos.real;
    const realVal = backend.data.get(real.dataId).values;
    // When complex tensor is disposed, its underlying parts will be disposed too.
    // Make new tensor out of the real value of the complex. This makes sure the
    // value is still accessible even if complex tensor is disposed.
    return backend.makeTensorInfo(real.shape, real.dtype, realVal);
}
const realConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Real,
    backendName: 'cpu',
    kernelFunc: real
};
//# sourceMappingURL=Real.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rsqrtImpl": () => (/* binding */ rsqrtImpl),
/* harmony export */   "rsqrt": () => (/* binding */ rsqrt),
/* harmony export */   "rsqrtConfig": () => (/* binding */ rsqrtConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/unary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js");
/* harmony import */ var _utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/unary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const rsqrtImpl = (0,_utils_unary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleUnaryImpl)((xi) => 1 / Math.sqrt(xi));
const rsqrt = (0,_utils_unary_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFuncFromImpl)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Rsqrt, rsqrtImpl);
const rsqrtConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Rsqrt,
    backendName: 'cpu',
    kernelFunc: rsqrt,
};
//# sourceMappingURL=Rsqrt.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sliceImpl": () => (/* binding */ sliceImpl),
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "sliceConfig": () => (/* binding */ sliceConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cpu_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cpu_util */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function sliceImpl(vals, begin, size, shape, dtype) {
    const isContinous = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.isSliceContinous(shape, begin, size);
    const length = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(size);
    const xStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(shape);
    if (isContinous) {
        const flatOffset = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.computeFlatOffset(begin, xStrides);
        if (dtype === 'string') {
            return vals.slice(flatOffset, flatOffset + length);
        }
        return vals.subarray(flatOffset, flatOffset + length);
    }
    const decodedData = dtype === 'string' ?
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.fromUint8ToStringArray(vals) :
        vals;
    const inBuf = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(shape, dtype, decodedData);
    const outBuf = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(size, dtype);
    for (let i = 0; i < outBuf.size; ++i) {
        const outLoc = outBuf.indexToLoc(i);
        const inLoc = outLoc.map((idx, j) => idx + begin[j]);
        outBuf.set(inBuf.get(...inLoc), ...outLoc);
    }
    if (dtype === 'string') {
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.fromStringArrayToUint8(outBuf.values);
    }
    return outBuf.values;
}
function slice(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { begin, size } = attrs;
    (0,_cpu_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, 'slice');
    const [$begin, $size] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.parseSliceParams(x, begin, size);
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.assertParamsValid(x, $begin, $size);
    const vals = backend.data.get(x.dataId).values;
    const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);
    return backend.makeTensorInfo($size, x.dtype, outVals);
}
const sliceConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Slice,
    backendName: 'cpu',
    kernelFunc: slice
};
//# sourceMappingURL=Slice.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "squaredDifferenceImpl": () => (/* binding */ squaredDifferenceImpl),
/* harmony export */   "squaredDifference": () => (/* binding */ squaredDifference),
/* harmony export */   "squaredDifferenceConfig": () => (/* binding */ squaredDifferenceConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const squaredDifferenceImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)(((a, b) => {
    const diff = a - b;
    return diff * diff;
}));
const squaredDifference = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.SquaredDifference, squaredDifferenceImpl);
const squaredDifferenceConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.SquaredDifference,
    backendName: 'cpu',
    kernelFunc: squaredDifference
};
//# sourceMappingURL=SquaredDifference.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stridedSliceImpl": () => (/* binding */ stridedSliceImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function stridedSliceImpl(outShape, xBuf, strides, begin) {
    const outBuf = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(outShape, xBuf.dtype);
    for (let i = 0; i < outBuf.size; i++) {
        const loc = outBuf.indexToLoc(i);
        const newLoc = new Array(loc.length);
        for (let j = 0; j < newLoc.length; j++) {
            newLoc[j] = loc[j] * strides[j] + begin[j];
        }
        outBuf.set(xBuf.get(...newLoc), ...loc);
    }
    return outBuf;
}
//# sourceMappingURL=StridedSlice_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subImpl": () => (/* binding */ subImpl),
/* harmony export */   "subComplexImpl": () => (/* binding */ subComplexImpl),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "subConfig": () => (/* binding */ subConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js");
/* harmony import */ var _utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/binary_utils */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const subImpl = (0,_utils_binary_impl__WEBPACK_IMPORTED_MODULE_1__.createSimpleBinaryKernelImpl)(((aValue, bValue) => aValue - bValue));
const subComplexImpl = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.createComplexBinaryKernelImpl)(((aReal, aImag, bReal, bImag) => {
    return { real: aReal - bReal, imag: aImag - bImag };
}));
const sub = (0,_utils_binary_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sub, subImpl, subComplexImpl);
const subConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sub,
    backendName: 'cpu',
    kernelFunc: sub
};
//# sourceMappingURL=Sub.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tileImpl": () => (/* binding */ tileImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

/**
 * An implementation of the tile kernel shared between webgl and cpu for string
 * tensors only.
 */
function tileImpl(xBuf, reps) {
    const newShape = new Array(xBuf.rank);
    for (let i = 0; i < newShape.length; i++) {
        newShape[i] = xBuf.shape[i] * reps[i];
    }
    const result = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(newShape, xBuf.dtype);
    for (let i = 0; i < result.values.length; ++i) {
        const newLoc = result.indexToLoc(i);
        const originalLoc = new Array(xBuf.rank);
        for (let j = 0; j < originalLoc.length; j++) {
            originalLoc[j] = newLoc[j] % xBuf.shape[j];
        }
        const originalIndex = xBuf.locToIndex(originalLoc);
        result.values[i] = xBuf.values[originalIndex];
    }
    return result;
}
//# sourceMappingURL=Tile_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "topKImpl": () => (/* binding */ topKImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** An implementation of the TopK kernel shared between webgl and cpu. */

function topKImpl(x, xShape, xDtype, k, sorted) {
    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.
    const lastDim = xShape[xShape.length - 1];
    const [batch, size] = [x.length / lastDim, lastDim];
    const allTopKVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType(xDtype, batch * k);
    const allTopKIndices = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType('int32', batch * k);
    for (let b = 0; b < batch; b++) {
        const offset = b * size;
        const vals = x.subarray(offset, offset + size);
        const valAndInd = [];
        for (let i = 0; i < vals.length; i++) {
            valAndInd.push({ value: vals[i], index: i });
        }
        valAndInd.sort((a, b) => b.value - a.value);
        const outOffset = b * k;
        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);
        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);
        for (let i = 0; i < k; i++) {
            topKVals[i] = valAndInd[i].value;
            topKIndices[i] = valAndInd[i].index;
        }
    }
    // Reshape back to the original input shape, except that the last
    // dimension is k.
    const outputShape = xShape.slice();
    outputShape[outputShape.length - 1] = k;
    return [
        (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(outputShape, xDtype, allTopKVals),
        (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(outputShape, 'int32', allTopKIndices)
    ];
}
//# sourceMappingURL=TopK_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "transposeConfig": () => (/* binding */ transposeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cpu_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cpu_util */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function transpose(args) {
    const { inputs, attrs, backend } = args;
    const { x } = inputs;
    const { perm } = attrs;
    (0,_cpu_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, 'transpose');
    const xRank = x.shape.length;
    const newShape = new Array(xRank);
    for (let i = 0; i < newShape.length; i++) {
        newShape[i] = x.shape[perm[i]];
    }
    const values = backend.data.get(x.dataId).values;
    const result = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_2__.transposeImpl)(values, x.shape, x.dtype, perm, newShape);
    const dataId = backend.write(result, newShape, x.dtype);
    return { dataId, shape: newShape, dtype: x.dtype };
}
const transposeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Transpose,
    backendName: 'cpu',
    kernelFunc: transpose
};
//# sourceMappingURL=Transpose.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transposeImpl": () => (/* binding */ transposeImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function transposeImpl(xVals, xShape, dtype, perm, newShape) {
    const xRank = xShape.length;
    const xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(xShape);
    const xStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(xShape);
    const newStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(newShape);
    const result = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType(dtype, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(newShape));
    for (let i = 0; i < xSize; ++i) {
        const loc = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.indexToLoc(i, xRank, xStrides);
        // Permute location.
        const newLoc = new Array(loc.length);
        for (let i = 0; i < newLoc.length; i++) {
            newLoc[i] = loc[perm[i]];
        }
        const newIndex = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.locToIndex(newLoc, xRank, newStrides);
        result[newIndex] = xVals[i];
    }
    return result;
}
//# sourceMappingURL=Transpose_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uniqueImpl": () => (/* binding */ uniqueImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function uniqueImpl(values, axis, shape, dtype) {
    // Normalize and validate axis.
    const $axis = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, shape)[0];
    // Calculate the new shape that is suitable for extracting data along the
    // given axis.
    //
    // The rank is 3.
    // The size of the 1st dimension is the size of all the axes < the given axis.
    // The size of the 2nd dimension is the same as the size of the given axis.
    // The size of the 3rd dimension is the size of all the axes > the given axis.
    //
    // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the
    // newShape would be: [2*3, 5, 4].
    //
    // Note that this is not the final output shape. This will be the shape for an
    // intermediate TensorBuffer (see inputBuffer below) to allow us to extract
    // values along the given axis. To demonstrate how it works, consider the
    // following example:
    //
    // Input: a 3D tensor, with shape [1, 2, 3]
    // [
    //   [
    //      [1,2,3],
    //      [4,5,6]
    //   ]
    // ]
    // Axis: 2 (the last axis).
    // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].
    //
    // For this example, newShape would be: [2, 3, 1], where 2 is calculated from
    // 1*2. The re-shaped data would look like:
    //
    // [
    //   [
    //     [1], [2], [3]
    //   ],
    //   [
    //     [4], [5], [6]
    //   ]
    // ]
    //
    // Then, we can construct a 3-level nested loop by the following dimension
    // order to extract the values along the axis (dimension1):
    // i: dimension1       // 0,1,2 (newShape[1])
    //   m: dimension0     // 0,1   (newShape[0])
    //     n: dimension2   // 0     (newShape[2])
    //
    //                       m, i, n
    //                      ---------
    // Iteration 0: data at [0, 0, 0] => "1"
    // Iteration 1: data at [1, 0, 0] => "4"
    // We got [1,4].
    // Iteration 2: data at [0, 1, 0] => "2"
    // Iteration 3: data at [1, 1, 0] => "5"
    // We got [2,5].
    // Iteration 4: data at [0, 2, 0] => "3"
    // Iteration 5: data at [1, 2, 0] => "6"
    // We got [3,6].
    const newShape = [1, shape[0], 1];
    for (let i = 0; i < $axis; i++) {
        newShape[0] *= shape[i];
    }
    newShape[1] = shape[$axis];
    for (let i = $axis + 1; i < shape.length; i++) {
        newShape[2] *= shape[i];
    }
    // A map from unique elements (their string representations) to their values
    // in "indices" (below).
    const uniqueElements = {};
    // The indices of each unique element in the original tensor along the given
    // axis. It is 1D and has the same size as the given axis.
    const indices = new Int32Array(shape[$axis]);
    // Create a buffer so we can easily extract value at a given location.
    const inputBuffer = new _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.TensorBuffer(newShape, dtype, values);
    // The indices along the given axis that have unique elements. This is a
    // de-duped version of "indices" above.
    const uniqueIndices = [];
    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
    for (let i = 0; i < shape[$axis]; i++) {
        // Extract values along the axis.
        let element;
        if (is1DTensor) {
            // Fast path for 1D tensor input.
            element = values[i].toString();
        }
        else {
            const axisValues = [];
            for (let m = 0; m < newShape[0]; m++) {
                for (let n = 0; n < newShape[2]; n++) {
                    axisValues.push(inputBuffer.get(m, i, n));
                }
            }
            element = axisValues.join(',');
        }
        // Dedup and update various indices.
        if (uniqueElements[element] !== undefined) {
            indices[i] = uniqueElements[element];
        }
        else {
            const uniqueIndex = Object.keys(uniqueElements).length;
            uniqueElements[element] = uniqueIndex;
            indices[i] = uniqueIndex;
            uniqueIndices.push(i);
        }
    }
    // Now we know where each of the unique elements are located along the axis
    // (uniqueIndices). Extract them from input buffer and store them in the
    // output buffer.
    const outputTmpShape = newShape.slice();
    outputTmpShape[1] = Object.keys(uniqueElements).length;
    const outputBuffer = new _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.TensorBuffer(outputTmpShape, dtype);
    uniqueIndices.forEach((uniqueElementIndex, i) => {
        for (let m = 0; m < newShape[0]; m++) {
            for (let n = 0; n < newShape[2]; n++) {
                outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);
            }
        }
    });
    // The output shape can be calculated from the input shape with the size of
    // the given axis replaced by the number of unique elements along that axis.
    const outputShape = shape.slice();
    outputShape[$axis] = outputTmpShape[1];
    return {
        outputValues: outputBuffer.values,
        outputShape,
        indices,
    };
}
//# sourceMappingURL=Unique_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "simpleAbsImpl": () => (/* reexport safe */ _kernels_Abs__WEBPACK_IMPORTED_MODULE_0__.simpleAbsImpl),
/* harmony export */   "addImpl": () => (/* reexport safe */ _kernels_Add__WEBPACK_IMPORTED_MODULE_1__.addImpl),
/* harmony export */   "bincountImpl": () => (/* reexport safe */ _kernels_Bincount_impl__WEBPACK_IMPORTED_MODULE_2__.bincountImpl),
/* harmony export */   "bincountReduceImpl": () => (/* reexport safe */ _kernels_Bincount_impl__WEBPACK_IMPORTED_MODULE_2__.bincountReduceImpl),
/* harmony export */   "ceilImpl": () => (/* reexport safe */ _kernels_Ceil__WEBPACK_IMPORTED_MODULE_3__.ceilImpl),
/* harmony export */   "concatImpl": () => (/* reexport safe */ _kernels_Concat_impl__WEBPACK_IMPORTED_MODULE_4__.concatImpl),
/* harmony export */   "expImpl": () => (/* reexport safe */ _kernels_Exp__WEBPACK_IMPORTED_MODULE_5__.expImpl),
/* harmony export */   "expm1Impl": () => (/* reexport safe */ _kernels_Expm1__WEBPACK_IMPORTED_MODULE_6__.expm1Impl),
/* harmony export */   "floorImpl": () => (/* reexport safe */ _kernels_Floor__WEBPACK_IMPORTED_MODULE_7__.floorImpl),
/* harmony export */   "gatherV2Impl": () => (/* reexport safe */ _kernels_GatherV2_impl__WEBPACK_IMPORTED_MODULE_8__.gatherV2Impl),
/* harmony export */   "greaterImpl": () => (/* reexport safe */ _kernels_Greater__WEBPACK_IMPORTED_MODULE_9__.greaterImpl),
/* harmony export */   "lessImpl": () => (/* reexport safe */ _kernels_Less__WEBPACK_IMPORTED_MODULE_10__.lessImpl),
/* harmony export */   "linSpaceImpl": () => (/* reexport safe */ _kernels_LinSpace_impl__WEBPACK_IMPORTED_MODULE_11__.linSpaceImpl),
/* harmony export */   "logImpl": () => (/* reexport safe */ _kernels_Log__WEBPACK_IMPORTED_MODULE_12__.logImpl),
/* harmony export */   "maxImpl": () => (/* reexport safe */ _kernels_Max_impl__WEBPACK_IMPORTED_MODULE_13__.maxImpl),
/* harmony export */   "maximumImpl": () => (/* reexport safe */ _kernels_Maximum__WEBPACK_IMPORTED_MODULE_14__.maximumImpl),
/* harmony export */   "minimumImpl": () => (/* reexport safe */ _kernels_Minimum__WEBPACK_IMPORTED_MODULE_15__.minimumImpl),
/* harmony export */   "multiplyImpl": () => (/* reexport safe */ _kernels_Multiply__WEBPACK_IMPORTED_MODULE_16__.multiplyImpl),
/* harmony export */   "negImpl": () => (/* reexport safe */ _kernels_Neg__WEBPACK_IMPORTED_MODULE_17__.negImpl),
/* harmony export */   "notEqualImpl": () => (/* reexport safe */ _kernels_NotEqual__WEBPACK_IMPORTED_MODULE_18__.notEqualImpl),
/* harmony export */   "prodImpl": () => (/* reexport safe */ _kernels_Prod__WEBPACK_IMPORTED_MODULE_19__.prodImpl),
/* harmony export */   "rangeImpl": () => (/* reexport safe */ _kernels_Range_impl__WEBPACK_IMPORTED_MODULE_20__.rangeImpl),
/* harmony export */   "rsqrtImpl": () => (/* reexport safe */ _kernels_Rsqrt__WEBPACK_IMPORTED_MODULE_21__.rsqrtImpl),
/* harmony export */   "sliceImpl": () => (/* reexport safe */ _kernels_Slice__WEBPACK_IMPORTED_MODULE_22__.sliceImpl),
/* harmony export */   "squaredDifferenceImpl": () => (/* reexport safe */ _kernels_SquaredDifference__WEBPACK_IMPORTED_MODULE_23__.squaredDifferenceImpl),
/* harmony export */   "stridedSliceImpl": () => (/* reexport safe */ _kernels_StridedSlice_impl__WEBPACK_IMPORTED_MODULE_24__.stridedSliceImpl),
/* harmony export */   "subImpl": () => (/* reexport safe */ _kernels_Sub__WEBPACK_IMPORTED_MODULE_25__.subImpl),
/* harmony export */   "tileImpl": () => (/* reexport safe */ _kernels_Tile_impl__WEBPACK_IMPORTED_MODULE_26__.tileImpl),
/* harmony export */   "topKImpl": () => (/* reexport safe */ _kernels_TopK_impl__WEBPACK_IMPORTED_MODULE_27__.topKImpl),
/* harmony export */   "transposeImpl": () => (/* reexport safe */ _kernels_Transpose_impl__WEBPACK_IMPORTED_MODULE_28__.transposeImpl),
/* harmony export */   "uniqueImpl": () => (/* reexport safe */ _kernels_Unique_impl__WEBPACK_IMPORTED_MODULE_29__.uniqueImpl)
/* harmony export */ });
/* harmony import */ var _kernels_Abs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kernels/Abs */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js");
/* harmony import */ var _kernels_Add__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kernels/Add */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js");
/* harmony import */ var _kernels_Bincount_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kernels/Bincount_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js");
/* harmony import */ var _kernels_Ceil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./kernels/Ceil */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js");
/* harmony import */ var _kernels_Concat_impl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./kernels/Concat_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js");
/* harmony import */ var _kernels_Exp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./kernels/Exp */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js");
/* harmony import */ var _kernels_Expm1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./kernels/Expm1 */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js");
/* harmony import */ var _kernels_Floor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./kernels/Floor */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js");
/* harmony import */ var _kernels_GatherV2_impl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./kernels/GatherV2_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js");
/* harmony import */ var _kernels_Greater__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./kernels/Greater */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js");
/* harmony import */ var _kernels_Less__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./kernels/Less */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js");
/* harmony import */ var _kernels_LinSpace_impl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./kernels/LinSpace_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js");
/* harmony import */ var _kernels_Log__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./kernels/Log */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js");
/* harmony import */ var _kernels_Max_impl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./kernels/Max_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js");
/* harmony import */ var _kernels_Maximum__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./kernels/Maximum */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js");
/* harmony import */ var _kernels_Minimum__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./kernels/Minimum */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js");
/* harmony import */ var _kernels_Multiply__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./kernels/Multiply */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js");
/* harmony import */ var _kernels_Neg__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./kernels/Neg */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js");
/* harmony import */ var _kernels_NotEqual__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./kernels/NotEqual */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js");
/* harmony import */ var _kernels_Prod__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./kernels/Prod */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js");
/* harmony import */ var _kernels_Range_impl__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./kernels/Range_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js");
/* harmony import */ var _kernels_Rsqrt__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./kernels/Rsqrt */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js");
/* harmony import */ var _kernels_Slice__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./kernels/Slice */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js");
/* harmony import */ var _kernels_SquaredDifference__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./kernels/SquaredDifference */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js");
/* harmony import */ var _kernels_StridedSlice_impl__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./kernels/StridedSlice_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js");
/* harmony import */ var _kernels_Sub__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./kernels/Sub */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js");
/* harmony import */ var _kernels_Tile_impl__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./kernels/Tile_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js");
/* harmony import */ var _kernels_TopK_impl__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./kernels/TopK_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js");
/* harmony import */ var _kernels_Transpose_impl__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./kernels/Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js");
/* harmony import */ var _kernels_Unique_impl__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./kernels/Unique_impl */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Shared functionality among backends.






























//# sourceMappingURL=shared.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSimpleBinaryKernelImpl": () => (/* binding */ createSimpleBinaryKernelImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

/**
 * Template that creates implementation for binary ops. Supports broadcast.
 */
function createSimpleBinaryKernelImpl(op) {
    return (aShape, bShape, aVals, bVals, dtype) => {
        const newShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(aShape, bShape);
        const resultRank = newShape.length;
        const resultStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(newShape);
        const resultSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(newShape);
        const result = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType(dtype, resultSize);
        const aRank = aShape.length;
        const bRank = bShape.length;
        const aStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(aShape);
        const bStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(bShape);
        const aBroadcastDims = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getBroadcastDims(aShape, newShape);
        const bBroadcastDims = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getBroadcastDims(bShape, newShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
            for (let i = 0; i < result.length; ++i) {
                result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);
            }
        }
        else {
            for (let i = 0; i < result.length; ++i) {
                const loc = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.indexToLoc(i, resultRank, resultStrides);
                const aLoc = loc.slice(-aRank);
                aBroadcastDims.forEach(d => aLoc[d] = 0);
                const aIndex = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.locToIndex(aLoc, aRank, aStrides);
                const bLoc = loc.slice(-bRank);
                bBroadcastDims.forEach(d => bLoc[d] = 0);
                const bIndex = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.locToIndex(bLoc, bRank, bStrides);
                result[i] = op(aVals[aIndex], bVals[bIndex]);
            }
        }
        return [result, newShape];
    };
}
//# sourceMappingURL=binary_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryKernelFunc": () => (/* binding */ binaryKernelFunc),
/* harmony export */   "createComplexBinaryKernelImpl": () => (/* binding */ createComplexBinaryKernelImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cpu_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cpu_util */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js");
/* harmony import */ var _kernels_Cast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernels/Cast */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js");
/* harmony import */ var _kernels_Complex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernels/Complex */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




/**
 * Template that creates a `KernelFunc` for binary ops.
 * @param name Kernel name.
 * @param binaryKernelImpl A `SimpleBinaryKernelImpl` for the kernel.
 * @param binaryKernelComplexImpl Optional. If exists, represents a
 *     `ComplexBinaryKernelImpl` for the kernel, will be used when input dtype
 *     is `complex64`.
 * @param dtype Optional. If set, the result has this dtype. Otherwise, the
 *     result has the same dtype as the first input. This is mainly used in
 *     comparison kernels, such as Equal, Less, Greater, etc.
 */
function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {
    if (complexImpl == null) {
        return ({ inputs, backend }) => {
            const { a, b } = inputs;
            const cpuBackend = backend;
            (0,_cpu_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)([a, b], name);
            const aVals = cpuBackend.data.get(a.dataId).values;
            const bVals = cpuBackend.data.get(b.dataId).values;
            const $dtype = dtype || a.dtype;
            const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
        };
    }
    return ({ inputs, backend }) => {
        const { a, b } = inputs;
        const cpuBackend = backend;
        if (a.dtype === 'complex64' || b.dtype === 'complex64') {
            const $aComplex = (0,_kernels_Cast__WEBPACK_IMPORTED_MODULE_2__.cast)({ inputs: { x: a }, backend: cpuBackend, attrs: { dtype: 'complex64' } });
            const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
            const aReal = $aComplexVals.complexTensorInfos.real;
            const aImag = $aComplexVals.complexTensorInfos.imag;
            const aRealVals = cpuBackend.data.get(aReal.dataId).values;
            const aImagVals = cpuBackend.data.get(aImag.dataId).values;
            const $bComplex = (0,_kernels_Cast__WEBPACK_IMPORTED_MODULE_2__.cast)({ inputs: { x: b }, backend: cpuBackend, attrs: { dtype: 'complex64' } });
            const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
            const bReal = $bComplexVals.complexTensorInfos.real;
            const bImag = $bComplexVals.complexTensorInfos.imag;
            const bRealVals = cpuBackend.data.get(bReal.dataId).values;
            const bImagVals = cpuBackend.data.get(bImag.dataId).values;
            const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);
            const resultReal = cpuBackend.makeTensorInfo(resultShape, 'float32', resultRealData);
            const resultImag = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImagData);
            const result = (0,_kernels_Complex__WEBPACK_IMPORTED_MODULE_3__.complex)({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });
            cpuBackend.disposeIntermediateTensorInfo($aComplex);
            cpuBackend.disposeIntermediateTensorInfo($bComplex);
            cpuBackend.disposeIntermediateTensorInfo(resultReal);
            cpuBackend.disposeIntermediateTensorInfo(resultImag);
            return result;
        }
        else {
            const aVals = cpuBackend.data.get(a.dataId).values;
            const bVals = cpuBackend.data.get(b.dataId).values;
            const $dtype = dtype || a.dtype;
            const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
        }
    };
}
/**
 * Template that creates the complex type implementation for binary ops.
 * Supports broadcast.
 */
function createComplexBinaryKernelImpl(op) {
    return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {
        const resultShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(aShape, bShape);
        const resultSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(resultShape);
        const resultRank = resultShape.length;
        const resultStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(resultShape);
        const resultRealVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType('float32', resultSize);
        const resultImagVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType('float32', resultSize);
        const aBroadcastDims = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getBroadcastDims(aShape, resultShape);
        const bBroadcastDims = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getBroadcastDims(bShape, resultShape);
        const aVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.mergeRealAndImagArrays(aRealVals, aImagVals);
        const bVals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.mergeRealAndImagArrays(bRealVals, bImagVals);
        const aRank = aShape.length;
        const aStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(aShape);
        const bRank = bShape.length;
        const bStrides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(bShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
            for (let i = 0; i < resultRealVals.length; i++) {
                const aIdx = i % aVals.length;
                const bIdx = i % bVals.length;
                const result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
                resultRealVals[i] = result.real;
                resultImagVals[i] = result.imag;
            }
        }
        else {
            for (let i = 0; i < resultRealVals.length; i++) {
                const loc = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.indexToLoc(i, resultRank, resultStrides);
                const aLoc = loc.slice(-aRank);
                aBroadcastDims.forEach(d => aLoc[d] = 0);
                const aIndex = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.locToIndex(aLoc, aRank, aStrides);
                const bLoc = loc.slice(-bRank);
                bBroadcastDims.forEach(d => bLoc[d] = 0);
                const bIndex = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.locToIndex(bLoc, bRank, bStrides);
                const opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
                resultRealVals[i] = opResult.real;
                resultImagVals[i] = opResult.imag;
            }
        }
        return [resultRealVals, resultImagVals, resultShape];
    };
}
//# sourceMappingURL=binary_utils.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSimpleUnaryImpl": () => (/* binding */ createSimpleUnaryImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

/**
 * Template that creates implementation for unary op.
 */
function createSimpleUnaryImpl(op) {
    return (values, dtype, attrs) => {
        const newValues = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType(dtype, values.length);
        for (let i = 0; i < values.length; ++i) {
            newValues[i] = op(values[i], attrs);
        }
        return newValues;
    };
}
//# sourceMappingURL=unary_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unaryKernelFunc": () => (/* binding */ unaryKernelFunc),
/* harmony export */   "unaryKernelFuncFromImpl": () => (/* binding */ unaryKernelFuncFromImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cpu_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cpu_util */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


/**
 * Template that creates a `KernelFunc` for unary ops.
 * @param name Kernel name.
 * @param op A `SimpleUnaryOperation` for the kernel.
 * @param dtype Optional. If set, the result has this dtype. Otherwise, the
 *     result has the same dtype as the input. This is mainly used in certain
 *     kernels that return bool type, such as isFinite, isInf, etc.
 */
function unaryKernelFunc(name, op, dtype) {
    return ({ inputs, attrs, backend }) => {
        const { x } = inputs;
        (0,_cpu_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, name);
        if (x.dtype === 'string' || dtype === 'string') {
            throw new Error('unaryKernelFunc does not support string input/output');
        }
        const cpuBackend = backend;
        const values = cpuBackend.data.get(x.dataId).values;
        const xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape);
        const $dtype = dtype || x.dtype;
        const newValues = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getArrayFromDType($dtype, xSize);
        for (let i = 0; i < xSize; ++i) {
            newValues[i] = op(values[i], attrs);
        }
        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
    };
}
/**
 * Template that creates a `KernelFunc` for unary ops from the given
 * `SimpleUnaryImpl`..
 * @param name Kernel name.
 * @param unaryImpl A `SimpleUnaryImpl` that implements the op.
 * @param dtype Optional. If set, the result has this dtype. Otherwise, the
 *     result has the same dtype as the input. This is mainly used in certain
 *     kernels that return bool type, such as isFinite, isInf, etc.
 */
function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {
    return ({ inputs, attrs, backend }) => {
        const { x } = inputs;
        (0,_cpu_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, name);
        if (x.dtype === 'string' || dtype === 'string') {
            throw new Error('unaryKernelFunc does not support string input/output');
        }
        const cpuBackend = backend;
        const values = cpuBackend.data.get(x.dataId).values;
        const $dtype = dtype || x.dtype;
        const newValues = unaryImpl(values, $dtype, attrs);
        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
    };
}
//# sourceMappingURL=unary_utils.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zeros": () => (/* binding */ zeros)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernels_Complex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernels/Complex */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


/**
 * Generates a tensorInfo with all zeros value.
 * @param backend cpu backend.
 * @param shape Shape for the zeros tensor.
 * @param dtype Optional. If set, the result has this dtype.
 */
function zeros(backend, shape, dtype = 'float32') {
    if (dtype === 'complex64') {
        const real = zeros(backend, shape, 'float32');
        const imag = zeros(backend, shape, 'float32');
        return (0,_kernels_Complex__WEBPACK_IMPORTED_MODULE_1__.complex)({ inputs: { real, imag }, backend });
    }
    const values = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.makeZerosTypedArray(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(shape), dtype);
    return backend.makeTensorInfo(shape, dtype, values);
}
//# sourceMappingURL=zeros_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddNProgram": () => (/* binding */ AddNProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AddNProgram {
    constructor(outputShape, shapes) {
        this.outputShape = [];
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const snippets = [];
        // Get target elements from every input tensor.
        this.variableNames.forEach(variable => {
            snippets.push(`float v${variable} = get${variable}AtOutCoords();`);
        });
        // Calculate the sum of all elements.
        const operation = this.variableNames
            .map(variable => {
            return `v${variable}`;
        })
            .join(' + ');
        this.userCode = `
      void main() {
        ${snippets.join('\n        ')}

        float result = ${operation};
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=addn_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddNPackedProgram": () => (/* binding */ AddNPackedProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AddNPackedProgram {
    constructor(outputShape, shapes) {
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const snippets = [];
        // Get target elements from every input tensor.
        this.variableNames.forEach(variable => {
            snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);
        });
        // Calculate the sum of all elements.
        const operation = this.variableNames
            .map(variable => {
            return `v${variable}`;
        })
            .join(' + ');
        this.userCode = `
      void main() {
        ${snippets.join('\n        ')}

        vec4 result = ${operation};
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=addn_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArgMinMaxProgram": () => (/* binding */ ArgMinMaxProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ArgMinMaxProgram {
    constructor(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        const { windowSize, batchSize, outSize } = reduceInfo;
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        const compOp = (op === 'max') ? '>' : '<';
        const indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
}
//# sourceMappingURL=argminmax_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArgMinMaxPackedProgram": () => (/* binding */ ArgMinMaxPackedProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



class ArgMinMaxPackedProgram {
    constructor(shape, windowSize, op, firstPass) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(shape.length > 2, () => `Packed arg${op.charAt(0).toUpperCase() +
            op.slice(1)} supports only inputs with rank above 2.`);
        const inSize = shape[shape.length - 1];
        const outSize = Math.ceil(inSize / windowSize);
        this.outputShape = shape.slice(0, -1);
        if (outSize > 1) {
            this.outputShape.push(outSize);
        }
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        const outShape = this.outputShape;
        const rank = outShape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_1__.getCoordsDataType)(rank);
        const coords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_2__.getChannels)('coords', rank);
        let sourceLocSetup;
        let sourceRank;
        if (outSize === 1) {
            sourceRank = rank + 1;
            const sourceLocDType = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_1__.getCoordsDataType)(sourceRank);
            sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);
        ++${coords[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);
        ++${coords[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);
        --${coords[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);
        --${coords[rank - 2]};`;
        }
        else {
            sourceRank = rank;
            sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords[rank - 2]};`;
        }
        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);
        const inChannel = '.' + channels[sourceRank - 1]; // e.g. ".b" for rank 3.
        const intChannels = channels.map(x => 'int ' + x);
        const srcRCoords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_2__.getChannels)('sourceLocR', sourceRank - 1).concat('inIdx.r');
        const srcGCoords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_2__.getChannels)('sourceLocG', sourceRank - 1).concat('inIdx.g');
        const srcBCoords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_2__.getChannels)('sourceLocB', sourceRank - 1).concat('inIdx.b');
        const srcACoords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_2__.getChannels)('sourceLocA', sourceRank - 1).concat('inIdx.a');
        const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';
        const fetchCandidateIdx = firstPass ? '' : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
        const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
        const getBestIndicesAChannelSnippet = firstPass ? '' : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
        this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
}
//# sourceMappingURL=argminmax_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AvgPool2DBackpropProgram": () => (/* binding */ AvgPool2DBackpropProgram),
/* harmony export */   "AvgPool3DBackpropProgram": () => (/* binding */ AvgPool3DBackpropProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AvgPool2DBackpropProgram {
    constructor(convInfo) {
        this.variableNames = ['dy'];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class AvgPool3DBackpropProgram {
    constructor(convInfo) {
        this.variableNames = ['dy'];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
//# sourceMappingURL=avg_pool_backprop_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPSILON_FLOAT32": () => (/* binding */ EPSILON_FLOAT32),
/* harmony export */   "EPSILON_FLOAT16": () => (/* binding */ EPSILON_FLOAT16),
/* harmony export */   "getBinaryCache": () => (/* binding */ getBinaryCache),
/* harmony export */   "MathBackendWebGL": () => (/* binding */ MathBackendWebGL)
/* harmony export */ });
/* harmony import */ var _flags_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flags_webgl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js");
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _canvas_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js");
/* harmony import */ var _decode_matrix_gpu__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./decode_matrix_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js");
/* harmony import */ var _decode_matrix_packed_gpu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./decode_matrix_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js");
/* harmony import */ var _encode_float_gpu__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./encode_float_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js");
/* harmony import */ var _encode_float_packed_gpu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./encode_float_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js");
/* harmony import */ var _encode_matrix_gpu__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./encode_matrix_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js");
/* harmony import */ var _encode_matrix_packed_gpu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./encode_matrix_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js");
/* harmony import */ var _gpgpu_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gpgpu_context */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js");
/* harmony import */ var _gpgpu_math__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./gpgpu_math */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _pack_gpu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pack_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js");
/* harmony import */ var _reshape_packed_gpu__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./reshape_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/* harmony import */ var _texture_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./texture_manager */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/* harmony import */ var _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./unaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js");
/* harmony import */ var _unpack_gpu__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./unpack_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Import webgl flags.






















const whereImpl = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.kernel_impls.whereImpl;
const EPSILON_FLOAT32 = 1e-7;
const EPSILON_FLOAT16 = 1e-4;
const binaryCaches = {};
function getBinaryCache(webGLVersion) {
    if (webGLVersion in binaryCaches) {
        return binaryCaches[webGLVersion];
    }
    binaryCaches[webGLVersion] = {};
    return binaryCaches[webGLVersion];
}
// Empirically determined constant used to determine size threshold for handing
// off execution to the CPU.
const CPU_HANDOFF_SIZE_THRESHOLD = 128;
// Empirically determined constant used to decide the number of MB on GPU
// before we warn about high memory use. The MB are this constant * screen area
// * dpi / 1024 / 1024.
const BEFORE_PAGING_CONSTANT = 600;
function numMBBeforeWarning() {
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().global.screen == null) {
        return 1024; // 1 GB.
    }
    return ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().global.screen.height * (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().global.screen.width *
        window.devicePixelRatio) *
        BEFORE_PAGING_CONSTANT / 1024 / 1024;
}
class MathBackendWebGL extends _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.KernelBackend {
    constructor(gpgpu) {
        super();
        // Maps data ids that have a pending read operation, to list of subscribers.
        this.pendingRead = new WeakMap();
        // List of data ids that are scheduled for disposal, but are waiting on a
        // pending read operation.
        this.pendingDisposal = new WeakSet();
        // Used to count the number of 'shallow' sliced tensors that point to the
        // same data id.
        this.dataRefCount = new WeakMap();
        this.numBytesInGPU = 0;
        // Accumulated time spent (including blocking) in uploading data to webgl.
        this.uploadWaitMs = 0;
        // Accumulated time spent (including blocking in downloading data from webgl.
        this.downloadWaitMs = 0;
        this.warnedAboutMemory = false;
        this.warnedAboutCPUBackend = false;
        this.pendingDeletes = 0;
        this.disposed = false;
        if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('HAS_WEBGL')) {
            throw new Error('WebGL is not supported on this device');
        }
        if (gpgpu == null) {
            const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_2__.getWebGLContext)((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_VERSION'));
            this.binaryCache = getBinaryCache((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_VERSION'));
            this.gpgpu = new _gpgpu_context__WEBPACK_IMPORTED_MODULE_3__.GPGPUContext(gl);
            this.canvas = gl.canvas;
            this.gpgpuCreatedLocally = true;
        }
        else {
            this.gpgpu = gpgpu;
            this.binaryCache = {};
            this.gpgpuCreatedLocally = false;
            this.canvas = gpgpu.gl.canvas;
        }
        this.textureManager = new _texture_manager__WEBPACK_IMPORTED_MODULE_4__.TextureManager(this.gpgpu);
        this.numMBBeforeWarning = numMBBeforeWarning();
        this.texData = new _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.DataStorage(this, (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.engine)());
    }
    numDataIds() {
        return this.texData.numDataIds() +
            (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) -
            this.pendingDeletes;
    }
    write(values, shape, dtype) {
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||
            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('DEBUG')) {
            this.checkNumericalProblems(values);
        }
        if (dtype === 'complex64' && values != null) {
            throw new Error(`Cannot write to a complex64 dtype. ` +
                `Please use tf.complex(real, imag).`);
        }
        const dataId = {};
        this.texData.set(dataId, {
            shape,
            dtype,
            values,
            usage: _tex_util__WEBPACK_IMPORTED_MODULE_5__.TextureUsage.UPLOAD,
            refCount: 1,
            complexParentRefCount: 0
        });
        return dataId;
    }
    /** Increase refCount of a `TextureData`. */
    incRef(dataId) {
        const texData = this.texData.get(dataId);
        texData.refCount++;
    }
    /** Decrease refCount of a `TextureData`. */
    decRef(dataId) {
        if (this.texData.has(dataId)) {
            const texData = this.texData.get(dataId);
            texData.refCount--;
        }
    }
    /**
     * Decrease refCount of a `TextureData` if it is a component of complex
     * tensor.
     */
    decComplexRef(dataId) {
        if (this.texData.has(dataId)) {
            const texData = this.texData.get(dataId);
            if (texData.complexParentRefCount > 0) {
                texData.refCount--;
            }
        }
    }
    move(dataId, values, shape, dtype) {
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('DEBUG')) {
            this.checkNumericalProblems(values);
        }
        if (dtype === 'complex64') {
            throw new Error(`Cannot write to a complex64 dtype. ` +
                `Please use tf.complex(real, imag).`);
        }
        this.texData.set(dataId, {
            shape,
            dtype,
            values,
            usage: _tex_util__WEBPACK_IMPORTED_MODULE_5__.TextureUsage.UPLOAD,
            refCount: 1,
            complexParentRefCount: 0
        });
    }
    disposeIntermediateTensorInfo(tensorInfo) {
        const dataId = tensorInfo.dataId;
        if (this.texData.has(dataId)) {
            const textureData = this.texData.get(dataId);
            textureData.refCount--;
            if (textureData.refCount < 1) {
                this.disposeData(dataId);
            }
        }
    }
    readSync(dataId) {
        const texData = this.texData.get(dataId);
        const { values, dtype, complexTensorInfos, slice, shape, isPacked } = texData;
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) {
                program = new _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_6__.UnaryOpPackedProgram(shape, _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.CLONE);
            }
            else {
                program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.UnaryOpProgram(shape, _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.CLONE);
            }
            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
            const data = this.readSync(res.dataId);
            this.disposeIntermediateTensorInfo(res);
            return data;
        }
        if (values != null) {
            return this.convertAndCacheOnCPU(dataId);
        }
        if (dtype === 'string') {
            return values;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
            start = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.now();
        }
        let result;
        if (dtype === 'complex64') {
            const realValues = this.readSync(complexTensorInfos.real.dataId);
            const imagValues = this.readSync(complexTensorInfos.imag.dataId);
            result = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.backend_util.mergeRealAndImagArrays(realValues, imagValues);
        }
        else {
            result = this.getValuesFromTexture(dataId);
        }
        if (shouldTimeProgram) {
            this.downloadWaitMs += _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.now() - start;
        }
        return this.convertAndCacheOnCPU(dataId, result);
    }
    async read(dataId) {
        if (this.pendingRead.has(dataId)) {
            const subscribers = this.pendingRead.get(dataId);
            return new Promise(resolve => subscribers.push(resolve));
        }
        const texData = this.texData.get(dataId);
        const { values, shape, slice, dtype, complexTensorInfos, isPacked } = texData;
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) {
                program = new _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_6__.UnaryOpPackedProgram(shape, _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.CLONE);
            }
            else {
                program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.UnaryOpProgram(shape, _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.CLONE);
            }
            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
            const data = this.read(res.dataId);
            this.disposeIntermediateTensorInfo(res);
            return data;
        }
        if (values != null) {
            return this.convertAndCacheOnCPU(dataId);
        }
        if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&
            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_VERSION') === 2) {
            throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +
                `WEBGL_VERSION=2 not yet supported.`);
        }
        let buffer = null;
        let tmpDownloadTarget;
        if (dtype !== 'complex64' && (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().get('WEBGL_BUFFER_SUPPORTED')) {
            // Possibly copy the texture into a buffer before inserting a fence.
            tmpDownloadTarget = this.decode(dataId);
            const tmpData = this.texData.get(tmpDownloadTarget.dataId);
            buffer = this.gpgpu.createBufferFromTexture(tmpData.texture, ..._tex_util__WEBPACK_IMPORTED_MODULE_5__.getDenseTexShape(shape));
        }
        this.pendingRead.set(dataId, []);
        if (dtype !== 'complex64') {
            // Create a fence and wait for it to resolve.
            await this.gpgpu.createAndWaitForFence();
        }
        // Download the values from the GPU.
        let vals;
        if (dtype === 'complex64') {
            const ps = await Promise.all([
                this.read(complexTensorInfos.real.dataId),
                this.read(complexTensorInfos.imag.dataId)
            ]);
            const realValues = ps[0];
            const imagValues = ps[1];
            vals = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.backend_util.mergeRealAndImagArrays(realValues, imagValues);
        }
        else if (buffer == null) {
            vals = this.getValuesFromTexture(dataId);
        }
        else {
            const size = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.sizeFromShape(shape);
            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);
        }
        if (tmpDownloadTarget != null) {
            this.disposeIntermediateTensorInfo(tmpDownloadTarget);
        }
        const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
        const subscribers = this.pendingRead.get(dataId);
        this.pendingRead.delete(dataId);
        // Notify all pending reads.
        subscribers.forEach(resolve => resolve(dTypeVals));
        if (this.pendingDisposal.has(dataId)) {
            this.pendingDisposal.delete(dataId);
            this.disposeData(dataId);
            this.pendingDeletes--;
        }
        return dTypeVals;
    }
    bufferSync(t) {
        const data = this.readSync(t.dataId);
        let decodedData = data;
        if (t.dtype === 'string') {
            try {
                // Decode the bytes into string.
                decodedData = data.map(d => _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.decodeString(d));
            }
            catch (_a) {
                throw new Error('Failed to decode encoded string bytes into utf-8');
            }
        }
        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.buffer)(t.shape, t.dtype, decodedData);
    }
    checkNumericalProblems(values) {
        if (values == null) {
            return;
        }
        for (let i = 0; i < values.length; i++) {
            const num = values[i];
            if (!_webgl_util__WEBPACK_IMPORTED_MODULE_8__.canBeRepresented(num)) {
                if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {
                    throw Error(`The value ${num} cannot be represented with your ` +
                        `current settings. Consider enabling float32 rendering: ` +
                        `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
                }
                throw Error(`The value ${num} cannot be represented on this device.`);
            }
        }
    }
    getValuesFromTexture(dataId) {
        const { shape, dtype, isPacked } = this.texData.get(dataId);
        const size = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.sizeFromShape(shape);
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {
            const tmpTarget = this.decode(dataId);
            const tmpData = this.texData.get(tmpTarget.dataId);
            const vals = this.gpgpu
                .downloadMatrixFromPackedTexture(tmpData.texture, ..._tex_util__WEBPACK_IMPORTED_MODULE_5__.getDenseTexShape(shape))
                .subarray(0, size);
            this.disposeIntermediateTensorInfo(tmpTarget);
            return vals;
        }
        const shouldUsePackedProgram = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_PACK') && isPacked === true;
        const outputShape = shouldUsePackedProgram ? _webgl_util__WEBPACK_IMPORTED_MODULE_8__.getShapeAs3D(shape) : shape;
        const program = shouldUsePackedProgram ?
            new _encode_float_packed_gpu__WEBPACK_IMPORTED_MODULE_9__.EncodeFloatPackedProgram(outputShape) :
            new _encode_float_gpu__WEBPACK_IMPORTED_MODULE_10__.EncodeFloatProgram(outputShape);
        const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], 'float32');
        const tmpData = this.texData.get(output.dataId);
        const vals = this.gpgpu
            .downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])
            .subarray(0, size);
        this.disposeIntermediateTensorInfo(output);
        return vals;
    }
    async time(f) {
        const oldActiveTimers = this.activeTimers;
        const newActiveTimers = [];
        let outerMostTime = false;
        if (this.programTimersStack == null) {
            this.programTimersStack = newActiveTimers;
            outerMostTime = true;
        }
        else {
            this.activeTimers.push(newActiveTimers);
        }
        this.activeTimers = newActiveTimers;
        f();
        // needing to split these up because util.flatten only accepts certain types
        const flattenedActiveTimerQueries = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.flatten(this.activeTimers.map((d) => d.query))
            .filter(d => d != null);
        const flattenedActiveTimerNames = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.flatten(this.activeTimers.map((d) => d.name))
            .filter(d => d != null);
        this.activeTimers = oldActiveTimers;
        if (outerMostTime) {
            this.programTimersStack = null;
        }
        const res = {
            uploadWaitMs: this.uploadWaitMs,
            downloadWaitMs: this.downloadWaitMs,
            kernelMs: null,
            wallMs: null // will be filled by the engine
        };
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            const kernelMs = await Promise.all(flattenedActiveTimerQueries);
            res['kernelMs'] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.sum(kernelMs);
            res['getExtraProfileInfo'] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d }))
                .map(d => `${d.name}: ${d.ms}`)
                .join(', ');
        }
        else {
            res['kernelMs'] = {
                error: 'WebGL query timers are not supported in this environment.'
            };
        }
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        return res;
    }
    memory() {
        return {
            unreliable: false,
            numBytesInGPU: this.numBytesInGPU,
            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
            numBytesInGPUFree: this.textureManager.numBytesFree
        };
    }
    startTimer() {
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            return this.gpgpu.beginQuery();
        }
        return { startMs: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.now(), endMs: null };
    }
    endTimer(query) {
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            this.gpgpu.endQuery();
            return query;
        }
        query.endMs = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.now();
        return query;
    }
    async getQueryTime(query) {
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            return this.gpgpu.waitForQueryAndGetTime(query);
        }
        const timerQuery = query;
        return timerQuery.endMs - timerQuery.startMs;
    }
    disposeData(dataId) {
        if (this.pendingDisposal.has(dataId)) {
            return;
        }
        if (this.pendingRead.has(dataId)) {
            this.pendingDisposal.add(dataId);
            this.pendingDeletes++;
            return;
        }
        // No-op if already disposed.
        if (!this.texData.has(dataId)) {
            return;
        }
        // Trying to dispose a textureData that has a 'kept' refCount, e.g. trying
        // to dispose a tensor whose data bucket is shared with a complex tensor. In
        // this case we are removing a reference to the textureData, but we
        // shouldn't actually dispose the texture.
        if (this.texData.get(dataId).complexParentRefCount > 0) {
            this.texData.get(dataId).refCount--;
            return;
        }
        this.releaseGPUData(dataId);
        const { complexTensorInfos } = this.texData.get(dataId);
        if (complexTensorInfos != null) {
            this.texData.get(complexTensorInfos.real.dataId).complexParentRefCount--;
            this.disposeIntermediateTensorInfo(complexTensorInfos.real);
            this.texData.get(complexTensorInfos.imag.dataId).complexParentRefCount--;
            this.disposeIntermediateTensorInfo(complexTensorInfos.imag);
        }
        this.texData.delete(dataId);
    }
    releaseGPUData(dataId) {
        const { texture, dtype, texShape, usage, isPacked, slice } = this.texData.get(dataId);
        const key = slice && slice.origDataId || dataId;
        const refCount = this.dataRefCount.get(key);
        if (refCount > 1) {
            this.dataRefCount.set(key, refCount - 1);
        }
        else {
            this.dataRefCount.delete(key);
            if (texture != null) {
                this.numBytesInGPU -= this.computeBytes(texShape, dtype);
                this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
            }
        }
        const texData = this.texData.get(dataId);
        texData.texture = null;
        texData.texShape = null;
        texData.isPacked = false;
        texData.slice = null;
    }
    getTexture(dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture;
    }
    /**
     * Returns internal information for the specific data bucket. Used in unit
     * tests.
     */
    getDataInfo(dataId) {
        return this.texData.get(dataId);
    }
    getCPUBackend() {
        if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_CPU_FORWARD')) {
            return null;
        }
        if (this.cpuBackend == null) {
            this.cpuBackend = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.engine)().findBackend('cpu');
        }
        return this.cpuBackend;
    }
    /*
    Tests whether all the inputs to an op are small and on the CPU. This heuristic
    determines when it would be faster to execute a kernel on the CPU. WebGL
    kernels opt into running this check and forwarding when appropriate.
    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more
    sustainable strategy for optimizing backend execution of ops.
     */
    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
        const cpuBackend = this.getCPUBackend();
        if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('IS_TEST') && !this.warnedAboutCPUBackend &&
            cpuBackend == null) {
            console.warn('Your application contains ops that are small enough to be ' +
                'executed on the CPU backend, however the CPU backend cannot ' +
                'be found. Consider importing the CPU backend ' +
                '(@tensorflow/tfjs-backend-cpu) for better performance.');
            this.warnedAboutCPUBackend = true;
        }
        return cpuBackend != null &&
            inputs.every(input => this.texData.get(input.dataId).texture == null &&
                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.sizeFromShape(input.shape) < sizeThreshold);
    }
    getGPGPUContext() {
        return this.gpgpu;
    }
    where(condition) {
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.backend_util.warn('tf.where() in webgl locks the UI thread. ' +
            'Call tf.whereAsync() instead');
        const condVals = condition.dataSync();
        return whereImpl(condition.shape, condVals);
    }
    packedUnaryOp(x, op, dtype) {
        const program = new _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_6__.UnaryOpPackedProgram(x.shape, op);
        return this.compileAndRun(program, [x], dtype);
    }
    // TODO(msoulanille) remove this once the backend has been modularized
    // a copy is needed here to break a circular dependency.
    // Also remove the op from unary_op.
    abs(x) {
        // TODO: handle cases when x is complex.
        if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {
            const outValues = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_11__.simpleAbsImplCPU)(this.texData.get(x.dataId).values);
            return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {
            return this.packedUnaryOp(x, _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.ABS, x.dtype);
        }
        const program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.UnaryOpProgram(x.shape, _unaryop_gpu__WEBPACK_IMPORTED_MODULE_7__.ABS);
        return this.compileAndRun(program, [x]);
    }
    makeTensorInfo(shape, dtype, values) {
        let dataId;
        if (dtype === 'string' && values != null && values.length > 0 &&
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.isString(values[0])) {
            const encodedValues = values.map(d => _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.encodeString(d));
            dataId = this.write(encodedValues, shape, dtype);
        }
        else {
            dataId = this.write(values, shape, dtype);
        }
        this.texData.get(dataId).usage = null;
        return { dataId, shape, dtype };
    }
    makeOutput(shape, dtype, values) {
        const { dataId } = this.makeTensorInfo(shape, dtype, values);
        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.engine)().makeTensorFromDataId(dataId, shape, dtype, this);
    }
    unpackTensor(input) {
        const program = new _unpack_gpu__WEBPACK_IMPORTED_MODULE_12__.UnpackProgram(input.shape);
        return this.runWebGLProgram(program, [input], input.dtype);
    }
    packTensor(input) {
        const program = new _pack_gpu__WEBPACK_IMPORTED_MODULE_13__.PackProgram(input.shape);
        const preventEagerUnpackingOutput = true;
        return this.runWebGLProgram(program, [input], input.dtype, null /* customSetup */, preventEagerUnpackingOutput);
    }
    packedReshape(input, afterShape) {
        const input3DShape = [
            _webgl_util__WEBPACK_IMPORTED_MODULE_8__.getBatchDim(input.shape),
            ..._webgl_util__WEBPACK_IMPORTED_MODULE_8__.getRowsCols(input.shape)
        ];
        const input3D = {
            dtype: input.dtype,
            shape: input3DShape,
            dataId: input.dataId
        };
        const afterShapeAs3D = [
            _webgl_util__WEBPACK_IMPORTED_MODULE_8__.getBatchDim(afterShape), ..._webgl_util__WEBPACK_IMPORTED_MODULE_8__.getRowsCols(afterShape)
        ];
        const program = new _reshape_packed_gpu__WEBPACK_IMPORTED_MODULE_14__.ReshapePackedProgram(afterShapeAs3D, input3DShape);
        const preventEagerUnpackingOfOutput = true;
        const output = this.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);
        return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
    }
    decode(dataId) {
        const texData = this.texData.get(dataId);
        const { isPacked, shape, dtype } = texData;
        const shapeAs3D = _webgl_util__WEBPACK_IMPORTED_MODULE_8__.getShapeAs3D(shape);
        let program;
        if (isPacked) {
            program = new _decode_matrix_packed_gpu__WEBPACK_IMPORTED_MODULE_15__.DecodeMatrixPackedProgram(shapeAs3D);
        }
        else {
            program = new _decode_matrix_gpu__WEBPACK_IMPORTED_MODULE_16__.DecodeMatrixProgram(shapeAs3D);
        }
        const preventEagerUnpackingOfOutput = true;
        const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, null /* customSetup */, preventEagerUnpackingOfOutput);
        return { dtype, shape, dataId: out.dataId };
    }
    runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {
        const output = this.makeTensorInfo(program.outputShape, outputDtype);
        const outData = this.texData.get(output.dataId);
        if (program.packedOutput) {
            outData.isPacked = true;
        }
        if (program.outPackingScheme === _tex_util__WEBPACK_IMPORTED_MODULE_5__.PackingScheme.DENSE) {
            const texelShape = _tex_util__WEBPACK_IMPORTED_MODULE_5__.getDenseTexShape(program.outputShape);
            // For a densely packed output, we explicitly set texShape
            // so it doesn't get assigned later according to our typical packing
            // scheme wherein a single texel can only contain values from adjacent
            // rows/cols.
            outData.texShape = texelShape.map(d => d * 2);
        }
        if (program.outTexUsage != null) {
            outData.usage = program.outTexUsage;
        }
        if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.sizeFromShape(output.shape) === 0) {
            // Short-circuit the computation since the result is empty (has 0 in its
            // shape).
            outData.values =
                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.getTypedArrayFromDType(output.dtype, 0);
            return output;
        }
        const dataToDispose = [];
        const inputsData = inputs.map(input => {
            if (input.dtype === 'complex64') {
                throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` +
                    `dtypes, please separate the program into real and imaginary ` +
                    `parts.`);
            }
            let texData = this.texData.get(input.dataId);
            if (texData.texture == null) {
                if (!program.packedInputs &&
                    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.sizeFromShape(input.shape) <=
                        (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {
                    // Upload small tensors that live on the CPU as uniforms, not as
                    // textures. Do this only when the environment supports 32bit floats
                    // due to problems when comparing 16bit floats with 32bit floats.
                    // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it
                    // possible for packed shaders to sample from uniforms.
                    return {
                        shape: input.shape,
                        texData: null,
                        isUniform: true,
                        uniformValues: texData.values
                    };
                }
                // This ensures that if a packed program's inputs have not yet been
                // uploaded to the GPU, they get uploaded as packed right off the bat.
                if (program.packedInputs) {
                    texData.isPacked = true;
                    texData.shape = input.shape;
                }
            }
            else if (!!texData.isPacked !== !!program.packedInputs) {
                input = texData.isPacked ? this.unpackTensor(input) :
                    this.packTensor(input);
                dataToDispose.push(input);
                texData = this.texData.get(input.dataId);
            }
            else if (texData.isPacked &&
                !_webgl_util__WEBPACK_IMPORTED_MODULE_8__.isReshapeFree(texData.shape, input.shape)) {
                // This is a special case where a texture exists for a tensor
                // but the shapes are incompatible (due to packing constraints) because
                // the tensor did not have a chance to go through the packed reshape
                // shader. This only happens when we reshape the *same* tensor to form
                // *distinct* inputs to an op, e.g. dotting a vector with itself. This
                // case will disappear once packed uploading is the default.
                const savedInput = input;
                const targetShape = input.shape;
                input.shape = texData.shape;
                input = this.packedReshape(input, targetShape);
                dataToDispose.push(input);
                texData = this.texData.get(input.dataId);
                savedInput.shape = targetShape;
            }
            this.uploadToGPU(input.dataId);
            return { shape: input.shape, texData, isUniform: false };
        });
        this.uploadToGPU(output.dataId);
        const outputData = { shape: output.shape, texData: outData, isUniform: false };
        const key = _gpgpu_math__WEBPACK_IMPORTED_MODULE_17__.makeShaderKey(program, inputsData, outputData);
        const binary = this.getAndSaveBinary(key, () => {
            return _gpgpu_math__WEBPACK_IMPORTED_MODULE_17__.compileProgram(this.gpgpu, program, inputsData, outputData);
        });
        const shouldTimeProgram = this.activeTimers != null;
        let query;
        if (shouldTimeProgram) {
            query = this.startTimer();
        }
        _gpgpu_math__WEBPACK_IMPORTED_MODULE_17__.runProgram(this.gpgpu, binary, inputsData, outputData, customSetup);
        dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));
        if (shouldTimeProgram) {
            query = this.endTimer(query);
            this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
        }
        if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&
            preventEagerUnpackingOfOutput === false) {
            const unpacked = this.unpackTensor(output);
            this.disposeIntermediateTensorInfo(output);
            return unpacked;
        }
        return output;
    }
    compileAndRun(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {
        outputDtype = outputDtype || inputs[0].dtype;
        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput);
        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.engine)().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
    }
    getAndSaveBinary(key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    }
    getTextureManager() {
        return this.textureManager;
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        // Avoid disposing the compiled webgl programs during unit testing because
        // it slows down test execution.
        if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('IS_TEST')) {
            const allKeys = Object.keys(this.binaryCache);
            allKeys.forEach(key => {
                this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
                delete this.binaryCache[key];
            });
        }
        this.textureManager.dispose();
        if (this.canvas != null &&
            (typeof (HTMLCanvasElement) !== 'undefined' &&
                this.canvas instanceof HTMLCanvasElement)) {
            this.canvas.remove();
        }
        else {
            this.canvas = null;
        }
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.program = null;
            this.gpgpu.dispose();
        }
        this.disposed = true;
    }
    floatPrecision() {
        if (this.floatPrecisionValue == null) {
            this.floatPrecisionValue = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy)(() => {
                if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().get('WEBGL_RENDER_FLOAT32_ENABLED')) {
                    // Momentarily switching DEBUG flag to false so we don't throw an
                    // error trying to upload a small value.
                    const debugFlag = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().getBool('DEBUG');
                    (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().set('DEBUG', false);
                    const underflowCheckValue = this.abs((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.scalar)(1e-8)).dataSync()[0];
                    (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.env)().set('DEBUG', debugFlag);
                    if (underflowCheckValue > 0) {
                        return 32;
                    }
                }
                return 16;
            });
        }
        return this.floatPrecisionValue;
    }
    /** Returns the smallest representable number.  */
    epsilon() {
        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
    }
    uploadToGPU(dataId) {
        const texData = this.texData.get(dataId);
        const { shape, dtype, values, texture, usage, isPacked } = texData;
        if (texture != null) {
            // Array is already on GPU. No-op.
            return;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
            start = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.now();
        }
        let texShape = texData.texShape;
        if (texShape == null) {
            texShape = _webgl_util__WEBPACK_IMPORTED_MODULE_8__.getTextureShapeFromLogicalShape(shape, isPacked);
            texData.texShape = texShape;
        }
        if (values != null) {
            const shapeAs3D = _webgl_util__WEBPACK_IMPORTED_MODULE_8__.getShapeAs3D(shape);
            let program;
            let width = texShape[1], height = texShape[0];
            const isByteArray = values instanceof Uint8Array;
            if (isPacked) {
                [width, height] = _tex_util__WEBPACK_IMPORTED_MODULE_5__.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
                program = new _encode_matrix_packed_gpu__WEBPACK_IMPORTED_MODULE_18__.EncodeMatrixPackedProgram(shapeAs3D, [height, width], isByteArray);
            }
            else {
                program =
                    new _encode_matrix_gpu__WEBPACK_IMPORTED_MODULE_19__.EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);
            }
            const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);
            if (isByteArray) {
                this.texData.get(tempDenseInputHandle.dataId).usage =
                    _tex_util__WEBPACK_IMPORTED_MODULE_5__.TextureUsage.PIXELS;
            }
            else {
                this.texData.get(tempDenseInputHandle.dataId).usage =
                    _tex_util__WEBPACK_IMPORTED_MODULE_5__.TextureUsage.UPLOAD;
            }
            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
            // We want the output to remain packed regardless of the value of
            // WEBGL_PACK.
            const preventEagerUnpacking = true;
            const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);
            // Have the original texture assume the identity of the encoded output.
            const outputTexData = this.texData.get(encodedOutputTarget.dataId);
            texData.texture = outputTexData.texture;
            texData.texShape = outputTexData.texShape;
            texData.isPacked = outputTexData.isPacked;
            texData.usage = outputTexData.usage;
            this.disposeIntermediateTensorInfo(tempDenseInputHandle);
            this.texData.delete(encodedOutputTarget.dataId);
            // Once uploaded, don't store the values on cpu.
            texData.values = null;
            if (shouldTimeProgram) {
                this.uploadWaitMs += _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.now() - start;
            }
        }
        else {
            const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
            texData.texture = newTexture;
        }
    }
    convertAndCacheOnCPU(dataId, float32Values) {
        const texData = this.texData.get(dataId);
        const { dtype } = texData;
        this.releaseGPUData(dataId);
        if (float32Values != null) {
            texData.values = float32ToTypedArray(float32Values, dtype);
        }
        return texData.values;
    }
    acquireTexture(texShape, texType, dtype, isPacked) {
        this.numBytesInGPU += this.computeBytes(texShape, dtype);
        if (!this.warnedAboutMemory &&
            this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
            const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
            this.warnedAboutMemory = true;
            console.warn(`High memory usage in GPU: ${mb} MB, ` +
                `most likely due to a memory leak`);
        }
        return this.textureManager.acquireTexture(texShape, texType, isPacked);
    }
    computeBytes(shape, dtype) {
        return shape[0] * shape[1] * _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.bytesPerElement(dtype);
    }
}
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32' || dtype === 'complex64') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        const result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (let i = 0; i < result.length; ++i) {
            result[i] = Math.round(a[i]);
        }
        return result;
    }
    else {
        throw new Error(`Unknown dtype ${dtype}`);
    }
}
//# sourceMappingURL=backend_webgl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version_webgl": () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_1__.version),
/* harmony export */   "GPGPUContext": () => (/* reexport safe */ _webgl__WEBPACK_IMPORTED_MODULE_3__.GPGPUContext),
/* harmony export */   "MathBackendWebGL": () => (/* reexport safe */ _webgl__WEBPACK_IMPORTED_MODULE_3__.MathBackendWebGL),
/* harmony export */   "forceHalfFloat": () => (/* reexport safe */ _webgl__WEBPACK_IMPORTED_MODULE_3__.forceHalfFloat),
/* harmony export */   "gpgpu_util": () => (/* reexport safe */ _webgl__WEBPACK_IMPORTED_MODULE_3__.gpgpu_util),
/* harmony export */   "setWebGLContext": () => (/* reexport safe */ _webgl__WEBPACK_IMPORTED_MODULE_3__.setWebGLContext),
/* harmony export */   "webgl_util": () => (/* reexport safe */ _webgl__WEBPACK_IMPORTED_MODULE_3__.webgl_util),
/* harmony export */   "webgl": () => (/* binding */ webgl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _backend_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./backend_webgl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/version.js");
/* harmony import */ var _webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl.js");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// base.ts is the webgl backend without auto kernel registration.



if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.device_util.isBrowser()) {
    (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.registerBackend)('webgl', () => new _backend_webgl__WEBPACK_IMPORTED_MODULE_2__.MathBackendWebGL(), 2 /* priority */);
}
// Export webgl utilities

// Export forceHalfFlost under webgl namespace for the union bundle.

const webgl = { forceHalfFloat: _webgl__WEBPACK_IMPORTED_MODULE_3__.forceHalfFloat };
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchNormProgram": () => (/* binding */ BatchNormProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class BatchNormProgram {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.variableNames = ['x', 'mean', 'variance'];
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, meanShape);
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, varianceShape);
        let offsetSnippet = '0.0';
        if (offsetShape != null) {
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        let scaleSnippet = '1.0';
        if (scaleShape != null) {
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
}
//# sourceMappingURL=batchnorm_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchNormPackedProgram": () => (/* binding */ BatchNormPackedProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class BatchNormPackedProgram {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.packedInputs = true;
        this.packedOutput = true;
        this.variableNames = ['x', 'mean', 'variance'];
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, meanShape);
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, varianceShape);
        let offsetSnippet = 'vec4(0.0)';
        if (offsetShape != null) {
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        let scaleSnippet = 'vec4(1.0)';
        if (scaleShape != null) {
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
}
//# sourceMappingURL=batchnorm_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "COMPLEX_MULTIPLY": () => (/* binding */ COMPLEX_MULTIPLY),
/* harmony export */   "BinaryOpComplexProgram": () => (/* binding */ BinaryOpComplexProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

// (Ar + Ai)(Br + Bi) =
// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr
// Yr = ArBr - AB
// Yi = ArBi + AiBr
const COMPLEX_MULTIPLY = {
    REAL: 'return areal * breal - aimag * bimag;',
    IMAG: 'return areal * bimag + aimag * breal;'
};
class BinaryOpComplexProgram {
    constructor(op, aShape, bShape) {
        this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];
        this.outputShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
}
//# sourceMappingURL=binaryop_complex_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CHECK_NAN_SNIPPET": () => (/* binding */ CHECK_NAN_SNIPPET),
/* harmony export */   "SQUARED_DIFFERENCE": () => (/* binding */ SQUARED_DIFFERENCE),
/* harmony export */   "BinaryOpProgram": () => (/* binding */ BinaryOpProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

const CHECK_NAN_SNIPPET = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';
class BinaryOpProgram {
    constructor(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.outputShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = `
      float binaryOperation(float a, float b) {
        ${op}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
}
//# sourceMappingURL=binaryop_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CHECK_NAN_SNIPPET": () => (/* binding */ CHECK_NAN_SNIPPET),
/* harmony export */   "ELU_DER": () => (/* binding */ ELU_DER),
/* harmony export */   "NOT_EQUAL": () => (/* binding */ NOT_EQUAL),
/* harmony export */   "BinaryOpPackedProgram": () => (/* binding */ BinaryOpPackedProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const CHECK_NAN_SNIPPET = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
const ELU_DER = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
const NOT_EQUAL = `
  return vec4(notEqual(a, b));
`;
class BinaryOpPackedProgram {
    constructor(op, aShape, bShape, checkOutOfBounds = false) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAndGetBroadcastShape(aShape, bShape);
        const rank = this.outputShape.length;
        let checkOutOfBoundsString = '';
        if (checkOutOfBounds) {
            if (rank === 0 || _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(this.outputShape) === 1) {
                checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
            }
            else {
                const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_1__.getCoordsDataType)(rank);
                checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
                if (rank === 1) {
                    checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
                }
                else {
                    const channels = (0,_packing_util__WEBPACK_IMPORTED_MODULE_2__.getChannels)('coords', rank);
                    checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
                }
            }
        }
        this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=binaryop_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearWebGLContext": () => (/* binding */ clearWebGLContext),
/* harmony export */   "setWebGLContext": () => (/* binding */ setWebGLContext),
/* harmony export */   "getWebGLContext": () => (/* binding */ getWebGLContext)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const contexts = {};
const WEBGL_ATTRIBUTES = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
};
function clearWebGLContext(webGLVersion) {
    delete contexts[webGLVersion];
}
function setWebGLContext(webGLVersion, gl) {
    contexts[webGLVersion] = gl;
}
function getWebGLContext(webGLVersion) {
    if (!(webGLVersion in contexts)) {
        const newCtx = getWebGLRenderingContext(webGLVersion);
        if (newCtx !== null) {
            contexts[webGLVersion] = newCtx;
        }
        else {
            console.log('Could not get context for WebGL version', webGLVersion);
            return null;
        }
    }
    const gl = contexts[webGLVersion];
    if (gl.isContextLost()) {
        delete contexts[webGLVersion];
        return getWebGLContext(webGLVersion);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return contexts[webGLVersion];
}
function createCanvas(webGLVersion) {
    if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {
        return new OffscreenCanvas(300, 150);
    }
    else if (typeof document !== 'undefined') {
        return document.createElement('canvas');
    }
    else {
        throw new Error('Cannot create a canvas in this context');
    }
}
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion !== 1 && webGLVersion !== 2) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    const canvas = createCanvas(webGLVersion);
    canvas.addEventListener('webglcontextlost', (ev) => {
        ev.preventDefault();
        delete contexts[webGLVersion];
    }, false);
    if (webGLVersion === 1) {
        return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||
            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES));
    }
    return canvas.getContext('webgl2', WEBGL_ATTRIBUTES);
}
//# sourceMappingURL=canvas_util.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClipProgram": () => (/* binding */ ClipProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ClipProgram {
    constructor(aShape) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
    getCustomSetupFunc(min, max) {
        return (gpgpu, webGLProgram) => {
            if (this.minLoc == null) {
                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');
                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');
            }
            gpgpu.gl.uniform1f(this.minLoc, min);
            gpgpu.gl.uniform1f(this.maxLoc, max);
        };
    }
}
//# sourceMappingURL=clip_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClipPackedProgram": () => (/* binding */ ClipPackedProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ClipPackedProgram {
    constructor(aShape) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = aShape;
        this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
    getCustomSetupFunc(min, max) {
        return (gpgpu, webGLProgram) => {
            if (this.minLoc == null) {
                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');
                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');
            }
            gpgpu.gl.uniform1f(this.minLoc, min);
            gpgpu.gl.uniform1f(this.maxLoc, max);
        };
    }
}
//# sourceMappingURL=clip_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComplexAbsProgram": () => (/* binding */ ComplexAbsProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ComplexAbsProgram {
    constructor(shape) {
        this.variableNames = ['real', 'imag'];
        this.outputShape = shape;
        this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
}
//# sourceMappingURL=complex_abs_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConcatProgram": () => (/* binding */ ConcatProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class ConcatProgram {
    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().
    constructor(shapes) {
        this.outputShape = [];
        this.outputShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutShape(shapes, 1 /* axis */);
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][1];
        for (let i = 1; i < offsets.length; i++) {
            offsets[i] = offsets[i - 1] + shapes[i][1];
        }
        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
        for (let i = 1; i < offsets.length; i++) {
            const shift = offsets[i - 1];
            snippets.push(`else if (yC < ${offsets[i]}) ` +
                `setOutput(getT${i}(yR, yC-${shift}));`);
        }
        const lastIndex = offsets.length;
        const lastShift = offsets[offsets.length - 1];
        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join('\n        ')}
      }
    `;
    }
}
//# sourceMappingURL=concat_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConcatPackedProgram": () => (/* binding */ ConcatPackedProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



class ConcatPackedProgram {
    constructor(shapes, axis) {
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        this.outputShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutShape(shapes, axis);
        const shape = this.outputShape;
        const rank = shape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_1__.getCoordsDataType)(rank);
        const coords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_2__.getChannels)('coords', rank);
        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][axis];
        for (let i = 1; i < offsets.length; i++) {
            offsets[i] = offsets[i - 1] + shapes[i][axis];
        }
        const channel = channels[axis];
        const lastChannels = channels.slice(-2);
        const allChannels = channels.join();
        let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
        for (let i = 1; i < offsets.length; i++) {
            const shift = offsets[i - 1];
            // Note: the >= comparison below may seem unnecessary given the check
            // above but is needed to workaround branch execution issues on some
            // devices. It makes all the conditions exclusive without relying on
            // execution order.
            getValueSnippet += `
        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
          return getChannel(
            getT${i}(${shiftedChannels(channels, channel, shift)}),
            vec2(${shiftedChannels(lastChannels, channel, shift)}));
        }`;
        }
        const lastIndex = offsets.length;
        const shift = offsets[offsets.length - 1];
        getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
        this.userCode = `
      float getValue(${channels.map(x => 'int ' + x)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);

        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;
        if (${coords[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords});
        }

        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;
        if (${coords[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords});
        }

        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;
        if (${coords[rank - 2]} < ${shape[rank - 2]} &&
            ${coords[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords});
        }
        setOutput(result);
      }
    `;
    }
}
/**
 * Return an expression for coordinates into a vector where a given channel
 * will be offset by [shift].
 *
 * @param channels the channels to consider
 * @param channel the channel we want shifted
 * @param shift  the amount to subtract from the channel.
 *
 * @returns a string of the form 'x, y-[shift], z' where any one channel can
 * have the shift applied.
 */
function shiftedChannels(channels, channel, shift) {
    const channelIdx = channels.indexOf(channel);
    const res = channels.map((c, idx) => {
        if (idx === channelIdx) {
            return `${c} - ${shift}`;
        }
        else {
            return c;
        }
    });
    return res.join();
}
//# sourceMappingURL=concat_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Conv2DDerFilterProgram": () => (/* binding */ Conv2DDerFilterProgram),
/* harmony export */   "Conv2DDerInputProgram": () => (/* binding */ Conv2DDerInputProgram),
/* harmony export */   "Conv3DDerFilterProgram": () => (/* binding */ Conv3DDerFilterProgram),
/* harmony export */   "Conv3DDerInputProgram": () => (/* binding */ Conv3DDerInputProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Conv2DDerFilterProgram {
    constructor(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const isChannelsLast = convInfo.dataFormat === 'channelsLast';
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              if (${isChannelsLast}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class Conv2DDerInputProgram {
    constructor(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const isChannelsLast = convInfo.dataFormat === 'channelsLast';
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class Conv3DDerFilterProgram {
    constructor(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class Conv3DDerInputProgram {
    constructor(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = filterDepth - 1 - convInfo.padInfo.front;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
//# sourceMappingURL=conv_backprop_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DepthwiseConv2DDerFilterProgram": () => (/* binding */ DepthwiseConv2DDerFilterProgram),
/* harmony export */   "DepthwiseConv2DDerInputProgram": () => (/* binding */ DepthwiseConv2DDerInputProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DepthwiseConv2DDerFilterProgram {
    constructor(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class DepthwiseConv2DDerInputProgram {
    constructor(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
//# sourceMappingURL=conv_backprop_gpu_depthwise.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Conv2DProgram": () => (/* binding */ Conv2DProgram),
/* harmony export */   "Conv3DProgram": () => (/* binding */ Conv3DProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Conv2DProgram {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        const isChannelsLast = convInfo.dataFormat === 'channelsLast';
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivationWeights) {
                activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            }
            else if (hasLeakyreluAlpha) {
                activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            }
            else {
                activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
            }
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivationWeights) {
            this.variableNames.push('preluActivationWeights');
        }
        if (hasLeakyreluAlpha) {
            this.variableNames.push('leakyreluAlpha');
        }
        this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
}
class Conv3DProgram {
    constructor(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
//# sourceMappingURL=conv_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DepthwiseConv2DProgram": () => (/* binding */ DepthwiseConv2DProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DepthwiseConv2DProgram {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        const xNumRows = convInfo.inHeight;
        const xNumCols = convInfo.inWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivation) {
                activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            }
            else if (hasLeakyReluAlpha) {
                activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            }
            else {
                activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
            }
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivation) {
            this.variableNames.push('preluActivationWeights');
        }
        if (hasLeakyReluAlpha) {
            this.variableNames.push('leakyreluAlpha');
        }
        this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${xNumRows}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${xNumCols}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=conv_gpu_depthwise.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DepthwiseConvPacked2DProgram": () => (/* binding */ DepthwiseConvPacked2DProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class DepthwiseConvPacked2DProgram {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
        this.variableNames = ['x', 'W'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = convInfo.outShape;
        const xNumRows = convInfo.inHeight;
        const xNumCols = convInfo.inWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const texelsAcross = filterWidth;
        let mainLoop = `int xR; int xC; int xCOffset;`;
        for (let r = 0; r < filterHeight; r++) {
            for (let c = 0; c < filterWidth; c++) {
                mainLoop += `
          vec4 xTexelR${r}C${c * 2} = vec4(0.);
          vec4 wR${r}C${c} = vec4(0.);
          vec4 xR${r}C${c} = vec4(0.);`;
            }
        }
        /**
         * This vectorized implementation works by gathering the values needed for
         * each output channel's dot product into vec4's and then multiplying them
         * all together (this happens in the final double for-loop below). Most of
         * the main loop consists of constructing these vec4's with the minimum
         * number of texture2D calls, which means making use of all four returned
         * values from a texture2D call at once.
         */
        for (let r = 0; r < filterHeight; r++) {
            for (let texelC = 0; texelC < texelsAcross; texelC++) {
                const c = texelC * 2;
                mainLoop += `
          xR = xRCorner + ${r * dilationHeight};
          xC = xCCorner + ${c * dilationWidth};
        `;
                if (strideWidth === 1) {
                    if (c < filterWidth) {
                        // If padding is odd, the outer texels have to be composed.
                        if (padLeft % 2 === 1) {
                            // TODO: Ensure vec4 previous does not result in redundant sample,
                            // and avoid setting xTexelRC's that exceed the boundary in the
                            // first place rather than resetting them to vec4(0)).
                            // To compute xCOffset:
                            // - If padding is odd, we must add 1 to ensure we ask for an
                            // even-numbered row.
                            // - We subtract 2 to access the previous texel.
                            mainLoop += `
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${xNumCols}) {
                    xTexelR${r}C${c}.zw = vec2(0.);
                  }
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${xNumCols}) {
                    previous.zw = vec2(0.);
                  }

                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);
                } else {
                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);
                }
              `;
                        }
                        else {
                            // Padding is even, so xRC corresponds to a single texel.
                            mainLoop += `
                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xR${r}C${c} = xTexelR${r}C${c};
              `;
                        }
                        if (c + 1 < filterWidth) {
                            // If dilation is even, the second entry should match the first
                            // (either both are composed or both are single samples). But if
                            // dilation is odd, then the second entry should be the opposite
                            // of the first (if the first is composed, the second is a single
                            // sample, and vice versa.)
                            const nextTexelOffset = padLeft % 2 === 0 ?
                                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.nearestLargerEven(dilationWidth) :
                                dilationWidth;
                            if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||
                                (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {
                                mainLoop += `
                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};

                  if(xR >= 0 && xR < ${xNumRows} &&
                    xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);
                  }
                `;
                                // If dilation > 1 then the xRC's will not be able to share any
                                // values, so each xRC will require two unique calls to getX.
                                if (dilationWidth > 1) {
                                    mainLoop += `
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ${xNumRows} &&
                      xCOffset >= 0 && xCOffset < ${xNumCols}) {
                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR${r}C${c} = vec4(0.);
                    }
                  `;
                                }
                                mainLoop += `
                  xR${r}C${c + 1} = vec4(
                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);
                `;
                            }
                            else {
                                mainLoop += `
                  xCOffset = xC + ${nextTexelOffset};

                  if(xR >= 0 && xR < ${xNumRows} &&
                    xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);
                  }

                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};
                `;
                            }
                        }
                    }
                }
                else { // stride > 1
                    if (c < filterWidth) {
                        mainLoop += `
              if(xR >= 0 && xR < ${xNumRows}) {
            `;
                        // Depending on whether padLeft is even or odd, we want either the
                        // xy or zw channels from X texels for xR${r}C${c}. If padLeft is
                        // even, xR${r}C${c + 1} is simply the zw channels of texels we've
                        // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will
                        // need to come from the xy channels of a new texel, hence the `vec4
                        // final` initialized below.
                        if (padLeft % 2 === 1) {
                            mainLoop += `
                xCOffset = xC + 1 - ${strideWidth};
                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {
                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR${r}C${c + 2} = vec4(0.);
                }

                xR${r}C${c} = vec4(
                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);
              `;
                            if (c + 1 < filterWidth) {
                                mainLoop += `
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ${strideWidth};
                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);
                `;
                            }
                        }
                        else {
                            mainLoop += `
                if(xC >= 0 && xC < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xCOffset = xC + ${strideWidth};
                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${r}C${c + 2} = vec4(0.);
                }

                xR${r}C${c} = vec4(
                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);
              `;
                            if (c + 1 < filterWidth) {
                                mainLoop += `
                  xR${r}C${c + 1} = vec4(
                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);
                `;
                            }
                        }
                        mainLoop += `}`;
                    }
                }
                if (c < filterWidth) {
                    mainLoop += `
            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);
            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);
          `;
                    if (c + 1 < filterWidth) {
                        mainLoop += `
              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);
              wR${r}C${c + 1} =
                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;
                    }
                }
            }
        }
        for (let r = 0; r < filterHeight; r++) {
            for (let c = 0; c < filterWidth; c++) {
                mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;
            }
        }
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivation) {
                activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            }
            else if (hasLeakyReluAlpha) {
                activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            }
            else {
                activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
            }
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivation) {
            this.variableNames.push('preluActivationWeights');
        }
        if (hasLeakyReluAlpha) {
            this.variableNames.push('leakyreluAlpha');
        }
        this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ${mainLoop}

        vec4 result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=conv_packed_gpu_depthwise.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CropAndResizeProgram": () => (/* binding */ CropAndResizeProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class CropAndResizeProgram {
    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
        this.variableNames = ['Image', 'Boxes', 'BoxInd'];
        this.outputShape = [];
        const [batch, imageHeight, imageWidth, depth] = imageShape;
        const [numBoxes,] = boxShape;
        const [cropHeight, cropWidth] = cropSize;
        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
        const methodId = method === 'bilinear' ? 1 : 0;
        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
        const [heightRatio, heightScale, inY] = cropHeight > 1 ?
            [
                `${(imageHeight - 1) / (cropHeight - 1)}`,
                '(y2-y1) * height_ratio',
                `y1*${inputHeightFloat} + float(y)*(height_scale)`,
            ] :
            [
                '0.0',
                '0.0',
                `0.5 * (y1+y2) * ${inputHeightFloat}`,
            ];
        const [widthRatio, widthScale, inX] = cropWidth > 1 ?
            [
                `${(imageWidth - 1) / (cropWidth - 1)}`,
                '(x2-x1) * width_ratio',
                `x1*${inputWidthFloat} + float(x)*(width_scale)`,
            ] :
            [
                '0.0',
                '0.0',
                `0.5 * (x1+x2) * ${inputWidthFloat}`,
            ];
        // Reference implementation
        // tslint:disable-next-line:max-line-length
        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc
        this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
}
//# sourceMappingURL=crop_and_resize_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/cumsum_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/cumsum_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CumSumProgram": () => (/* binding */ CumSumProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");

class CumSumProgram {
    constructor(shape, exclusive, reverse) {
        this.variableNames = ['x'];
        this.outputShape = shape;
        const rank = shape.length;
        const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;
        const length = shape[shape.length - 1];
        let condition = '';
        let idxString = '';
        // When exclusive is set, the cumsum op becomes roll op that copies the
        // value from the previous index based on the direction specified by the
        // reverse flag.
        if (exclusive) {
            condition = reverse ? `end != ${length - 1}` : 'end != 0';
            idxString = reverse ? 'end + 1' : 'end - 1';
        }
        else {
            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';
            idxString = (reverse ? 'end + pow2' : 'end - pow2');
        }
        this.userCode = `
      uniform float index;
      void main() {
        ${(0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank, 'coords')};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank, 'coords')} = idx;
          val += getX(${getCoords(rank, 'coords')});
        }
        setOutput(val);
      }
    `;
    }
    getCustomSetupFunc(index) {
        return (gpgpu, webGLProgram) => {
            if (this.index == null) {
                this.index = gpgpu.getUniformLocation(webGLProgram, 'index');
            }
            gpgpu.gl.uniform1f(this.index, index);
        };
    }
}
function getCoords(rank, name) {
    if (rank === 1) {
        return `${name}`;
    }
    else if (rank === 2) {
        return `${name}.x, ${name}.y`;
    }
    else if (rank === 3) {
        return `${name}.x, ${name}.y, ${name}.z`;
    }
    else if (rank === 4) {
        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
    }
    else {
        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
    }
}
function getFinalCoord(rank, name) {
    if (rank === 1) {
        return `${name}`;
    }
    else if (rank === 2) {
        return `${name}.y`;
    }
    else if (rank === 3) {
        return `${name}.z`;
    }
    else if (rank === 4) {
        return `${name}.w`;
    }
    else {
        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
    }
}
//# sourceMappingURL=cumsum_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DecodeMatrixProgram": () => (/* binding */ DecodeMatrixProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



class DecodeMatrixProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        this.packedInputs = false;
        this.packedOutput = true;
        this.outPackingScheme = _tex_util__WEBPACK_IMPORTED_MODULE_0__.PackingScheme.DENSE;
        const texShape = (0,_tex_util__WEBPACK_IMPORTED_MODULE_0__.getDenseTexShape)(outputShape);
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
        this.outputShape = outputShape;
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${_shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
    }
}
//# sourceMappingURL=decode_matrix_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DecodeMatrixPackedProgram": () => (/* binding */ DecodeMatrixPackedProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



class DecodeMatrixPackedProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outPackingScheme = _tex_util__WEBPACK_IMPORTED_MODULE_0__.PackingScheme.DENSE;
        const texShape = (0,_tex_util__WEBPACK_IMPORTED_MODULE_0__.getDenseTexShape)(outputShape);
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
        this.outputShape = outputShape;
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${_shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
    }
}
//# sourceMappingURL=decode_matrix_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DepthToSpaceProgram": () => (/* binding */ DepthToSpaceProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DepthToSpaceProgram {
    constructor(outputShape, blockSize, dataFormat) {
        this.variableNames = ['x'];
        this.outputShape = [];
        this.outputShape = outputShape;
        this.blockSize = blockSize;
        this.dataFormat = dataFormat;
        this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
        if (this.dataFormat === 'NHWC') {
            return `coords[1]`;
        }
        else {
            return `coords[2]`;
        }
    }
    getWidthCoordString() {
        if (this.dataFormat === 'NHWC') {
            return `coords[2]`;
        }
        else {
            return `coords[3]`;
        }
    }
    getDepthCoordString() {
        if (this.dataFormat === 'NHWC') {
            return `coords[3]`;
        }
        else {
            return `coords[1]`;
        }
    }
    getOutputDepthSize() {
        if (this.dataFormat === 'NHWC') {
            return this.outputShape[3];
        }
        else {
            return this.outputShape[1];
        }
    }
    getInputSamplingString() {
        if (this.dataFormat === 'NHWC') {
            return `getX(b, in_h, in_w, in_d)`;
        }
        else {
            return `getX(b, in_d, in_h, in_w)`;
        }
    }
}
//# sourceMappingURL=depth_to_space_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiagProgram": () => (/* binding */ DiagProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DiagProgram {
    constructor(size) {
        this.variableNames = ['X'];
        this.outputShape = [size, size];
        this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
}
//# sourceMappingURL=diag_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dilation2DProgram": () => (/* binding */ Dilation2DProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Dilation2DProgram {
    constructor(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;
        const { top: padTop, left: padLeft } = padInfo;
        this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${filterHeight}; h++) {
          int hIn = hBeg + h * ${dilationHeight};

          if (hIn >= 0 && hIn < ${inHeight}) {
            for (int w = 0; w < ${filterWidth}; w++) {
              int wIn = wBeg + w * ${dilationWidth};

              if (wIn >= 0 && wIn < ${inWidth}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=dilation_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncodeFloatProgram": () => (/* binding */ EncodeFloatProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



class EncodeFloatProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        this.outTexUsage = _tex_util__WEBPACK_IMPORTED_MODULE_0__.TextureUsage.DOWNLOAD;
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
        this.outputShape = outputShape;
        this.userCode = `
      ${_shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
    }
}
//# sourceMappingURL=encode_float_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncodeFloatPackedProgram": () => (/* binding */ EncodeFloatPackedProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



class EncodeFloatPackedProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outTexUsage = _tex_util__WEBPACK_IMPORTED_MODULE_0__.TextureUsage.DOWNLOAD;
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
        this.outputShape = outputShape;
        this.userCode = `
      ${_shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
    }
}
//# sourceMappingURL=encode_float_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncodeMatrixProgram": () => (/* binding */ EncodeMatrixProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


class EncodeMatrixProgram {
    constructor(outputShape, texShape, inputIsUnsignedByte = false) {
        this.variableNames = ['A'];
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_0__.getGlslDifferences)();
        const [height, width] = texShape;
        this.outputShape = outputShape;
        let output = `result`;
        if (inputIsUnsignedByte) {
            output = `floor(result * 255. + 0.5)`;
        }
        this.userCode = `
      ${_shader_compiler_util__WEBPACK_IMPORTED_MODULE_1__.getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${width};
        int c = imod(flatIndex, ${width});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
        vec4 values = ${glsl.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
    }
}
//# sourceMappingURL=encode_matrix_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncodeMatrixPackedProgram": () => (/* binding */ EncodeMatrixPackedProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


/*
This is how the shader encodes a tensor with shape = [2, 3, 5]
(indices are [batch, row, col]).

000|001   002|003   004|xxx   020|021   022|023   024|xxx
-------   -------   -------   -------   -------   -------
010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx

100|101   102|103   104|xxx   120|121   122|123   124|xxx
-------   -------   -------   -------   -------   -------
110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx

Single texels contain only values from the same batch, and from adjacent rows
and columns.
 */
class EncodeMatrixPackedProgram {
    constructor(outputShape, texShape, inputIsUnsignedByte = false) {
        this.variableNames = ['A'];
        this.packedInputs = false;
        this.packedOutput = true;
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_0__.getGlslDifferences)();
        const [height, width] = texShape;
        this.outputShape = outputShape;
        let mainLoop = '';
        let output = 'result';
        if (inputIsUnsignedByte) {
            output = 'floor(result * 255. + 0.5)';
        }
        for (let row = 0; row <= 1; row++) {
            for (let col = 0; col <= 1; col++) {
                const channel = row * 2 + col;
                mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${outputShape[2]}) {
            localCoords[2] += ${col};
            if(localCoords[1] + ${row} < ${outputShape[1]}) {
              localCoords[1] += ${row};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${width};
              c = imod(flatIndex, ${width});
              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
              values = ${glsl.texture2D}(A, uv);

              if(offset == 0) {
                result[${channel}] = values[0];
              } else if(offset == 1) {
                result[${channel}] = values[1];
              } else if(offset == 2) {
                result[${channel}] = values[2];
              } else {
                result[${channel}] = values[3];
              }
            }
          }
        `;
            }
        }
        this.userCode = `
      ${_shader_compiler_util__WEBPACK_IMPORTED_MODULE_1__.getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${mainLoop}

        ${glsl.output} = ${output};
      }
    `;
    }
}
//# sourceMappingURL=encode_matrix_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FFTProgram": () => (/* binding */ FFTProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class FFTProgram {
    constructor(component, inputShape, inverse) {
        this.variableNames = ['real', 'imag'];
        const innerDim = inputShape[1];
        this.outputShape = inputShape;
        const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
        const resultDenominator = inverse ? `${innerDim}.0` : '1.0';
        let opString;
        if (component === 'real') {
            opString = 'return real * expR - imag * expI;';
        }
        else if (component === 'imag') {
            opString = 'return real * expI + imag * expR;';
        }
        else {
            throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
        }
        this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
}
//# sourceMappingURL=fft_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillProgram": () => (/* binding */ FillProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class FillProgram {
    constructor(shape, value) {
        this.outputShape = [];
        this.variableNames = ['x'];
        this.outputShape = shape;
        this.userCode = `
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
    getCustomSetupFunc(value) {
        return (gpgpu, webGLProgram) => {
            if (this.valueLoc == null) {
                this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');
            }
            gpgpu.gl.uniform1f(this.valueLoc, value);
        };
    }
}
//# sourceMappingURL=fill_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const ENV = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)();
/**
 * This file contains WebGL-specific flag registrations.
 */
/**
 * True if WebGL is supported.
 */
ENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);
/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */
ENV.registerFlag('WEBGL_VERSION', () => {
    if ((0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isWebGLVersionEnabled)(2)) {
        return 2;
    }
    else if ((0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isWebGLVersionEnabled)(1)) {
        return 1;
    }
    return 0;
});
/** Whether to check for numerical representation problems. */
ENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', () => false);
ENV.registerFlag('WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);
/** Whether the WebGL backend will sometimes forward ops to the CPU. */
ENV.registerFlag('WEBGL_CPU_FORWARD', () => true);
/** Whether the WebGL backend will always use f16 textures for rendering. */
ENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);
/** Whether to turn all packing related flags on. */
ENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));
/** Whether we will pack the batchnormalization op. */
ENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));
/** Whether we will pack the clip op. */
ENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));
/** Whether we will pack the depthwise conv op. */
// TODO: https://github.com/tensorflow/tfjs/issues/1679
ENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => false);
/** Whether we will pack binary ops. */
ENV.registerFlag('WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));
/** Whether we will pack unary ops. */
ENV.registerFlag('WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));
/** Whether we will pack array ops. */
ENV.registerFlag('WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));
/** Whether we will pack image ops. */
ENV.registerFlag('WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));
/** Whether we will pack reduce ops. */
ENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));
/** Whether packed WebGL kernels lazily unpack their outputs. */
ENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));
/** Whether we will use the im2col algorithm to speed up convolutions. */
ENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));
/** The maximum texture dimension. */
ENV.registerFlag('WEBGL_MAX_TEXTURE_SIZE', () => (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLMaxTextureSize)(ENV.getNumber('WEBGL_VERSION')));
/** The maximum texture dimension. */
ENV.registerFlag('WEBGL_MAX_TEXTURES_IN_SHADER', () => (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getMaxTexturesInShader)(ENV.getNumber('WEBGL_VERSION')));
/**
 * The disjoint_query_timer extension version.
 * 0: disabled, 1: EXT_disjoint_timer_query, 2:
 * EXT_disjoint_timer_query_webgl2.
 * In Firefox with WebGL 2.0,
 * EXT_disjoint_timer_query_webgl2 is not available, so we must use the
 * WebGL 1.0 extension.
 */
ENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {
    const webGLVersion = ENV.getNumber('WEBGL_VERSION');
    if (webGLVersion === 0) {
        return 0;
    }
    return (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLDisjointQueryTimerVersion)(webGLVersion);
});
/**
 * Whether the timer object from the disjoint_query_timer extension gives
 * timing information that is reliable.
 */
ENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&
    !_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.device_util.isMobile());
/**
 * Whether the device is physically capable of rendering to float32 textures.
 */
ENV.registerFlag('WEBGL_RENDER_FLOAT32_CAPABLE', () => (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isCapableOfRenderingToFloatTexture)(ENV.getNumber('WEBGL_VERSION')));
/**
 * Whether rendering to float32 textures is enabled. If disabled, renders to
 * float16 textures.
 */
ENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {
    return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?
        false :
        ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');
});
/**
 * Whether downloading float textures is enabled (16 or 32 bit). If disabled,
 * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.
 */
ENV.registerFlag('WEBGL_DOWNLOAD_FLOAT_ENABLED', () => (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isDownloadFloatTextureEnabled)(ENV.getNumber('WEBGL_VERSION')));
/** Whether the fence API is available. */
ENV.registerFlag('WEBGL_FENCE_API_ENABLED', () => (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isWebGLFenceEnabled)(ENV.getNumber('WEBGL_VERSION')));
/**
 * Tensors with size <= than this will be uploaded as uniforms, not textures.
 */
ENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {
    // Use uniform uploads only when 32bit floats are supported. In
    // 16bit
    // environments there are problems with comparing a 16bit texture value
    // with a 32bit uniform value.
    const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');
    return useUniforms ? 4 : 0;
});
/**
 * If the total number of bytes allocated on the GPU is greater than this
 * number, we will aggressively delete textures upon disposal with
 * gl.deleteMatrixTexture, rather than making them available for reuse.
 *
 * Default value -1 indicates that we will never aggressively delete textures.
 */
ENV.registerFlag('WEBGL_DELETE_TEXTURE_THRESHOLD', () => {
    return -1;
}, threshold => {
    if (threshold < 0 && threshold !== -1) {
        throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` +
            `delete) or at least 0, but got ${threshold}.`);
    }
});
//# sourceMappingURL=flags_webgl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FlipLeftRightProgram": () => (/* binding */ FlipLeftRightProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class FlipLeftRightProgram {
    constructor(imageShape) {
        this.variableNames = ['Image'];
        this.outputShape = [];
        const imageWidth = imageShape[2];
        this.outputShape = imageShape;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
}
//# sourceMappingURL=flip_left_right_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GatherProgram": () => (/* binding */ GatherProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class GatherProgram {
    constructor(aShape, outputShape) {
        this.variableNames = ['A', 'indices'];
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(this.rank);
        const sourceCoords = getSourceCoords(aShape, 2);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
    }
}
// The input and output are always flattened into rank 4 tensors.
function getSourceCoords(aShape, axis) {
    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    const sourceCoords = [];
    for (let i = 0; i < aShape.length; i++) {
        if (i === 2) {
            sourceCoords.push('int(getIndices(resRC.x, resRC.z))');
        }
        else {
            sourceCoords.push(`${currentCoords[i]}`);
        }
    }
    return sourceCoords.join();
}
//# sourceMappingURL=gather_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GatherNDProgram": () => (/* binding */ GatherNDProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");

class GatherNDProgram {
    constructor(sliceDim, strides, shape) {
        this.sliceDim = sliceDim;
        this.strides = strides;
        this.variableNames = ['x', 'indices'];
        this.outputShape = shape;
        const stridesType = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(strides.length);
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(shape.length);
        const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';
        this.userCode = `
        ${stridesType} strides = ${stridesType}(${this.strides});
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${strideString};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
    }
}
//# sourceMappingURL=gather_nd_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getGlslDifferences": () => (/* binding */ getGlslDifferences)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function getGlslDifferences() {
    let version;
    let attribute;
    let varyingVs;
    let varyingFs;
    let texture2D;
    let output;
    let defineOutput;
    let defineSpecialNaN;
    let defineSpecialInf;
    let defineRound;
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_VERSION') === 2) {
        version = '#version 300 es';
        attribute = 'in';
        varyingVs = 'out';
        varyingFs = 'in';
        texture2D = 'texture';
        output = 'outputColor';
        defineOutput = 'out vec4 outputColor;';
        // Use custom isnan definition to work across differences between
        // implementations on various platforms. While this should happen in ANGLE
        // we still see differences between android and windows (on chrome) when
        // using isnan directly.
        defineSpecialNaN = `
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `;
        // In webgl 2 we do not need to specify a custom isinf so there is no
        // need for a special INFINITY constant.
        defineSpecialInf = ``;
        defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    }
    else {
        version = '';
        attribute = 'attribute';
        varyingVs = 'varying';
        varyingFs = 'varying';
        texture2D = 'texture2D';
        output = 'gl_FragColor';
        defineOutput = '';
        // WebGL1 has no built in isnan so we define one here.
        defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
        defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
        defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    }
    return {
        version,
        attribute,
        varyingVs,
        varyingFs,
        texture2D,
        output,
        defineOutput,
        defineSpecialNaN,
        defineSpecialInf,
        defineRound
    };
}
//# sourceMappingURL=glsl_version.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GPGPUContext": () => (/* binding */ GPGPUContext),
/* harmony export */   "linearSearchLastTrue": () => (/* binding */ linearSearchLastTrue)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _canvas_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js");
/* harmony import */ var _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gpgpu_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





class GPGPUContext {
    constructor(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.vertexAttrsAreBound = false;
        this.itemsToPoll = [];
        const glVersion = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_VERSION');
        if (gl != null) {
            this.gl = gl;
            (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.setWebGLContext)(glVersion, gl);
        }
        else {
            this.gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(glVersion);
        }
        // WebGL 2.0 enables texture floats without an extension.
        let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';
        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_VERSION') === 1) {
            const TEXTURE_FLOAT = 'OES_texture_float';
            const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';
            this.textureFloatExtension =
                _webgl_util__WEBPACK_IMPORTED_MODULE_2__.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
            if (_webgl_util__WEBPACK_IMPORTED_MODULE_2__.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
                this.textureHalfFloatExtension =
                    _webgl_util__WEBPACK_IMPORTED_MODULE_2__.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
            }
            else if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().get('WEBGL_FORCE_F16_TEXTURES')) {
                throw new Error('GL context does not support half float textures, yet the ' +
                    'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');
            }
            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
            if (_webgl_util__WEBPACK_IMPORTED_MODULE_2__.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
                this.colorBufferHalfFloatExtension =
                    _webgl_util__WEBPACK_IMPORTED_MODULE_2__.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
            }
            else if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().get('WEBGL_FORCE_F16_TEXTURES')) {
                throw new Error('GL context does not support color renderable half floats, yet ' +
                    'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');
            }
        }
        else {
            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';
            if (_webgl_util__WEBPACK_IMPORTED_MODULE_2__.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
                this.colorBufferFloatExtension =
                    this.gl.getExtension(COLOR_BUFFER_FLOAT);
            }
            else if (_webgl_util__WEBPACK_IMPORTED_MODULE_2__.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
                this.colorBufferHalfFloatExtension =
                    this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
            }
            else {
                throw new Error('GL context does not support color renderable floats');
            }
        }
        this.vertexBuffer = _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createVertexBuffer(this.gl);
        this.indexBuffer = _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createIndexBuffer(this.gl);
        this.framebuffer = _webgl_util__WEBPACK_IMPORTED_MODULE_2__.createFramebuffer(this.gl);
        this.textureConfig =
            _tex_util__WEBPACK_IMPORTED_MODULE_4__.getTextureConfig(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('DEBUG');
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        const gl = this.gl;
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.finish());
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));
        this.disposed = true;
    }
    createFloat32MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createFloat16MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    uploadPixelDataToTexture(texture, pixels) {
        this.throwIfDisposed();
        _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.uploadPixelDataToTexture(this.gl, texture, pixels);
    }
    uploadDenseMatrixToTexture(texture, width, height, data) {
        this.throwIfDisposed();
        _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createPackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    deleteMatrixTexture(texture) {
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
        return this.downloadMatrixDriver(texture, () => _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {
        return _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(buffer, size) {
        return _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);
    }
    createBufferFromTexture(texture, rows, columns) {
        this.bindTextureToFrameBuffer(texture);
        const result = _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
        this.unbindTextureToFrameBuffer();
        return result;
    }
    createAndWaitForFence() {
        const fenceContext = this.createFence(this.gl);
        return this.pollFence(fenceContext);
    }
    createFence(gl) {
        let query;
        let isFencePassed;
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_FENCE_API_ENABLED')) {
            const gl2 = gl;
            const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
            gl.flush();
            isFencePassed = () => {
                const status = gl2.clientWaitSync(sync, 0, 0);
                return status === gl2.ALREADY_SIGNALED ||
                    status === gl2.CONDITION_SATISFIED;
            };
            query = sync;
        }
        else if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            query = this.beginQuery();
            this.endQuery();
            isFencePassed = () => this.isQueryAvailable(query, (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));
        }
        else {
            // If we have no way to fence, return true immediately. This will fire in
            // WebGL 1.0 when there is no disjoint query timer. In this case, because
            // the fence passes immediately, we'll immediately ask for a download of
            // the texture, which will cause the UI thread to hang.
            isFencePassed = () => true;
        }
        return { query, isFencePassed };
    }
    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
        return this.downloadMatrixDriver(texture, () => _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
    }
    createProgram(fragmentShaderSource) {
        this.throwIfDisposed();
        const gl = this.gl;
        const fragmentShader = _webgl_util__WEBPACK_IMPORTED_MODULE_2__.createFragmentShader(gl, fragmentShaderSource);
        const vertexShader = _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.createVertexShader(gl);
        const program = _webgl_util__WEBPACK_IMPORTED_MODULE_2__.createProgram(gl);
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.attachShader(program, vertexShader));
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.linkProgram(gl, program);
        if (this.debug) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.validateProgram(gl, program);
        }
        if (!this.vertexAttrsAreBound) {
            this.setProgram(program);
            this.vertexAttrsAreBound = _gpgpu_util__WEBPACK_IMPORTED_MODULE_3__.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        }
        return program;
    }
    deleteProgram(program) {
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(this.gl, () => this.gl.deleteProgram(program));
        }
    }
    setProgram(program) {
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.debug) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.validateProgram(this.gl, this.program);
        }
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(this.gl, () => this.gl.useProgram(program));
    }
    getUniformLocation(program, uniformName, shouldThrow = true) {
        this.throwIfDisposed();
        if (shouldThrow) {
            return _webgl_util__WEBPACK_IMPORTED_MODULE_2__.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        }
        else {
            return _webgl_util__WEBPACK_IMPORTED_MODULE_2__.getProgramUniformLocation(this.gl, program, uniformName);
        }
    }
    getAttributeLocation(program, attribute) {
        this.throwIfDisposed();
        return _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
    }
    getUniformLocationNoThrow(program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    }
    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
    }
    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    }
    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        const [width, height] = _tex_util__WEBPACK_IMPORTED_MODULE_4__.getPackedMatrixTextureShapeWidthHeight(rows, columns);
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    }
    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    }
    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    }
    debugValidate() {
        if (this.program != null) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.validateProgram(this.gl, this.program);
        }
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.validateFramebuffer(this.gl);
    }
    executeProgram() {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        const gl = this.gl;
        if (this.debug) {
            this.debugValidate();
        }
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
        this.throwIfDisposed();
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
        if (this.disjointQueryTimerExtension == null) {
            this.disjointQueryTimerExtension =
                _webgl_util__WEBPACK_IMPORTED_MODULE_2__.getExtensionOrThrow(this.gl, (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?
                    'EXT_disjoint_timer_query_webgl2' :
                    'EXT_disjoint_timer_query');
        }
        return this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
        return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
        return this.getQueryTimerExtension();
    }
    beginQuery() {
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            const gl2 = this.gl;
            const ext = this.getQueryTimerExtensionWebGL2();
            const query = gl2.createQuery();
            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
            return query;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        const query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
    }
    endQuery() {
        if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            const gl2 = this.gl;
            const ext = this.getQueryTimerExtensionWebGL2();
            gl2.endQuery(ext.TIME_ELAPSED_EXT);
            return;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(query) {
        await _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed
            // in rapid succession, so without this check we
            // may poll for the query timer indefinitely
            this.isQueryAvailable(query, (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));
        return this.getQueryTime(query, (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));
    }
    getQueryTime(query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return null;
        }
        if (queryTimerVersion === 2) {
            const gl2 = this.gl;
            const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            // Return milliseconds.
            return timeElapsedNanos / 1000000;
        }
        else {
            const ext = this.getQueryTimerExtensionWebGL1();
            const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
            // Return milliseconds.
            return timeElapsedNanos / 1000000;
        }
    }
    isQueryAvailable(query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return true;
        }
        if (queryTimerVersion === 2) {
            const gl2 = this.gl;
            const ext = this.getQueryTimerExtensionWebGL2();
            const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
        else {
            const ext = this.getQueryTimerExtensionWebGL1();
            const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
    }
    pollFence(fenceContext) {
        return new Promise(resolve => {
            this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
        });
    }
    pollItems() {
        // Find the last query that has finished.
        const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));
        for (let i = 0; i <= index; ++i) {
            const { resolveFn } = this.itemsToPoll[i];
            resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index + 1);
    }
    addItemToPoll(isDoneFn, resolveFn) {
        this.itemsToPoll.push({ isDoneFn, resolveFn });
        if (this.itemsToPoll.length > 1) {
            // We already have a running loop that polls.
            return;
        }
        // Start a new loop that polls.
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.repeatedTry(() => {
            this.pollItems();
            // End the loop if no more items to poll.
            return this.itemsToPoll.length === 0;
        });
    }
    bindTextureToFrameBuffer(texture) {
        this.throwIfDisposed();
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.debug) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.validateFramebuffer(this.gl);
        }
    }
    unbindTextureToFrameBuffer() {
        if (this.outputTexture != null) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.debug) {
                _webgl_util__WEBPACK_IMPORTED_MODULE_2__.validateFramebuffer(this.gl);
            }
        }
        else {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    }
    downloadMatrixDriver(texture, downloadAndDecode) {
        this.bindTextureToFrameBuffer(texture);
        const result = downloadAndDecode();
        this.unbindTextureToFrameBuffer();
        return result;
    }
    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        const gl = this.gl;
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.debug) {
            _webgl_util__WEBPACK_IMPORTED_MODULE_2__.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.viewport(0, 0, width, height));
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(gl, () => gl.scissor(0, 0, width, height));
    }
    setOutputMatrixWriteRegionDriver(x, y, width, height) {
        this.throwIfDisposed();
        _webgl_util__WEBPACK_IMPORTED_MODULE_2__.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));
    }
    throwIfDisposed() {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    }
    throwIfNoProgram() {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    }
}
/**
 * Finds the index of the last true element using linear search.
 * Note: We can't do binary search because Chrome expects us to explicitly
 * test all fences before download:
 * https://github.com/tensorflow/tfjs/issues/1145
 */
function linearSearchLastTrue(arr) {
    let i = 0;
    for (; i < arr.length; ++i) {
        const isDone = arr[i]();
        if (!isDone) {
            break;
        }
    }
    return i - 1;
}
//# sourceMappingURL=gpgpu_context.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compileProgram": () => (/* binding */ compileProgram),
/* harmony export */   "runProgram": () => (/* binding */ runProgram),
/* harmony export */   "makeShaderKey": () => (/* binding */ makeShaderKey)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function compileProgram(gpgpu, program, inputs, output) {
    const userCode = program.userCode;
    const inputInfos = inputs.map((input, i) => {
        const shapeInfo = {
            logicalShape: input.shape,
            texShape: input.isUniform ? null : input.texData.texShape,
            isUniform: input.isUniform,
            isPacked: input.isUniform ? false : input.texData.isPacked,
            flatOffset: null
        };
        if (input.texData != null && input.texData.slice != null &&
            input.texData.slice.flatOffset > 0) {
            shapeInfo.flatOffset = input.texData.slice.flatOffset;
        }
        return { name: program.variableNames[i], shapeInfo };
    });
    const inShapeInfos = inputInfos.map(x => x.shapeInfo);
    const outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.texData.texShape,
        isUniform: false,
        isPacked: output.texData.isPacked,
        flatOffset: null
    };
    const source = _shader_compiler__WEBPACK_IMPORTED_MODULE_1__.makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);
    const webGLProgram = gpgpu.createProgram(source);
    // Add special uniforms (NAN, INFINITY)
    let infLoc = null;
    const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_VERSION') === 1) {
        infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);
    }
    // Add user-defined uniforms
    const uniformLocations = {};
    for (let i = 0; i < program.variableNames.length; i++) {
        const varName = program.variableNames[i];
        const shouldThrow = false;
        uniformLocations[varName] =
            gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
        uniformLocations[`offset${varName}`] =
            gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
    }
    return {
        program,
        source,
        webGLProgram,
        uniformLocations,
        inShapeInfos,
        outShapeInfo,
        infLoc,
        nanLoc,
    };
}
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` +
            `was executed with ${inputs.length} inputs`);
    }
    shapeInfos.forEach((s, i) => {
        const shapeA = s.logicalShape;
        const input = inputs[i];
        const shapeB = input.shape;
        if (!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(shapeA, shapeB)) {
            throw Error(`Binary was compiled with different shapes than ` +
                `the current args. Shapes ${shapeA} and ${shapeB} must match`);
        }
        // The input is uploaded as uniform.
        if (s.isUniform && input.isUniform) {
            return;
        }
        const texShapeA = s.texShape;
        const texShapeB = input.isUniform ? null : input.texData.texShape;
        if (!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(texShapeA, texShapeB)) {
            throw Error(`Binary was compiled with different texture shapes than the` +
                ` current args. Shape ${texShapeA} and ${texShapeB} must match`);
        }
    });
}
function runProgram(gpgpu, binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    const outTex = output.texData.texture;
    const outTexShape = output.texData.texShape;
    if (output.texData.isPacked) {
        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    }
    else {
        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    }
    gpgpu.setProgram(binary.webGLProgram);
    // Set special uniforms (NAN, INFINITY)
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_VERSION') === 1) {
        if (binary.infLoc !== null) {
            gpgpu.gl.uniform1f(binary.infLoc, Infinity);
        }
    }
    if (binary.nanLoc !== null) {
        gpgpu.gl.uniform1f(binary.nanLoc, NaN);
    }
    // Set user-defined inputs
    inputs.forEach((input, i) => {
        const varName = binary.program.variableNames[i];
        const varLoc = binary.uniformLocations[varName];
        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
        if (varLoc == null) {
            // The compiler inferred that this variable is not used in this shader.
            return;
        }
        if (input.isUniform) {
            // Upload the values of the tensor as uniform.
            if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(input.shape) < 2) {
                gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);
            }
            else {
                let vals = input.uniformValues;
                if (!(vals instanceof Float32Array)) {
                    vals = new Float32Array(vals);
                }
                gpgpu.gl.uniform1fv(varLoc, vals);
            }
            return;
        }
        // If the input was sliced, upload the flat offset index.
        if (input.texData.slice != null && varOffsetLoc != null) {
            gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);
        }
        gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);
    });
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram();
}
function makeShaderKey(program, inputs, output) {
    let keyInputs = '';
    inputs.concat(output).forEach(x => {
        const hasOffset = x.texData != null && x.texData.slice != null &&
            x.texData.slice.flatOffset > 0;
        const texShape = x.isUniform ? 'uniform' : x.texData.texShape;
        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
    });
    const keyUserCode = program.userCode;
    let key = program.constructor.name;
    // Fast string concat. See https://jsperf.com/string-concatenation/14.
    key += '_' + keyInputs + '_' + keyUserCode;
    return key;
}
//# sourceMappingURL=gpgpu_math.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVertexShader": () => (/* binding */ createVertexShader),
/* harmony export */   "createVertexBuffer": () => (/* binding */ createVertexBuffer),
/* harmony export */   "createIndexBuffer": () => (/* binding */ createIndexBuffer),
/* harmony export */   "getInternalFormatForFloat32MatrixTexture": () => (/* binding */ getInternalFormatForFloat32MatrixTexture),
/* harmony export */   "createFloat32MatrixTexture": () => (/* binding */ createFloat32MatrixTexture),
/* harmony export */   "getInternalFormatForFloat16MatrixTexture": () => (/* binding */ getInternalFormatForFloat16MatrixTexture),
/* harmony export */   "createFloat16MatrixTexture": () => (/* binding */ createFloat16MatrixTexture),
/* harmony export */   "getInternalFormatForUnsignedBytesMatrixTexture": () => (/* binding */ getInternalFormatForUnsignedBytesMatrixTexture),
/* harmony export */   "createUnsignedBytesMatrixTexture": () => (/* binding */ createUnsignedBytesMatrixTexture),
/* harmony export */   "getInternalFormatForPackedMatrixTexture": () => (/* binding */ getInternalFormatForPackedMatrixTexture),
/* harmony export */   "createPackedMatrixTexture": () => (/* binding */ createPackedMatrixTexture),
/* harmony export */   "getInternalFormatForFloat16PackedMatrixTexture": () => (/* binding */ getInternalFormatForFloat16PackedMatrixTexture),
/* harmony export */   "createFloat16PackedMatrixTexture": () => (/* binding */ createFloat16PackedMatrixTexture),
/* harmony export */   "bindVertexProgramAttributeStreams": () => (/* binding */ bindVertexProgramAttributeStreams),
/* harmony export */   "uploadDenseMatrixToTexture": () => (/* binding */ uploadDenseMatrixToTexture),
/* harmony export */   "uploadPixelDataToTexture": () => (/* binding */ uploadPixelDataToTexture),
/* harmony export */   "createBufferFromOutputTexture": () => (/* binding */ createBufferFromOutputTexture),
/* harmony export */   "downloadFloat32MatrixFromBuffer": () => (/* binding */ downloadFloat32MatrixFromBuffer),
/* harmony export */   "downloadByteEncodedFloatMatrixFromOutputTexture": () => (/* binding */ downloadByteEncodedFloatMatrixFromOutputTexture),
/* harmony export */   "downloadPackedMatrixFromBuffer": () => (/* binding */ downloadPackedMatrixFromBuffer),
/* harmony export */   "downloadMatrixFromPackedOutputTexture": () => (/* binding */ downloadMatrixFromPackedOutputTexture)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function createVertexShader(gl) {
    const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_0__.getGlslDifferences)();
    const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return _webgl_util__WEBPACK_IMPORTED_MODULE_1__.createVertexShader(gl, vertexShaderSource);
}
function createVertexBuffer(gl) {
    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]
    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return _webgl_util__WEBPACK_IMPORTED_MODULE_1__.createStaticVertexBuffer(gl, vertexArray);
}
function createIndexBuffer(gl) {
    // OpenGL (and WebGL) have "CCW == front" winding
    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return _webgl_util__WEBPACK_IMPORTED_MODULE_1__.createStaticIndexBuffer(gl, triangleVertexIndices);
}
function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.validateTextureSize(width, height);
    const texture = _webgl_util__WEBPACK_IMPORTED_MODULE_1__.createTexture(gl);
    const tex2d = gl.TEXTURE_2D;
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    return texture;
}
function getInternalFormatForFloat32MatrixTexture(textureConfig) {
    return textureConfig.internalFormatFloat;
}
function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = _tex_util__WEBPACK_IMPORTED_MODULE_2__.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
}
function getInternalFormatForFloat16MatrixTexture(textureConfig) {
    return textureConfig.internalFormatHalfFloat;
}
function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = _tex_util__WEBPACK_IMPORTED_MODULE_2__.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
}
function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
    return textureConfig.downloadTextureFormat;
}
function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = _tex_util__WEBPACK_IMPORTED_MODULE_2__.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
}
function getInternalFormatForPackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedFloat;
}
function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = _tex_util__WEBPACK_IMPORTED_MODULE_2__.getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);
}
function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedHalfFloat;
}
function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = _tex_util__WEBPACK_IMPORTED_MODULE_2__.getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
}
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    const posOffset = 0; // x is the first buffer element
    const uvOffset = 3 * 4; // uv comes after [x y z]
    const stride = (3 * 4) + (2 * 4); // xyz + uv, each entry is 4-byte float.
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));
    const success = _webgl_util__WEBPACK_IMPORTED_MODULE_1__.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    return success &&
        _webgl_util__WEBPACK_IMPORTED_MODULE_1__.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
}
function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    let dataForUpload, texelDataType, internalFormat;
    if (data instanceof Uint8Array) {
        dataForUpload = new Uint8Array(width * height * 4);
        texelDataType = gl.UNSIGNED_BYTE;
        internalFormat = gl.RGBA;
    }
    else {
        dataForUpload = new Float32Array(width * height * 4);
        texelDataType = gl.FLOAT;
        internalFormat = textureConfig.internalFormatPackedFloat;
    }
    dataForUpload.set(data);
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function uploadPixelDataToTexture(gl, texture, pixels) {
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    if (pixels.data instanceof Uint8Array) {
        _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
    }
    else {
        _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
    }
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
    // Create and bind the buffer.
    const buffer = gl2.createBuffer();
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));
    // Initialize the buffer to the size of the texture in bytes.
    const bytesPerFloat = 4;
    const valuesPerTexel = 4;
    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
    // Enqueue a command on the GPU command queue to copy of texture into the
    // buffer.
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
    return buffer;
}
function downloadFloat32MatrixFromBuffer(gl, buffer, size) {
    const gl2 = gl;
    const downloadTarget = new Float32Array(size);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
}
function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
    const [w, h] = _tex_util__WEBPACK_IMPORTED_MODULE_2__.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    const numChannels = 4;
    const downloadTarget = new Uint8Array(_tex_util__WEBPACK_IMPORTED_MODULE_2__.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));
    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754
    // decoding of the 4 bytes that back each 32 bit float.
    return new Float32Array(downloadTarget.buffer);
}
function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
    const gl2 = gl;
    const downloadTarget = new Float32Array(_tex_util__WEBPACK_IMPORTED_MODULE_2__.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
}
function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {
    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
    _webgl_util__WEBPACK_IMPORTED_MODULE_1__.callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));
    return packedRGBA;
}
//# sourceMappingURL=gpgpu_util.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Im2ColPackedProgram": () => (/* binding */ Im2ColPackedProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class Im2ColPackedProgram {
    constructor(outputShape, inputShape, convInfo) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const { filterWidth, inChannels, strideWidth, strideHeight, padInfo, outWidth, dilationWidth, dilationHeight, dataFormat } = convInfo;
        const { left, top } = padInfo;
        const itemsPerBlockRow = inChannels * filterWidth;
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_0__.getGlslDifferences)();
        const isChannelsLast = dataFormat === 'channelsLast';
        const rowDim = isChannelsLast ? 0 : 1;
        const colDim = isChannelsLast ? 1 : 2;
        let unrolled = ``;
        for (let row = 0; row <= 1; row++) {
            for (let col = 0; col <= 1; col++) {
                unrolled += `
          blockIndex = rc.y + ${col};
          pos = rc.x + ${row};

          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {
            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${top};
            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});

            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${strideWidth}. - ${left}.);
              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${itemsPerBlockRow}.) / ${inChannels}.));

              if(d1 < ${inputShape[colDim]} && d1 >= 0) {

                ch = int(mod(float(pos), ${inChannels}.));

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
            }
        }
        this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
    }
}
//# sourceMappingURL=im2col_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GPGPUContext": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.GPGPUContext),
/* harmony export */   "MathBackendWebGL": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.MathBackendWebGL),
/* harmony export */   "forceHalfFloat": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.forceHalfFloat),
/* harmony export */   "gpgpu_util": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.gpgpu_util),
/* harmony export */   "setWebGLContext": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.setWebGLContext),
/* harmony export */   "version_webgl": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.version_webgl),
/* harmony export */   "webgl": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.webgl),
/* harmony export */   "webgl_util": () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.webgl_util)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js");
/* harmony import */ var _register_all_kernels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./register_all_kernels */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// All exports from this package should be in base.


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "argMinMaxReduce": () => (/* binding */ argMinMaxReduce)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _argminmax_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../argminmax_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js");
/* harmony import */ var _argminmax_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../argminmax_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js");
/* harmony import */ var _kernels_Reshape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernels/Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function argReduce(backend, x, reduceType, bestIndicesA = null) {
    let batchSize = x.shape[0];
    let inSize = x.shape[1];
    if (bestIndicesA != null) {
        batchSize = bestIndicesA.shape[0];
        inSize = bestIndicesA.shape[1];
    }
    const windowSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOptimalWindowSize(inSize);
    const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };
    const program = new _argminmax_gpu__WEBPACK_IMPORTED_MODULE_1__.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
    const inputs = [x];
    if (bestIndicesA != null) {
        inputs.push(bestIndicesA);
    }
    const output = backend.runWebGLProgram(program, inputs, 'int32');
    // No need to run another GPGPU program.
    if (output.shape[1] === 1) {
        return output;
    }
    const result = argReduce(backend, x, reduceType, output);
    backend.disposeIntermediateTensorInfo(output);
    return result;
}
function argReducePacked(backend, x, reduceType, bestIndicesA = null) {
    const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;
    const inSize = inShape[inShape.length - 1];
    const windowSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOptimalWindowSize(inSize);
    const program = new _argminmax_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
    const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];
    const output = backend.runWebGLProgram(program, inputs, 'int32');
    if (output.shape.length === x.shape.length) {
        const result = argReducePacked(backend, x, reduceType, output);
        backend.disposeIntermediateTensorInfo(output);
        return result;
    }
    return output;
}
function argMinMaxReduce(backend, x, axis, reduceType) {
    const axes = [axis];
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);
    if (!(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_REDUCE') || x.shape.length <= 2) {
        const intermediateTensorInfos = [];
        const [outShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(x.shape, axes);
        const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
        const a2D = (0,_kernels_Reshape__WEBPACK_IMPORTED_MODULE_3__.reshape)({ inputs: { x }, backend, attrs: { shape: [-1, inSize] } });
        intermediateTensorInfos.push(a2D);
        const reduced = argReduce(backend, a2D, reduceType);
        intermediateTensorInfos.push(reduced);
        const reshaped = (0,_kernels_Reshape__WEBPACK_IMPORTED_MODULE_3__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
        intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));
        return reshaped;
    }
    return argReducePacked(backend, x, reduceType);
}
//# sourceMappingURL=arg_min_max.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "int": () => (/* binding */ int)
/* harmony export */ });
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

const TO_INT = `return float(int(x));`;
function int(input, backend) {
    const program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_0__.UnaryOpProgram(input.shape, TO_INT);
    const output = backend.runWebGLProgram(program, [input], 'int32');
    return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
}
//# sourceMappingURL=int.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CHECK_NAN_SNIPPET_UNARY": () => (/* binding */ CHECK_NAN_SNIPPET_UNARY),
/* harmony export */   "CHECK_NAN_SNIPPET_BINARY": () => (/* binding */ CHECK_NAN_SNIPPET_BINARY),
/* harmony export */   "CHECK_NAN_SNIPPET_BINARY_PACKED": () => (/* binding */ CHECK_NAN_SNIPPET_BINARY_PACKED),
/* harmony export */   "unaryKernelFunc": () => (/* binding */ unaryKernelFunc),
/* harmony export */   "binaryKernelFunc": () => (/* binding */ binaryKernelFunc),
/* harmony export */   "mapActivationToShaderProgram": () => (/* binding */ mapActivationToShaderProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../binaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/* harmony import */ var _kernels_Complex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../kernels/Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/* harmony import */ var _kernels_LeakyRelu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../kernels/LeakyRelu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js");
/* harmony import */ var _kernels_Prelu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../kernels/Prelu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/* harmony import */ var _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */










const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
const CHECK_NAN_SNIPPET_BINARY = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
const CHECK_NAN_SNIPPET_BINARY_PACKED = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
/**
 * Template that creates a `KernelFunc` for unary ops.
 * @param opSnippet Op snippet to create `UnaryOpProgram`.
 * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.
 * @param dtype Optional. If set, the result has this dtype. Otherwise, the
 *     result has the same dtype as the first input. This is mainly used in
 *     comparison kernels, such as Equal, Less, Greater, etc.
 */
function unaryKernelFunc({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {
    return ({ inputs, backend }) => {
        const { x } = inputs;
        const webglBackend = backend;
        const $dtype = dtype || x.dtype;
        if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {
            const xData = webglBackend.texData.get(x.dataId);
            const outValues = cpuKernelImpl(xData.values, $dtype);
            return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);
        }
        const shouldUsePackedProgram = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;
        let program;
        if (shouldUsePackedProgram) {
            program = new _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.UnaryOpPackedProgram(x.shape, packedOpSnippet);
        }
        else {
            program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.UnaryOpProgram(x.shape, opSnippet);
        }
        return webglBackend.runWebGLProgram(program, [x], $dtype);
    };
}
/**
 * Template that creates a `KernelFunc` for binary ops.
 * @param opSnippet Op snippet to create `BinaryOpProgram`.
 * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.
 * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true
 *     when creating BinaryOpPackedProgram.
 * @param dtype Optional. If set, the result has this dtype. Otherwise, the
 *     result has the same dtype as the first input. This is mainly used in
 *     comparison kernels, such as Equal, Less, Greater, etc.
 */
function binaryKernelFunc({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {
    return ({ inputs, backend }) => {
        const { a, b } = inputs;
        const webglBackend = backend;
        if (supportsComplex && a.dtype === 'complex64') {
            const aData = webglBackend.texData.get(a.dataId);
            const bData = webglBackend.texData.get(b.dataId);
            const [real, imag] = [
                [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
                [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
            ].map(complexParts => {
                const [aPart, bPart] = complexParts;
                const aHandle = {
                    dataId: aPart.dataId,
                    dtype: aPart.dtype,
                    shape: a.shape
                };
                const bHandle = {
                    dataId: bPart.dataId,
                    dtype: bPart.dtype,
                    shape: b.shape
                };
                const program = new _binaryop_gpu__WEBPACK_IMPORTED_MODULE_3__.BinaryOpProgram(opSnippet, a.shape, b.shape);
                return webglBackend.runWebGLProgram(program, [aHandle, bHandle], (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.upcastType)(aPart.dtype, bPart.dtype));
            });
            const complexOutput = (0,_kernels_Complex__WEBPACK_IMPORTED_MODULE_4__.complex)({ inputs: { real, imag }, backend: webglBackend });
            webglBackend.disposeIntermediateTensorInfo(real);
            webglBackend.disposeIntermediateTensorInfo(imag);
            // TODO(annxingyuan): Implement CPU forwarding for complex inputs.
            return complexOutput;
        }
        const $dtype = dtype || (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.upcastType)(a.dtype, b.dtype);
        if (webglBackend.shouldExecuteOnCPU([a, b]) && cpuKernelImpl != null) {
            const aData = webglBackend.texData.get(a.dataId);
            const bData = webglBackend.texData.get(b.dataId);
            const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, aData.values, bData.values, $dtype);
            const out = webglBackend.makeTensorInfo(outShape, $dtype);
            const outData = webglBackend.texData.get(out.dataId);
            outData.values = outValues;
            return out;
        }
        const shouldUsePackedProgram = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&
            packedOpSnippet != null;
        let program;
        if (shouldUsePackedProgram) {
            program = new _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_5__.BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);
        }
        else {
            program = new _binaryop_gpu__WEBPACK_IMPORTED_MODULE_3__.BinaryOpProgram(opSnippet, a.shape, b.shape);
        }
        return webglBackend.runWebGLProgram(program, [a, b], $dtype);
    };
}
function mapActivationToShaderProgram(activation, packed = false) {
    if (activation === 'linear') {
        if (packed) {
            return _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.LINEAR;
        }
        return _unaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.LINEAR;
    }
    else if (activation === 'relu') {
        if (packed) {
            return _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.RELU;
        }
        return _unaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.RELU;
    }
    else if (activation === 'elu') {
        if (packed) {
            return _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.ELU;
        }
        return _unaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.ELU;
    }
    else if (activation === 'relu6') {
        if (packed) {
            return _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.RELU6;
        }
        return _unaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.RELU6;
    }
    else if (activation === 'prelu') {
        if (packed) {
            return _kernels_Prelu__WEBPACK_IMPORTED_MODULE_6__.PRELU_PACKED;
        }
        return _kernels_Prelu__WEBPACK_IMPORTED_MODULE_6__.PRELU;
    }
    else if (activation === 'leakyrelu') {
        if (packed) {
            return _kernels_LeakyRelu__WEBPACK_IMPORTED_MODULE_7__.LEAKYRELU_PACKED;
        }
        return _kernels_LeakyRelu__WEBPACK_IMPORTED_MODULE_7__.LEAKYRELU;
    }
    throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);
}
//# sourceMappingURL=kernel_funcs_utils.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reduce": () => (/* binding */ reduce)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _mean_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mean_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js");
/* harmony import */ var _reduce_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../reduce_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



// Returns an array of configuration objects that describe each stage of the
// reduction.
function getReductionStages(inShape) {
    const stages = [];
    while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
        const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
        const windowSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOptimalWindowSize(outSize);
        stages.push({
            inSize: outSize,
            windowSize,
            outSize: Math.ceil(outSize / windowSize)
        });
    }
    return stages;
}
function reduce(x, dtype, reductionType, backend) {
    const reductionStages = getReductionStages(x.shape);
    let result = x;
    for (let i = 0; i < reductionStages.length; i++) {
        const { inSize, windowSize, outSize } = reductionStages[i];
        let program;
        let previousResult;
        if (reductionType === 'mean') {
            program = i === 0 ?
                new _mean_gpu__WEBPACK_IMPORTED_MODULE_1__.MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, inSize) :
                new _mean_gpu__WEBPACK_IMPORTED_MODULE_1__.MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize });
        }
        else {
            program = new _reduce_gpu__WEBPACK_IMPORTED_MODULE_2__.ReduceProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, reductionType);
        }
        previousResult = result;
        result = backend.runWebGLProgram(program, [result], dtype);
        if (previousResult.dataId !== x.dataId) {
            backend.disposeIntermediateTensorInfo(previousResult);
        }
    }
    return result;
}
//# sourceMappingURL=reduce.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packedReshape": () => (/* binding */ packedReshape)
/* harmony export */ });
/* harmony import */ var _reshape_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../reshape_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function packedReshape(input, afterShape, backend) {
    const input3DShape = [(0,_webgl_util__WEBPACK_IMPORTED_MODULE_0__.getBatchDim)(input.shape),
        ...(0,_webgl_util__WEBPACK_IMPORTED_MODULE_0__.getRowsCols)(input.shape)];
    const input3D = {
        dtype: input.dtype,
        shape: input3DShape,
        dataId: input.dataId
    };
    const afterShapeAs3D = [(0,_webgl_util__WEBPACK_IMPORTED_MODULE_0__.getBatchDim)(afterShape),
        ...(0,_webgl_util__WEBPACK_IMPORTED_MODULE_0__.getRowsCols)(afterShape)];
    const program = new _reshape_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.ReshapePackedProgram(afterShapeAs3D, input3DShape);
    const preventEagerUnpackingOfOutput = true;
    const output = backend.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);
    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
}
//# sourceMappingURL=reshape.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addImplCPU": () => (/* binding */ addImplCPU),
/* harmony export */   "bincountImplCPU": () => (/* binding */ bincountImplCPU),
/* harmony export */   "bincountReduceImplCPU": () => (/* binding */ bincountReduceImplCPU),
/* harmony export */   "ceilImplCPU": () => (/* binding */ ceilImplCPU),
/* harmony export */   "concatImplCPU": () => (/* binding */ concatImplCPU),
/* harmony export */   "expImplCPU": () => (/* binding */ expImplCPU),
/* harmony export */   "expm1ImplCPU": () => (/* binding */ expm1ImplCPU),
/* harmony export */   "floorImplCPU": () => (/* binding */ floorImplCPU),
/* harmony export */   "gatherV2ImplCPU": () => (/* binding */ gatherV2ImplCPU),
/* harmony export */   "greaterImplCPU": () => (/* binding */ greaterImplCPU),
/* harmony export */   "lessImplCPU": () => (/* binding */ lessImplCPU),
/* harmony export */   "linSpaceImplCPU": () => (/* binding */ linSpaceImplCPU),
/* harmony export */   "logImplCPU": () => (/* binding */ logImplCPU),
/* harmony export */   "maxImplCPU": () => (/* binding */ maxImplCPU),
/* harmony export */   "maximumImplCPU": () => (/* binding */ maximumImplCPU),
/* harmony export */   "minimumImplCPU": () => (/* binding */ minimumImplCPU),
/* harmony export */   "multiplyImplCPU": () => (/* binding */ multiplyImplCPU),
/* harmony export */   "negImplCPU": () => (/* binding */ negImplCPU),
/* harmony export */   "prodImplCPU": () => (/* binding */ prodImplCPU),
/* harmony export */   "simpleAbsImplCPU": () => (/* binding */ simpleAbsImplCPU),
/* harmony export */   "sliceImplCPU": () => (/* binding */ sliceImplCPU),
/* harmony export */   "stridedSliceImplCPU": () => (/* binding */ stridedSliceImplCPU),
/* harmony export */   "subImplCPU": () => (/* binding */ subImplCPU),
/* harmony export */   "rangeImplCPU": () => (/* binding */ rangeImplCPU),
/* harmony export */   "rsqrtImplCPU": () => (/* binding */ rsqrtImplCPU),
/* harmony export */   "tileImplCPU": () => (/* binding */ tileImplCPU),
/* harmony export */   "topKImplCPU": () => (/* binding */ topKImplCPU),
/* harmony export */   "transposeImplCPU": () => (/* binding */ transposeImplCPU),
/* harmony export */   "uniqueImplCPU": () => (/* binding */ uniqueImplCPU)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_backend_cpu_dist_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-backend-cpu/dist/shared */ "./node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Import shared functionality from tfjs-backend-cpu without triggering
// side effects.
// tslint:disable-next-line: no-imports-from-dist

const { addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, lessImpl: lessImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, prodImpl: prodImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, stridedSliceImpl: stridedSliceImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU, } = _tensorflow_tfjs_backend_cpu_dist_shared__WEBPACK_IMPORTED_MODULE_0__;

//# sourceMappingURL=shared.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "absConfig": () => (/* binding */ absConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/* harmony import */ var _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../unaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




const ABS = `return abs(x);`;
function abs(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    // TODO: handle cases when x is complex. Once the cpu implementation
    // can handle complex values, refactor to use unaryKernelFunc.
    if (backend.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {
        const xData = backend.texData.get(x.dataId);
        const outValues = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.simpleAbsImplCPU)(xData.values);
        return backend.makeTensorInfo(x.shape, x.dtype, outValues);
    }
    let program;
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {
        program = new _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.UnaryOpPackedProgram(x.shape, ABS);
    }
    else {
        program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_3__.UnaryOpProgram(x.shape, ABS);
    }
    return backend.runWebGLProgram(program, [x], x.dtype);
}
const absConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Abs,
    backendName: 'webgl',
    kernelFunc: abs
};
//# sourceMappingURL=Abs.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "acosConfig": () => (/* binding */ acosConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ACOS = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
const acos = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: ACOS });
const acosConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Acos,
    backendName: 'webgl',
    kernelFunc: acos,
};
//# sourceMappingURL=Acos.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "acosh": () => (/* binding */ acosh),
/* harmony export */   "acoshConfig": () => (/* binding */ acoshConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ACOSH = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
const acosh = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: ACOSH });
const acoshConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Acosh,
    backendName: 'webgl',
    kernelFunc: acosh,
};
//# sourceMappingURL=Acosh.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addKernelFunc": () => (/* binding */ addKernelFunc),
/* harmony export */   "addConfig": () => (/* binding */ addConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ADD = 'return a + b;';
const addKernelFunc = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({
    opSnippet: ADD,
    packedOpSnippet: ADD,
    supportsComplex: true,
    cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.addImplCPU
});
const addConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Add,
    backendName: 'webgl',
    kernelFunc: addKernelFunc
};
//# sourceMappingURL=Add.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addN": () => (/* binding */ addN),
/* harmony export */   "addNConfig": () => (/* binding */ addNConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _addn_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../addn_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js");
/* harmony import */ var _addn_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addn_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function addN(args) {
    const { inputs, backend } = args;
    const tensors = inputs;
    if (tensors.length === 1) {
        return (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x: tensors[0] }, backend });
    }
    // Limit the number of uploaded textures for optimization.
    if (tensors.length > (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {
        const midIndex = Math.floor(tensors.length / 2);
        const leftSide = addN({ inputs: tensors.slice(0, midIndex), backend });
        const rightSide = addN({ inputs: tensors.slice(midIndex), backend });
        return addN({ inputs: [leftSide, rightSide], backend });
    }
    const dtype = tensors.map(t => t.dtype).reduce((d1, d2) => (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.upcastType)(d1, d2));
    const shapes = tensors.map(t => t.shape);
    // We can make sure shapes are identical in op level.
    const usePackedOp = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK');
    const program = usePackedOp ?
        new _addn_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.AddNPackedProgram(tensors[0].shape, shapes) :
        new _addn_gpu__WEBPACK_IMPORTED_MODULE_3__.AddNProgram(tensors[0].shape, shapes);
    return backend.runWebGLProgram(program, tensors, dtype);
}
const addNConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.AddN,
    backendName: 'webgl',
    kernelFunc: addN
};
//# sourceMappingURL=AddN.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/All.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/All.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "all": () => (/* binding */ all),
/* harmony export */   "allConfig": () => (/* binding */ allConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/reduce */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function all(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, xRank);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('all', axes, xRank);
    const [outShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
    const a2D = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    const reduced = (0,_kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__.reduce)(a2D, a2D.dtype, 'all', backend);
    let res;
    if (keepDims) {
        const newShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(outShape, origAxes);
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
    }
    else {
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
    }
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
        backend.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
}
const allConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.All,
    backendName: 'webgl',
    kernelFunc: all
};
//# sourceMappingURL=All.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "any": () => (/* binding */ any),
/* harmony export */   "anyConfig": () => (/* binding */ anyConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/reduce */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function any(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, xRank);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('any', axes, xRank);
    const [outShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
    const a2D = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    const reduced = (0,_kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__.reduce)(a2D, a2D.dtype, 'any', backend);
    let res;
    if (keepDims) {
        const newShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(outShape, origAxes);
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
    }
    else {
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
    }
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
        backend.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
}
const anyConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Any,
    backendName: 'webgl',
    kernelFunc: any
};
//# sourceMappingURL=Any.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "argMax": () => (/* binding */ argMax),
/* harmony export */   "argMaxConfig": () => (/* binding */ argMaxConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_arg_min_max__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/arg_min_max */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function argMax(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    let axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
        $x = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        intermediateTensorInfos.push($x);
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, $x.shape.length);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('argMax', [axes[0]], $x.shape.length);
    const out = (0,_kernel_utils_arg_min_max__WEBPACK_IMPORTED_MODULE_2__.argMinMaxReduce)(backend, $x, axes[0], 'max');
    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return out;
}
const argMaxConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ArgMax,
    backendName: 'webgl',
    kernelFunc: argMax
};
//# sourceMappingURL=ArgMax.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "argMin": () => (/* binding */ argMin),
/* harmony export */   "argMinConfig": () => (/* binding */ argMinConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_arg_min_max__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/arg_min_max */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function argMin(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    let axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
        $x = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        intermediateTensorInfos.push($x);
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, $x.shape.length);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('argMin', [axes[0]], $x.shape.length);
    const out = (0,_kernel_utils_arg_min_max__WEBPACK_IMPORTED_MODULE_2__.argMinMaxReduce)(backend, $x, axes[0], 'min');
    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return out;
}
const argMinConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ArgMin,
    backendName: 'webgl',
    kernelFunc: argMin
};
//# sourceMappingURL=ArgMin.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asin": () => (/* binding */ asin),
/* harmony export */   "asinConfig": () => (/* binding */ asinConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ASIN = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
const asin = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: ASIN });
const asinConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Asin,
    backendName: 'webgl',
    kernelFunc: asin,
};
//# sourceMappingURL=Asin.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asinh": () => (/* binding */ asinh),
/* harmony export */   "asinhConfig": () => (/* binding */ asinhConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ASINH = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;
const asinh = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: ASINH });
const asinhConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Asinh,
    backendName: 'webgl',
    kernelFunc: asinh,
};
//# sourceMappingURL=Asinh.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "atan": () => (/* binding */ atan),
/* harmony export */   "atanConfig": () => (/* binding */ atanConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ATAN = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  return atan(x);
`;
const atan = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: ATAN });
const atanConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Atan,
    backendName: 'webgl',
    kernelFunc: atan,
};
//# sourceMappingURL=Atan.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "atan2Config": () => (/* binding */ atan2Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const ATAN2 = _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET_BINARY + `
  return atan(a, b);
`;
const ATAN2_PACKED = `
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` +
    _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET_BINARY_PACKED + `
  return result;
`;
const atan2 = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });
const atan2Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Atan2,
    backendName: 'webgl',
    kernelFunc: atan2,
};
//# sourceMappingURL=Atan2.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "atanh": () => (/* binding */ atanh),
/* harmony export */   "atanhConfig": () => (/* binding */ atanhConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ATANH = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
const atanh = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: ATANH });
const atanhConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Atanh,
    backendName: 'webgl',
    kernelFunc: atanh,
};
//# sourceMappingURL=Atanh.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "avgPool": () => (/* binding */ avgPool),
/* harmony export */   "avgPoolConfig": () => (/* binding */ avgPoolConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _pool_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pool_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function avgPool(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, 'avgPool');
    const { filterSize, strides, pad, dimRoundingMode } = attrs;
    const dilations = 1;
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(convInfo.inShape, convInfo.outShape)) {
        return (0,_Identity__WEBPACK_IMPORTED_MODULE_2__.identity)({ inputs: { x }, backend });
    }
    const avgPoolProgram = new _pool_gpu__WEBPACK_IMPORTED_MODULE_3__.Pool2DProgram(convInfo, 'avg', false);
    return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');
}
const avgPoolConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.AvgPool,
    backendName: 'webgl',
    kernelFunc: avgPool
};
//# sourceMappingURL=AvgPool.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "avgPool3D": () => (/* binding */ avgPool3D),
/* harmony export */   "avgPool3DConfig": () => (/* binding */ avgPool3DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _pool_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pool_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function avgPool3D(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad, dimRoundingMode, dataFormat } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);
    const avgPoolProgram = new _pool_gpu__WEBPACK_IMPORTED_MODULE_1__.Pool3DProgram(convInfo, 'avg', false);
    return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');
}
const avgPool3DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.AvgPool3D,
    backendName: 'webgl',
    kernelFunc: avgPool3D
};
//# sourceMappingURL=AvgPool3D.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "avgPool3DGrad": () => (/* binding */ avgPool3DGrad),
/* harmony export */   "avgPoolGrad3DConfig": () => (/* binding */ avgPoolGrad3DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _avg_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../avg_pool_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function avgPool3DGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input } = inputs;
    const x = input;
    const { filterSize, strides, pad, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    const avgPoolBackpropProgram = new _avg_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__.AvgPool3DBackpropProgram(convInfo);
    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
}
const avgPoolGrad3DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.AvgPool3DGrad,
    backendName: 'webgl',
    kernelFunc: avgPool3DGrad
};
//# sourceMappingURL=AvgPool3DGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "avgPoolGrad": () => (/* binding */ avgPoolGrad),
/* harmony export */   "avgPoolGradConfig": () => (/* binding */ avgPoolGradConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _avg_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../avg_pool_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function avgPoolGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input } = inputs;
    const x = input;
    (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)([dy, input], 'avgPoolGrad');
    const { filterSize, strides, pad } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad);
    const avgPoolBackpropProgram = new _avg_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_2__.AvgPool2DBackpropProgram(convInfo);
    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
}
const avgPoolGradConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.AvgPoolGrad,
    backendName: 'webgl',
    kernelFunc: avgPoolGrad
};
//# sourceMappingURL=AvgPoolGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "batchMatMul": () => (/* binding */ batchMatMul),
/* harmony export */   "batchMatMulConfig": () => (/* binding */ batchMatMulConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BatchMatMul_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function batchMatMul(args) {
    const { inputs, backend, attrs } = args;
    const { a, b } = inputs;
    const { transposeA, transposeB } = attrs;
    return (0,_BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__.batchMatMulImpl)({ a, b, transposeA, transposeB, backend });
}
const batchMatMulConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.BatchMatMul,
    backendName: 'webgl',
    kernelFunc: batchMatMul,
};
//# sourceMappingURL=BatchMatMul.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MATMUL_SHARED_DIM_THRESHOLD": () => (/* binding */ MATMUL_SHARED_DIM_THRESHOLD),
/* harmony export */   "batchMatMulImpl": () => (/* binding */ batchMatMulImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _mulmat_packed_gpu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../mulmat_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js");
/* harmony import */ var _Multiply__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Multiply */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Sum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Sum */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */







// Empirically determined minimal shared dimension in matmul before we forward
// to a.mul(b).sum() in order to take advantage of GPU parallelism. See
// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.
const MATMUL_SHARED_DIM_THRESHOLD = 1000;
function batchMatMulImpl({ a, b, transposeA, transposeB, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(outerDimsA);
    const batchDimB = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(outerDimsB);
    const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the ` +
        `same or at least one input batch dimension must be 1. Got input ` +
        `batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
    const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` +
        `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +
        `${b.shape} and transposeA=${transposeA}` +
        ` and transposeB=${transposeB} must match.`);
    const a3dShape = transposeA ?
        [batchDimA, innerShapeA, outerShapeA] :
        [batchDimA, outerShapeA, innerShapeA];
    const b3dShape = transposeB ?
        [batchDimB, outerShapeB, innerShapeB] :
        [batchDimB, innerShapeB, outerShapeB];
    // The rest of the implementation is designed to operate on rank-3 tensors
    const a3d = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: a }, backend, attrs: { shape: a3dShape } });
    const b3d = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: b }, backend, attrs: { shape: b3dShape } });
    const intermediates = [a3d, b3d];
    const batchDim = Math.max(batchDimA, batchDimB);
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    const fusedActivation = activation != null ?
        (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.mapActivationToShaderProgram)(activation, true) :
        null;
    const containsFusedOps = hasBias || hasPreluActivationWeights ||
        hasLeakyreluAlpha || fusedActivation != null;
    let out;
    // Since the matrices are vectors, it is faster to call mul().sum()
    // because sum() is O(sqrt(N)) due to divide-and-conquer.
    if ((outerShapeA === 1 || outerShapeB === 1) &&
        sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
        let aVec = a3d;
        let bVec = b3d;
        if (transposeA) {
            aVec = (0,_Transpose__WEBPACK_IMPORTED_MODULE_3__.transpose)({ inputs: { x: a3d }, backend, attrs: { perm: [0, 2, 1] } });
            intermediates.push(aVec);
        }
        if (transposeB) {
            bVec = (0,_Transpose__WEBPACK_IMPORTED_MODULE_3__.transpose)({ inputs: { x: b3d }, backend, attrs: { perm: [0, 2, 1] } });
            intermediates.push(bVec);
        }
        const shouldReshapeA = outerShapeB !== 1;
        const shouldReshapeB = outerShapeB === 1;
        let aVec3d = aVec;
        if (shouldReshapeA) {
            aVec3d = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({
                inputs: { x: aVec },
                backend,
                attrs: { shape: [batchDim, sharedDim, 1] }
            });
            intermediates.push(aVec3d);
        }
        const axis = outerShapeB === 1 ? 2 : 1;
        let bVec3d = bVec;
        if (shouldReshapeB) {
            bVec3d = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({
                inputs: { x: bVec },
                backend,
                attrs: { shape: [batchDim, 1, sharedDim] }
            });
            intermediates.push(bVec3d);
        }
        const product = (0,_Multiply__WEBPACK_IMPORTED_MODULE_4__.multiply)({ inputs: { a: aVec3d, b: bVec3d }, backend });
        out = (0,_Sum__WEBPACK_IMPORTED_MODULE_5__.sum)({ inputs: { x: product }, backend, attrs: { axis, keepDims: true } });
        intermediates.push(product);
    }
    else {
        const dtype = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.upcastType)(a.dtype, b.dtype);
        const program = new _mulmat_packed_gpu__WEBPACK_IMPORTED_MODULE_6__.MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
        const inputs = [a3d, b3d];
        if (bias != null) {
            inputs.push(bias);
        }
        if (hasPreluActivationWeights) {
            inputs.push(preluActivationWeights);
        }
        if (hasLeakyreluAlpha) {
            const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.createScalarValue(leakyreluAlpha, 'float32'));
            inputs.push($leakyreluAlpha);
            intermediates.push($leakyreluAlpha);
        }
        out = backend.runWebGLProgram(program, inputs, dtype);
    }
    const outReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: out }, backend, attrs: { shape: outShape } });
    intermediates.push(out);
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return outReshaped;
}
//# sourceMappingURL=BatchMatMul_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "batchNorm": () => (/* binding */ batchNorm),
/* harmony export */   "batchNormConfig": () => (/* binding */ batchNormConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _batchnorm_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../batchnorm_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js");
/* harmony import */ var _batchnorm_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../batchnorm_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const batchNorm = ({ inputs, backend, attrs }) => {
    const { x, mean, variance, offset, scale } = inputs;
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(mean.shape.length === variance.shape.length, () => 'Batch normalization gradient requires mean and variance to have ' +
        'equal ranks.');
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(offset == null || mean.shape.length === offset.shape.length, () => 'Batch normalization gradient requires mean and offset to have ' +
        'equal ranks.');
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(scale == null || mean.shape.length === scale.shape.length, () => 'Batch normalization gradient requires mean and scale to have ' +
        'equal ranks.');
    let { varianceEpsilon } = attrs;
    if (varianceEpsilon == null) {
        varianceEpsilon = 0.001;
    }
    const finalInputs = [x, mean, variance];
    let offsetShape = null;
    if (offset != null) {
        offsetShape = offset.shape;
        finalInputs.push(offset);
    }
    let scaleShape = null;
    if (scale != null) {
        scaleShape = scale.shape;
        finalInputs.push(scale);
    }
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_NORMALIZATION') ?
        new _batchnorm_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.BatchNormPackedProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) :
        new _batchnorm_gpu__WEBPACK_IMPORTED_MODULE_2__.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
    const output = backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
    return output;
};
const batchNormConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.FusedBatchNorm,
    backendName: 'webgl',
    kernelFunc: batchNorm,
};
//# sourceMappingURL=BatchNorm.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "batchToSpaceND": () => (/* binding */ batchToSpaceND),
/* harmony export */   "batchToSpaceNDConfig": () => (/* binding */ batchToSpaceNDConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Slice */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




const batchToSpaceND = (args) => {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { blockShape, crops } = attrs;
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(x.shape.length <= 4, () => 'batchToSpaceND for rank > 4 with a WebGL backend not ' +
        'implemented yet');
    const prod = blockShape.reduce((a, b) => a * b);
    const reshaped = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getReshaped(x.shape, blockShape, prod);
    const permuted = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getReshapedPermuted(x.shape, blockShape, prod);
    const sliceBeginCoords = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);
    const toDispose = [];
    const reshapedIntermediate = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x }, backend, attrs: { shape: reshaped } });
    const transposedIntermediate = (0,_Transpose__WEBPACK_IMPORTED_MODULE_2__.transpose)({ inputs: { x: reshapedIntermediate }, backend, attrs: { perm: permuted } });
    const reshapedIntermediate2 = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({
        inputs: { x: transposedIntermediate },
        backend,
        attrs: { shape: reshapedPermuted }
    });
    const sliced = (0,_Slice__WEBPACK_IMPORTED_MODULE_3__.slice)({
        inputs: { x: reshapedIntermediate2 },
        backend,
        attrs: { begin: sliceBeginCoords, size: sliceSize }
    });
    toDispose.push(reshapedIntermediate);
    toDispose.push(transposedIntermediate);
    toDispose.push(reshapedIntermediate2);
    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return sliced;
};
const batchToSpaceNDConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.BatchToSpaceND,
    backendName: 'webgl',
    kernelFunc: batchToSpaceND
};
//# sourceMappingURL=BatchToSpaceND.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bincount": () => (/* binding */ bincount),
/* harmony export */   "bincountConfig": () => (/* binding */ bincountConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function bincount(args) {
    const { inputs, backend, attrs } = args;
    const { x, weights } = inputs;
    const { size } = attrs;
    const xVals = backend.readSync(x.dataId);
    const weightsVals = backend.readSync(weights.dataId);
    const outVals = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.bincountImplCPU)(xVals, weightsVals, weights.dtype, weights.shape, size);
    return backend.makeTensorInfo([size], weights.dtype, outVals);
}
const bincountConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Bincount,
    backendName: 'webgl',
    kernelFunc: bincount
};
//# sourceMappingURL=Bincount.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cast": () => (/* binding */ cast),
/* harmony export */   "castConfig": () => (/* binding */ castConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Complex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/* harmony import */ var _NotEqual__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./NotEqual */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js");
/* harmony import */ var _Real__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Real */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js");
/* harmony import */ var _kernel_utils_int__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../kernel_utils/int */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */







function cast(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { dtype } = attrs;
    // Casting to complex64.
    if (dtype === 'complex64') {
        if (x.dtype === 'complex64') {
            return (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x }, backend });
        }
        // TODO(annxingyuan): Import kernel function once zeros is modularized.
        const zerosTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.zeros(x.shape);
        const floatX = cast({ inputs: { x }, backend, attrs: { dtype: 'float32' } });
        const result = (0,_Complex__WEBPACK_IMPORTED_MODULE_2__.complex)({ inputs: { real: floatX, imag: zerosTensor }, backend });
        zerosTensor.dispose();
        backend.disposeIntermediateTensorInfo(floatX);
        return result;
    }
    // Casting from complex64
    if (x.dtype === 'complex64') {
        const realPart = (0,_Real__WEBPACK_IMPORTED_MODULE_3__.real)({ inputs: { input: x }, backend });
        const result = cast({ inputs: { x: realPart }, backend, attrs: { dtype } });
        backend.disposeIntermediateTensorInfo(realPart);
        return result;
    }
    if (!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.hasEncodingLoss(x.dtype, dtype)) {
        // We don't change the underlying data, since we cast to higher
        // precision.
        const result = (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x }, backend });
        return { dataId: result.dataId, shape: result.shape, dtype };
    }
    if (dtype === 'int32') {
        return (0,_kernel_utils_int__WEBPACK_IMPORTED_MODULE_4__.int)(x, backend);
    }
    if (dtype === 'bool') {
        const zerosTensorInfo = backend.makeTensorInfo([], 'bool', _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getTypedArrayFromDType('bool', 1));
        const binaryInputs = { a: x, b: zerosTensorInfo };
        const result = (0,_NotEqual__WEBPACK_IMPORTED_MODULE_5__.notEqual)({ inputs: binaryInputs, backend });
        backend.disposeIntermediateTensorInfo(zerosTensorInfo);
        return result;
    }
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
}
const castConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Cast,
    backendName: 'webgl',
    kernelFunc: cast
};
//# sourceMappingURL=Cast.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "ceilConfig": () => (/* binding */ ceilConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const CEIL = `return ceil(x);`;
const ceil = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.ceilImplCPU });
const ceilConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Ceil,
    backendName: 'webgl',
    kernelFunc: ceil
};
//# sourceMappingURL=Ceil.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clipByValue": () => (/* binding */ clipByValue),
/* harmony export */   "clipByValueConfig": () => (/* binding */ clipByValueConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _clip_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js");
/* harmony import */ var _clip_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../clip_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function clipByValue(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { clipValueMin, clipValueMax } = attrs;
    let program;
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_CLIP')) {
        program = new _clip_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.ClipPackedProgram(x.shape);
    }
    else {
        program = new _clip_gpu__WEBPACK_IMPORTED_MODULE_2__.ClipProgram(x.shape);
    }
    const customSetup = program.getCustomSetupFunc(clipValueMin, clipValueMax);
    return backend.runWebGLProgram(program, [x], x.dtype, customSetup);
}
const clipByValueConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ClipByValue,
    backendName: 'webgl',
    kernelFunc: clipByValue
};
//# sourceMappingURL=ClipByValue.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "complex": () => (/* binding */ complex),
/* harmony export */   "complexConfig": () => (/* binding */ complexConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


/**
 * In WebGL data is stored in GPU textures which can't be efficiently copied, so
 * complex tensors share data with their real and imaginary components. Complex
 * tensors increment the `complexParentRefCount` properties of the underlying
 * data buckets to prevent them from being disposed, as the engine's disposal
 * logic does not account for data sharing by complex tensors.
 *
 * When a complex tensor is disposed, it will explicitly decrease the
 * `complexParentRefCount` properties of its underlying components.
 */
function complex(args) {
    const { inputs, backend } = args;
    const { real, imag } = inputs;
    const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');
    const complex = backend.texData.get(complexInfo.dataId);
    const realTensorInfo = (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x: real }, backend });
    const realData = backend.texData.get(realTensorInfo.dataId);
    realData.complexParentRefCount++;
    const imagTensorInfo = (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x: imag }, backend });
    const imagData = backend.texData.get(imagTensorInfo.dataId);
    imagData.complexParentRefCount++;
    complex.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
    return complexInfo;
}
const complexConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Complex,
    backendName: 'webgl',
    kernelFunc: complex
};
//# sourceMappingURL=Complex.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "complexAbs": () => (/* binding */ complexAbs),
/* harmony export */   "complexAbsConfig": () => (/* binding */ complexAbsConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _complex_abs_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../complex_abs_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


// Returns a TensorInfo with the complex shape and the dataId of the
// underlying part. We need to do this because a reshaped complex tensor is
// not reflected in its parts.
function makeComplexComponentTensorInfo(complexTensor, complexPart) {
    return {
        dataId: complexPart.dataId,
        dtype: complexPart.dtype,
        shape: complexTensor.shape
    };
}
function complexAbs(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    const xData = backend.texData.get(x.dataId);
    const program = new _complex_abs_gpu__WEBPACK_IMPORTED_MODULE_1__.ComplexAbsProgram(x.shape);
    const programInputs = [
        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),
        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag),
    ];
    return backend.runWebGLProgram(program, programInputs, programInputs[0].dtype);
}
const complexAbsConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ComplexAbs,
    backendName: 'webgl',
    kernelFunc: complexAbs
};
//# sourceMappingURL=ComplexAbs.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concat": () => (/* binding */ concat),
/* harmony export */   "concatConfig": () => (/* binding */ concatConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Concat_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Concat_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function concat(args) {
    const { inputs, backend, attrs } = args;
    const { axis } = attrs;
    const $axis = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, inputs[0].shape)[0];
    const outShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutShape(inputs.map(t => t.shape), $axis);
    if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(outShape) === 0) {
        return backend.makeTensorInfo(outShape, inputs[0].dtype, []);
    }
    // Keep only non-empty tensors (ignore tensors with 0 in their shape).
    const $inputs = inputs.filter(t => _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(t.shape) > 0);
    if ($inputs.length === 1) {
        return (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x: $inputs[0] }, backend });
    }
    const shapes = $inputs.map(t => t.shape);
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertParamsConsistent(shapes, $axis);
    return (0,_Concat_impl__WEBPACK_IMPORTED_MODULE_2__.concatImpl)($inputs, $axis, backend);
}
const concatConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Concat,
    backendName: 'webgl',
    kernelFunc: concat
};
//# sourceMappingURL=Concat.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concatImpl": () => (/* binding */ concatImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _concat_gpu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../concat_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js");
/* harmony import */ var _concat_packed_gpu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../concat_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _Complex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/* harmony import */ var _Imag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Imag */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js");
/* harmony import */ var _Real__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Real */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */








function concatImpl(inputs, axis, backend) {
    const dtype = inputs[0].dtype;
    if (dtype === 'complex64') {
        const reals = inputs.map((t) => (0,_Real__WEBPACK_IMPORTED_MODULE_1__.real)({ inputs: { input: t }, backend }));
        const imags = inputs.map((t) => (0,_Imag__WEBPACK_IMPORTED_MODULE_2__.imag)({ inputs: { input: t }, backend }));
        const realConcated = concatImpl(reals, axis, backend);
        const imagConcated = concatImpl(imags, axis, backend);
        const result = (0,_Complex__WEBPACK_IMPORTED_MODULE_3__.complex)({ inputs: { real: realConcated, imag: imagConcated }, backend });
        reals.forEach(r => backend.disposeIntermediateTensorInfo(r));
        imags.forEach(i => backend.disposeIntermediateTensorInfo(i));
        backend.disposeIntermediateTensorInfo(realConcated);
        backend.disposeIntermediateTensorInfo(imagConcated);
        return result;
    }
    // Run on cpu if dtype is string. For string, the backend represents it
    // as Uint8Array[], where each Uint8Array is a character. Given that the
    // computation is only on the outer array, uploading the whole data onto
    // gpu is wasteful. Also, currently webgl doesn't have a design to
    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we
    // just run the kernel on cpu if dtype is string.
    if (dtype === 'string') {
        const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend);
        const inputsValShapes = tensors2D.map(t => {
            return { vals: backend.readSync(t.dataId), shape: t.shape };
        });
        const simplyConcat = tensors2D[0].shape[0] === 1;
        const outVals = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_4__.concatImplCPU)(inputsValShapes, outShape, dtype, simplyConcat);
        const finalOutShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutShape(inputs.map(t => t.shape), axis);
        const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);
        tensors2D.forEach(t => backend.disposeIntermediateTensorInfo(t));
        return outInfo;
    }
    if (inputs.length > (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {
        const midIndex = Math.floor(inputs.length / 2);
        const leftSide = concatImpl(inputs.slice(0, midIndex), axis, backend);
        const rightSide = concatImpl(inputs.slice(midIndex), axis, backend);
        const result = concatImpl([leftSide, rightSide], axis, backend);
        backend.disposeIntermediateTensorInfo(leftSide);
        backend.disposeIntermediateTensorInfo(rightSide);
        return result;
    }
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_ARRAY_OPERATIONS') &&
        inputs[0].shape.length > 1) {
        const program = new _concat_packed_gpu__WEBPACK_IMPORTED_MODULE_5__.ConcatPackedProgram(inputs.map(t => t.shape), axis);
        return backend.runWebGLProgram(program, inputs, dtype);
    }
    const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend);
    const program = new _concat_gpu__WEBPACK_IMPORTED_MODULE_6__.ConcatProgram(tensors2D.map(t => t.shape));
    const result = backend.runWebGLProgram(program, tensors2D, dtype);
    tensors2D.forEach(r => backend.disposeIntermediateTensorInfo(r));
    const reshapedResult = (0,_Reshape__WEBPACK_IMPORTED_MODULE_7__.reshape)({ inputs: { x: result }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(result);
    return reshapedResult;
}
function computeTensors2D(inputs, axis, backend) {
    // Any concat of n-dimensional tensors across any axis can be reduced to
    // a concatenation of two-dimensional tensors across the axis 1 by first
    // partitioning the axes of the original tensors into those less than the
    // axis to be concatenated and the rest. Then reshape the tensors
    // into a two-dimensional tensor by collapsing these two sets of axes and
    // concatenate the resulting matrices across the axis 1, finally reshaping
    // the result to have the proper shape.
    const outShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutShape(inputs.map(t => t.shape), axis);
    const tensors2D = inputs.map(x => (0,_Reshape__WEBPACK_IMPORTED_MODULE_7__.reshape)({
        inputs: { x },
        attrs: { shape: [-1, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape.slice(axis))] },
        backend
    }));
    return { tensors2D, outShape };
}
//# sourceMappingURL=Concat_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conv2d": () => (/* binding */ conv2d),
/* harmony export */   "conv2DConfig": () => (/* binding */ conv2DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../conv_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js");
/* harmony import */ var _Conv2D_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Conv2D_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function conv2d(args) {
    const { inputs, backend, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad, dataFormat, dilations, dimRoundingMode } = attrs;
    const $dataFormat = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.convertConv2DDataFormat(dataFormat);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false /* depthwise */, $dataFormat);
    let out;
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&
        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&
        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&
        (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {
        out = (0,_Conv2D_impl__WEBPACK_IMPORTED_MODULE_1__.conv2dByMatMul)({ x, filter, convInfo, backend });
    }
    else if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {
        out = (0,_Conv2D_impl__WEBPACK_IMPORTED_MODULE_1__.conv2dWithIm2Row)({ x, filter, convInfo, backend });
    }
    else {
        const program = new _conv_gpu__WEBPACK_IMPORTED_MODULE_2__.Conv2DProgram(convInfo);
        out = backend.runWebGLProgram(program, [x, filter], 'float32');
    }
    const outReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_3__.reshape)({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
    backend.disposeIntermediateTensorInfo(out);
    return outReshaped;
}
const conv2DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Conv2D,
    backendName: 'webgl',
    kernelFunc: conv2d,
};
//# sourceMappingURL=Conv2D.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conv2DBackpropFilter": () => (/* binding */ conv2DBackpropFilter),
/* harmony export */   "conv2DBackpropFilterConfig": () => (/* binding */ conv2DBackpropFilterConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function conv2DBackpropFilter(args) {
    const { inputs, backend, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad, dataFormat, dimRoundingMode, filterShape } = attrs;
    const $dataFormat = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.convertConv2DDataFormat(dataFormat);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad, dimRoundingMode, false /* depthwise */, $dataFormat);
    const program = new _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__.Conv2DDerFilterProgram(convInfo);
    return backend.runWebGLProgram(program, [x, dy], 'float32');
}
const conv2DBackpropFilterConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Conv2DBackpropFilter,
    backendName: 'webgl',
    kernelFunc: conv2DBackpropFilter,
};
//# sourceMappingURL=Conv2DBackpropFilter.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conv2DBackpropInput": () => (/* binding */ conv2DBackpropInput),
/* harmony export */   "conv2DBackpropInputConfig": () => (/* binding */ conv2DBackpropInputConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function conv2DBackpropInput(args) {
    const { inputs, backend, attrs } = args;
    const { dy, filter } = inputs;
    const { inputShape, strides, pad, dataFormat, dimRoundingMode } = attrs;
    const $dataFormat = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.convertConv2DDataFormat(dataFormat);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);
    const program = new _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__.Conv2DDerInputProgram(convInfo);
    return backend.runWebGLProgram(program, [dy, filter], 'float32');
}
const conv2DBackpropInputConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Conv2DBackpropInput,
    backendName: 'webgl',
    kernelFunc: conv2DBackpropInput,
};
//# sourceMappingURL=Conv2DBackpropInput.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conv2dByMatMul": () => (/* binding */ conv2dByMatMul),
/* harmony export */   "conv2dWithIm2Row": () => (/* binding */ conv2dWithIm2Row)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _im2col_packed_gpu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../im2col_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _mulmat_packed_gpu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../mulmat_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/* harmony import */ var _BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BatchMatMul_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */








// For 1x1 kernels that iterate through every point in the input, convolution
// can be expressed as matrix multiplication (without need for memory
// remapping).
function conv2dByMatMul({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the
    // result from 2D to 4D.
    const xShape = x.shape;
    const xTexData = backend.texData.get(x.dataId);
    const sharedMatMulDim = convInfo.inChannels;
    const outerShapeX = xShape[0] * xShape[1] * xShape[2];
    const outerShapeFilter = convInfo.outChannels;
    const isChannelsLast = convInfo.dataFormat === 'channelsLast';
    const transposeA = false;
    const transposeB = false;
    let out;
    const intermediates = [];
    // TODO: Once reduction ops are packed, batchMatMul will always be packed
    // and we can remove this condition.
    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) &&
        sharedMatMulDim > _BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__.MATMUL_SHARED_DIM_THRESHOLD;
    const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;
    if (batchMatMulWillBeUnpacked || !(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_LAZILY_UNPACK') ||
        !(0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_BINARY_OPERATIONS') ||
        !reshapeWillBeExpensive) {
        const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :
            xShape[0] * xShape[2] * xShape[3];
        const xReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({
            inputs: { x },
            backend,
            attrs: { shape: [1, targetShape, convInfo.inChannels] }
        });
        const filterReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({
            inputs: { x: filter },
            backend,
            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        const result = (0,_BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__.batchMatMulImpl)({
            a: xReshaped,
            b: filterReshaped,
            transposeA,
            transposeB,
            backend,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
        out = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: result }, backend, attrs: { shape: convInfo.outShape } });
        intermediates.push(xReshaped);
        intermediates.push(filterReshaped);
        intermediates.push(result);
    }
    else {
        // Following optimization is specific to packed |x| with odd row count
        // (For example, in channelLast mode, 'row count' refers to x.shape[2]):
        // we avoid expensive packed 2x2 reshape by padding row count to next,
        // even number. When x.shape[2] is odd, the result of packed batchMatMul is
        // the same (has the same texture layout and and values in the texture) as
        // it is for even x.shape[2] + 1. We make the odd-rows tensor to look like
        // even-rows tensor before the operation and, after the batchMatMul,
        // fix the even-rows result to have odd number of rows.
        const targetShape = isChannelsLast ?
            xShape[0] * xShape[1] * (xShape[2] + 1) :
            xShape[0] * xShape[2] * (xShape[3] + 1);
        const xReshaped = {
            dataId: x.dataId,
            shape: [1, targetShape, convInfo.inChannels],
            dtype: x.dtype
        };
        // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.
        // Decrementing row count, after batchMatMul->...->compileProgram leads to
        // invalid row count within the reference in GPGPUBinary.inShapeInfos.
        // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos
        // in compileProgram method, but that would affect compilation of all
        // programs - instead, provide a copy here, with even row count, before
        // calling batchMatMul->...->compileProgram and after that, the original
        // xTexData.shape is restored.
        const originalXTexDataShape = xTexData.shape;
        xTexData.shape = xTexData.shape.slice();
        xTexData.shape[xTexData.shape.length - 2]++;
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(_webgl_util__WEBPACK_IMPORTED_MODULE_3__.isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
        const filterReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({
            inputs: { x: filter },
            backend,
            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        intermediates.push(filterReshaped);
        const pointwiseConv = (0,_BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__.batchMatMulImpl)({
            a: xReshaped,
            b: filterReshaped,
            backend,
            transposeA,
            transposeB,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
        const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(pointwiseConvTexData.isPacked, () => 'batchMatMul result is expected to be packed');
        // Restore the input shape to original.
        xTexData.shape = originalXTexDataShape;
        // Set the output shape - there is no need for expensive reshape as data
        // layout is already correct.
        pointwiseConvTexData.shape = convInfo.outShape;
        out = (0,_Identity__WEBPACK_IMPORTED_MODULE_4__.identity)({ inputs: { x: pointwiseConv }, backend });
        out.shape = convInfo.outShape;
        intermediates.push(pointwiseConv);
    }
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return out;
}
// Implements the im2row algorithm as outlined in "High Performance
// Convolutional Neural Networks for Document Processing" (Suvisoft, 2006)
function conv2dWithIm2Row({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    // Rearranges conv2d input so each block to be convolved over forms the
    // column of a new matrix with shape [filterWidth * filterHeight *
    // inChannels, outHeight * outWidth]. The filter is also rearranged so each
    // output channel forms a row of a new matrix with shape [outChannels,
    // filterWidth * filterHeight * inChannels]. The convolution is then
    // computed by multiplying these matrices and reshaping the result.
    const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
    const isChannelsLast = dataFormat === 'channelsLast';
    const sharedDim = filterWidth * filterHeight * inChannels;
    const numCols = outHeight * outWidth;
    const x2ColShape = [sharedDim, numCols];
    const transposeA = true;
    const transposeB = false;
    const intermediates = [];
    const xSqueezed = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x }, backend, attrs: { shape: x.shape.slice(1) } });
    const w2Row = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({
        inputs: { x: filter },
        backend,
        attrs: { shape: [1, sharedDim, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(filter.shape) / sharedDim] }
    });
    intermediates.push(xSqueezed);
    intermediates.push(w2Row);
    const im2ColProgram = new _im2col_packed_gpu__WEBPACK_IMPORTED_MODULE_5__.Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);
    const im2Col = backend.runWebGLProgram(im2ColProgram, [xSqueezed], 'float32');
    const im2ColReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({
        inputs: { x: im2Col },
        backend,
        attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }
    });
    intermediates.push(im2Col);
    intermediates.push(im2ColReshaped);
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    const fusedActivation = activation ? (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_6__.mapActivationToShaderProgram)(activation, true) : null;
    const matmulProgram = new _mulmat_packed_gpu__WEBPACK_IMPORTED_MODULE_7__.MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = [im2ColReshaped, w2Row];
    if (bias) {
        inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
        inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.createScalarValue(leakyreluAlpha, 'float32'));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
    }
    const product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');
    const outShape = isChannelsLast ?
        [1, outHeight, outWidth, convInfo.outChannels] :
        [1, convInfo.outChannels, outHeight, outWidth];
    const out = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: product }, backend, attrs: { shape: outShape } });
    intermediates.push(product);
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return out;
}
//# sourceMappingURL=Conv2D_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conv3D": () => (/* binding */ conv3D),
/* harmony export */   "conv3DConfig": () => (/* binding */ conv3DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function conv3D(args) {
    const { inputs, backend, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad, dilations } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad);
    const program = new _conv_gpu__WEBPACK_IMPORTED_MODULE_1__.Conv3DProgram(convInfo);
    return backend.runWebGLProgram(program, [x, filter], 'float32');
}
const conv3DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Conv3D,
    backendName: 'webgl',
    kernelFunc: conv3D,
};
//# sourceMappingURL=Conv3D.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conv3DBackpropFilterV2": () => (/* binding */ conv3DBackpropFilterV2),
/* harmony export */   "conv3DBackpropFilterV2Config": () => (/* binding */ conv3DBackpropFilterV2Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function conv3DBackpropFilterV2(args) {
    const { inputs, backend, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad, filterShape } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad);
    const program = new _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__.Conv3DDerFilterProgram(convInfo);
    return backend.runWebGLProgram(program, [x, dy], 'float32');
}
const conv3DBackpropFilterV2Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Conv3DBackpropFilterV2,
    backendName: 'webgl',
    kernelFunc: conv3DBackpropFilterV2
};
//# sourceMappingURL=Conv3DBackpropFilterV2.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conv3DBackpropInput": () => (/* binding */ conv3DBackpropInput),
/* harmony export */   "conv3DBackpropInputConfig": () => (/* binding */ conv3DBackpropInputConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function conv3DBackpropInput(args) {
    const { inputs, backend, attrs } = args;
    const { dy, filter } = inputs;
    const { pad, strides, inputShape } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv3DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad);
    const program = new _conv_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__.Conv3DDerInputProgram(convInfo);
    return backend.runWebGLProgram(program, [dy, filter], 'float32');
}
const conv3DBackpropInputConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Conv3DBackpropInputV2,
    backendName: 'webgl',
    kernelFunc: conv3DBackpropInput,
};
//# sourceMappingURL=Conv3DBackpropInputV2.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "cosConfig": () => (/* binding */ cosConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const COS = _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET_UNARY + `
  return cos(x);
`;
const cos = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: COS });
const cosConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Cos,
    backendName: 'webgl',
    kernelFunc: cos,
};
//# sourceMappingURL=Cos.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cosh": () => (/* binding */ cosh),
/* harmony export */   "coshConfig": () => (/* binding */ coshConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
const cosh = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: COSH });
const coshConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Cosh,
    backendName: 'webgl',
    kernelFunc: cosh,
};
//# sourceMappingURL=Cosh.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cropAndResize": () => (/* binding */ cropAndResize),
/* harmony export */   "cropAndResizeConfig": () => (/* binding */ cropAndResizeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _crop_and_resize_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crop_and_resize_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const cropAndResize = (args) => {
    const { inputs, backend, attrs } = args;
    const { image, boxes, boxInd } = inputs;
    const { cropSize, method, extrapolationValue } = attrs;
    const program = new _crop_and_resize_gpu__WEBPACK_IMPORTED_MODULE_1__.CropAndResizeProgram(image.shape, boxes.shape, cropSize, method, extrapolationValue);
    return backend.runWebGLProgram(program, [image, boxes, boxInd], 'float32');
};
const cropAndResizeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.CropAndResize,
    backendName: 'webgl',
    kernelFunc: cropAndResize
};
//# sourceMappingURL=CropAndResize.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cumsum": () => (/* binding */ cumsum),
/* harmony export */   "cumsumConfig": () => (/* binding */ cumsumConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _cumsum_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cumsum_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/cumsum_gpu.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function cumsum(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis, exclusive, reverse } = attrs;
    const xRank = x.shape.length;
    const permutation = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation([axis], xRank);
    let permutedX = x;
    if (permutation != null) {
        permutedX = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutation } });
    }
    const permutedAxis = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(1, xRank)[0];
    if (permutedAxis !== xRank - 1) {
        throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.shape.length - 1} ` +
            `but got axis=${axis}`);
    }
    const size = permutedX.shape[permutedAxis];
    let result = (0,_Identity__WEBPACK_IMPORTED_MODULE_2__.identity)({ inputs: { x: permutedX }, backend });
    // Use cumsum parallel algorithm, ref:
    // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda
    for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {
        const program = new _cumsum_gpu__WEBPACK_IMPORTED_MODULE_3__.CumSumProgram(permutedX.shape, false, reverse);
        const customSetup = program.getCustomSetupFunc(i);
        const prevResult = result;
        result =
            backend.runWebGLProgram(program, [result], result.dtype, customSetup);
        backend.disposeIntermediateTensorInfo(prevResult);
    }
    // For exclusive cumsum, shift the end result in the direction of sum
    // and add 0 to the front index.
    if (exclusive) {
        const program = new _cumsum_gpu__WEBPACK_IMPORTED_MODULE_3__.CumSumProgram(permutedX.shape, exclusive, reverse);
        const prevResult = result;
        result = backend.runWebGLProgram(program, [result], result.dtype);
        backend.disposeIntermediateTensorInfo(prevResult);
    }
    if (permutation != null) {
        const reversePermutation = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getUndoAxesPermutation(permutation);
        const reverseTransposedResult = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x: result }, backend, attrs: { perm: reversePermutation } });
        backend.disposeIntermediateTensorInfo(result);
        backend.disposeIntermediateTensorInfo(permutedX);
        return reverseTransposedResult;
    }
    return result;
}
const cumsumConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Cumsum,
    backendName: 'webgl',
    kernelFunc: cumsum
};
//# sourceMappingURL=Cumsum.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "denseBincount": () => (/* binding */ denseBincount),
/* harmony export */   "denseBincountConfig": () => (/* binding */ denseBincountConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function denseBincount(args) {
    const { inputs, backend, attrs } = args;
    const { x, weights } = inputs;
    const { size, binaryOutput } = attrs;
    if (x.shape.length === 1) {
        const xVals = backend.readSync(x.dataId);
        const weightsVals = backend.readSync(weights.dataId);
        const outVals = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.bincountImplCPU)(xVals, weightsVals, weights.dtype, weights.shape, size);
        return backend.makeTensorInfo([size], weights.dtype, outVals);
    }
    else if (x.shape.length === 2) {
        const xBuf = backend.bufferSync(x);
        const weightsBuf = backend.bufferSync(weights);
        const outBuf = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.bincountReduceImplCPU)(xBuf, weightsBuf, size, binaryOutput);
        return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank` +
        `${x.shape.length}.`);
}
const denseBincountConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.DenseBincount,
    backendName: 'webgl',
    kernelFunc: denseBincount
};
//# sourceMappingURL=DenseBincount.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "depthToSpace": () => (/* binding */ depthToSpace),
/* harmony export */   "depthToSpaceConfig": () => (/* binding */ depthToSpaceConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _depth_to_space_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../depth_to_space_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function depthToSpace(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { blockSize, dataFormat } = attrs;
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
    const batchSize = x.shape[0];
    const inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];
    const inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];
    const inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const outputShape = (dataFormat === 'NHWC') ?
        [batchSize, outputHeight, outputWidth, outputDepth] :
        [batchSize, outputDepth, outputHeight, outputWidth];
    const program = new _depth_to_space_gpu__WEBPACK_IMPORTED_MODULE_1__.DepthToSpaceProgram(outputShape, blockSize, dataFormat);
    return backend.runWebGLProgram(program, [x], x.dtype);
}
const depthToSpaceConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.DepthToSpace,
    backendName: 'webgl',
    kernelFunc: depthToSpace
};
//# sourceMappingURL=DepthToSpace.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "depthwiseConv2dNative": () => (/* binding */ depthwiseConv2dNative),
/* harmony export */   "depthwiseConv2dNativeConfig": () => (/* binding */ depthwiseConv2dNativeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_gpu_depthwise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../conv_gpu_depthwise */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js");
/* harmony import */ var _conv_packed_gpu_depthwise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_packed_gpu_depthwise */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function depthwiseConv2dNative(args) {
    const { inputs, backend, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad, dilations, dimRoundingMode } = attrs;
    let $dilations = dilations;
    if ($dilations == null) {
        $dilations = [1, 1];
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +
        `1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);
    let program;
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_DEPTHWISECONV') && convInfo.strideWidth <= 2 &&
        convInfo.outChannels / convInfo.inChannels === 1) {
        program = new _conv_packed_gpu_depthwise__WEBPACK_IMPORTED_MODULE_1__.DepthwiseConvPacked2DProgram(convInfo);
    }
    else {
        program = new _conv_gpu_depthwise__WEBPACK_IMPORTED_MODULE_2__.DepthwiseConv2DProgram(convInfo);
    }
    return backend.runWebGLProgram(program, [x, filter], 'float32');
}
const depthwiseConv2dNativeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.DepthwiseConv2dNative,
    backendName: 'webgl',
    kernelFunc: depthwiseConv2dNative,
};
//# sourceMappingURL=DepthwiseConv2dNative.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "depthwiseConv2dNativeBackpropFilter": () => (/* binding */ depthwiseConv2dNativeBackpropFilter),
/* harmony export */   "depthwiseConv2dNativeBackpropFilterConfig": () => (/* binding */ depthwiseConv2dNativeBackpropFilterConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_backprop_gpu_depthwise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_backprop_gpu_depthwise */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function depthwiseConv2dNativeBackpropFilter(args) {
    const { inputs, backend, attrs } = args;
    const { x, dy } = inputs;
    const { strides, dilations, pad, dimRoundingMode, filterShape } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);
    const program = new _conv_backprop_gpu_depthwise__WEBPACK_IMPORTED_MODULE_1__.DepthwiseConv2DDerFilterProgram(convInfo);
    return backend.runWebGLProgram(program, [x, dy], 'float32');
}
const depthwiseConv2dNativeBackpropFilterConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.DepthwiseConv2dNativeBackpropFilter,
    backendName: 'webgl',
    kernelFunc: depthwiseConv2dNativeBackpropFilter
};
//# sourceMappingURL=DepthwiseConv2dNativeBackpropFilter.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "depthwiseConv2dNativeBackpropInput": () => (/* binding */ depthwiseConv2dNativeBackpropInput),
/* harmony export */   "depthwiseConv2dNativeBackpropInputConfig": () => (/* binding */ depthwiseConv2dNativeBackpropInputConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_backprop_gpu_depthwise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../conv_backprop_gpu_depthwise */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function depthwiseConv2dNativeBackpropInput(args) {
    const { inputs, backend, attrs } = args;
    const { dy, filter } = inputs;
    const { strides, dilations, pad, dimRoundingMode, inputShape } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);
    const program = new _conv_backprop_gpu_depthwise__WEBPACK_IMPORTED_MODULE_1__.DepthwiseConv2DDerInputProgram(convInfo);
    return backend.runWebGLProgram(program, [dy, filter], 'float32');
}
const depthwiseConv2dNativeBackpropInputConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.DepthwiseConv2dNativeBackpropInput,
    backendName: 'webgl',
    kernelFunc: depthwiseConv2dNativeBackpropInput
};
//# sourceMappingURL=DepthwiseConv2dNativeBackpropInput.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "diag": () => (/* binding */ diag),
/* harmony export */   "diagConfig": () => (/* binding */ diagConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _diag_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../diag_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function diag(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    const outShape = [...x.shape, ...x.shape];
    const xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape);
    const flat = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x }, backend, attrs: { shape: [xSize] } });
    const program = new _diag_gpu__WEBPACK_IMPORTED_MODULE_2__.DiagProgram(xSize);
    const res = backend.runWebGLProgram(program, [flat], flat.dtype);
    const out = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: res }, backend, attrs: { shape: outShape } });
    backend.disposeIntermediateTensorInfo(flat);
    backend.disposeIntermediateTensorInfo(res);
    return out;
}
const diagConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Diag,
    backendName: 'webgl',
    kernelFunc: diag
};
//# sourceMappingURL=Diag.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dilation2D": () => (/* binding */ dilation2D),
/* harmony export */   "dilation2DConfig": () => (/* binding */ dilation2DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _dilation_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dilation_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function dilation2D(args) {
    const { inputs, backend, attrs } = args;
    const { x, filter } = inputs;
    const { strides, pad, dilations } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations);
    let out;
    const program = new _dilation_gpu__WEBPACK_IMPORTED_MODULE_1__.Dilation2DProgram(convInfo);
    out = backend.runWebGLProgram(program, [x, filter], 'float32');
    const outReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
    backend.disposeIntermediateTensorInfo(out);
    return outReshaped;
}
const dilation2DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Dilation2D,
    backendName: 'webgl',
    kernelFunc: dilation2D,
};
//# sourceMappingURL=Dilation2D.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eluConfig": () => (/* binding */ eluConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
const ELU_PACKED = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
const elu = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: ELU, packedOpSnippet: ELU_PACKED });
const eluConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Elu,
    backendName: 'webgl',
    kernelFunc: elu
};
//# sourceMappingURL=Elu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eluGrad": () => (/* binding */ eluGrad),
/* harmony export */   "eluGradConfig": () => (/* binding */ eluGradConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;
const ELU_DER_PACKED = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
const eluGrad = (args) => {
    const { inputs, backend } = args;
    const { dy, y } = inputs;
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?
        new _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) :
        new _binaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.BinaryOpProgram(ELU_DER, dy.shape, y.shape);
    return backend.runWebGLProgram(program, [dy, y], dy.dtype);
};
const eluGradConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.EluGrad,
    backendName: 'webgl',
    kernelFunc: eluGrad
};
//# sourceMappingURL=EluGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equal": () => (/* binding */ equal),
/* harmony export */   "equalConfig": () => (/* binding */ equalConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const PACKED_EQUAL = `
  return vec4(equal(a, b));
`;
const EQUAL = `return float(a == b);`;
const equal = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: EQUAL, packedOpSnippet: PACKED_EQUAL, dtype: 'bool' });
const equalConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Equal,
    backendName: 'webgl',
    kernelFunc: equal
};
//# sourceMappingURL=Equal.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "erf": () => (/* binding */ erf),
/* harmony export */   "erfConfig": () => (/* binding */ erfConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.ERF_P};
  float a1 = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.ERF_A1};
  float a2 = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.ERF_A2};
  float a3 = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.ERF_A3};
  float a4 = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.ERF_A4};
  float a5 = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
const erf = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: ERF });
const erfConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Erf,
    backendName: 'webgl',
    kernelFunc: erf,
};
//# sourceMappingURL=Erf.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EXP": () => (/* binding */ EXP),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "expConfig": () => (/* binding */ expConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const EXP = `return exp(x);`;
const exp = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: EXP, packedOpSnippet: EXP, cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.expImplCPU });
const expConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Exp,
    backendName: 'webgl',
    kernelFunc: exp
};
//# sourceMappingURL=Exp.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expandDims": () => (/* binding */ expandDims),
/* harmony export */   "expandDimsConfig": () => (/* binding */ expandDimsConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function expandDims(args) {
    const { inputs, attrs, backend } = args;
    const { dim } = attrs;
    const { input } = inputs;
    const inputRank = input.shape.length;
    const newShape = input.shape.slice();
    let $dim = dim;
    if (dim < 0) {
        // Negative value is counted from the tail of rank.
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
        $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: input }, backend, attrs: { shape: newShape } });
}
const expandDimsConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ExpandDims,
    backendName: 'webgl',
    kernelFunc: expandDims,
};
//# sourceMappingURL=ExpandDims.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expm1": () => (/* binding */ expm1),
/* harmony export */   "expm1Config": () => (/* binding */ expm1Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const EXPM1 = `return exp(x) - 1.0;`;
const expm1 = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.expm1ImplCPU });
const expm1Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Expm1,
    backendName: 'webgl',
    kernelFunc: expm1
};
//# sourceMappingURL=Expm1.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fft": () => (/* binding */ fft),
/* harmony export */   "fftConfig": () => (/* binding */ fftConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _FFT_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FFT_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function fft(args) {
    const { inputs, backend } = args;
    const { input } = inputs;
    return (0,_FFT_impl__WEBPACK_IMPORTED_MODULE_1__.fftImpl)(input, false /* inverse */, backend);
}
const fftConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.FFT,
    backendName: 'webgl',
    kernelFunc: fft
};
//# sourceMappingURL=FFT.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fftImpl": () => (/* binding */ fftImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _fft_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fft_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js");
/* harmony import */ var _Complex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function fftImpl(x, inverse, backend) {
    const xData = backend.texData.get(x.dataId);
    const inputSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape);
    // Collapse all outer dimensions to a single batch dimension.
    const innerDimensionSize = x.shape[x.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x }, backend, attrs: { shape: [batch, innerDimensionSize] } });
    const xShape = input2D.shape;
    const realProgram = new _fft_gpu__WEBPACK_IMPORTED_MODULE_2__.FFTProgram('real', xShape, inverse);
    const imagProgram = new _fft_gpu__WEBPACK_IMPORTED_MODULE_2__.FFTProgram('imag', xShape, inverse);
    const inputs = [
        {
            dataId: xData.complexTensorInfos.real.dataId,
            dtype: xData.complexTensorInfos.real.dtype,
            shape: xShape
        },
        {
            dataId: xData.complexTensorInfos.imag.dataId,
            dtype: xData.complexTensorInfos.imag.dtype,
            shape: xShape
        }
    ];
    const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');
    const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');
    const complexOutput = (0,_Complex__WEBPACK_IMPORTED_MODULE_3__.complex)({ inputs: { real: realPart, imag: imagPart }, backend });
    backend.disposeIntermediateTensorInfo(realPart);
    backend.disposeIntermediateTensorInfo(imagPart);
    const complexOutputReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: complexOutput }, backend, attrs: { shape: x.shape } });
    backend.disposeIntermediateTensorInfo(input2D);
    backend.disposeIntermediateTensorInfo(complexOutput);
    return complexOutputReshaped;
}
//# sourceMappingURL=FFT_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fill": () => (/* binding */ fill),
/* harmony export */   "fillConfig": () => (/* binding */ fillConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _fill_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fill_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function fill(args) {
    const { backend, attrs } = args;
    const { shape, value } = attrs;
    let { dtype } = attrs;
    dtype = dtype || _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.inferDtype(value);
    if (dtype === 'string') {
        // String type should be handled in CPU memory.
        const values = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.getArrayFromDType(dtype, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(shape));
        values.fill(value);
        return backend.makeTensorInfo(shape, dtype, values);
    }
    else {
        const program = new _fill_gpu__WEBPACK_IMPORTED_MODULE_1__.FillProgram(shape, value);
        const customSetup = program.getCustomSetupFunc(value);
        return backend.runWebGLProgram(program, [], dtype, customSetup);
    }
}
const fillConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Fill,
    backendName: 'webgl',
    kernelFunc: fill
};
//# sourceMappingURL=Fill.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flipLeftRightConfig": () => (/* binding */ flipLeftRightConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _flip_left_right_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flip_left_right_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const flipLeftRightConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.FlipLeftRight,
    backendName: 'webgl',
    kernelFunc: ({ inputs, backend }) => {
        const { image } = inputs;
        const webglBackend = backend;
        const program = new _flip_left_right_gpu__WEBPACK_IMPORTED_MODULE_1__.FlipLeftRightProgram(image.shape);
        const output = webglBackend.runWebGLProgram(program, [image], image.dtype);
        return output;
    }
};
//# sourceMappingURL=FlipLeftRight.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "floorConfig": () => (/* binding */ floorConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const FLOOR = `return floor(x);`;
const floor = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.floorImplCPU });
const floorConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Floor,
    backendName: 'webgl',
    kernelFunc: floor,
};
//# sourceMappingURL=Floor.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "floorDiv": () => (/* binding */ floorDiv),
/* harmony export */   "floorDivConfig": () => (/* binding */ floorDivConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


// We use native integer division to deal with floating point imprecision. Since
// we implement floor division and glsl implements truncated division, we
// correct for this by subtracting 1 from result when the result is negative and
// there is a remainder.
const INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
const INT_DIV_PACKED = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
const floorDiv = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: 'int32' });
const floorDivConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.FloorDiv,
    backendName: 'webgl',
    kernelFunc: floorDiv
};
//# sourceMappingURL=FloorDiv.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromPixelsConfig": () => (/* binding */ fromPixelsConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/* harmony import */ var _FromPixels_utils_from_pixels_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FromPixels_utils/from_pixels_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js");
/* harmony import */ var _FromPixels_utils_from_pixels_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FromPixels_utils/from_pixels_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





const fromPixelsConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.FromPixels,
    backendName: 'webgl',
    kernelFunc: fromPixels,
};
let fromPixels2DContext;
function fromPixels(args) {
    const { inputs, backend, attrs } = args;
    let { pixels } = inputs;
    const { numChannels } = attrs;
    const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&
        pixels instanceof HTMLVideoElement;
    const isImage = typeof (HTMLImageElement) !== 'undefined' &&
        pixels instanceof HTMLImageElement;
    const isImageBitmap = typeof (ImageBitmap) !== 'undefined' &&
        pixels instanceof ImageBitmap;
    const [width, height] = isVideo ?
        [
            pixels.videoWidth,
            pixels.videoHeight
        ] :
        [pixels.width, pixels.height];
    const texShape = [height, width];
    const outShape = [height, width, numChannels];
    if (isImage || isVideo || isImageBitmap) {
        if (fromPixels2DContext == null) {
            fromPixels2DContext = document.createElement('canvas').getContext('2d');
        }
        fromPixels2DContext.canvas.width = width;
        fromPixels2DContext.canvas.height = height;
        fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
        pixels = fromPixels2DContext.canvas;
    }
    const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');
    // This is a byte texture with pixels.
    backend.texData.get(tempPixelHandle.dataId).usage = _tex_util__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.PIXELS;
    backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK') ?
        new _FromPixels_utils_from_pixels_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.FromPixelsPackedProgram(outShape) :
        new _FromPixels_utils_from_pixels_gpu__WEBPACK_IMPORTED_MODULE_3__.FromPixelsProgram(outShape);
    const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');
    backend.disposeData(tempPixelHandle.dataId);
    return res;
}
//# sourceMappingURL=FromPixels.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FromPixelsProgram": () => (/* binding */ FromPixelsProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class FromPixelsProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_0__.getGlslDifferences)();
        const [height, width,] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
}
//# sourceMappingURL=from_pixels_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FromPixelsPackedProgram": () => (/* binding */ FromPixelsPackedProgram)
/* harmony export */ });
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class FromPixelsPackedProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        this.packedInputs = false;
        this.packedOutput = true;
        const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_0__.getGlslDifferences)();
        const [height, width,] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
    }
}
//# sourceMappingURL=from_pixels_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fusedConv2d": () => (/* binding */ fusedConv2d),
/* harmony export */   "fusedConv2DConfig": () => (/* binding */ fusedConv2DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../conv_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _Conv2D_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Conv2D_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





function fusedConv2d(args) {
    const { inputs, backend, attrs } = args;
    const { x, filter, bias, preluActivationWeights } = inputs;
    const { strides, pad, dataFormat, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    const $dataFormat = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.convertConv2DDataFormat(dataFormat);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false /* depthwise */, $dataFormat);
    let out;
    const intermediates = [];
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&
        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&
        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&
        (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {
        out = (0,_Conv2D_impl__WEBPACK_IMPORTED_MODULE_1__.conv2dByMatMul)({
            x,
            filter,
            convInfo,
            backend,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
    }
    else if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {
        out = (0,_Conv2D_impl__WEBPACK_IMPORTED_MODULE_1__.conv2dWithIm2Row)({
            x,
            filter,
            convInfo,
            backend,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
    }
    else {
        const hasBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        const hasLeakyreluAlpha = activation === 'leakyrelu';
        const fusedActivation = activation ? (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.mapActivationToShaderProgram)(activation, false) : null;
        const program = new _conv_gpu__WEBPACK_IMPORTED_MODULE_3__.Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
        const inputs = [x, filter];
        if (bias) {
            inputs.push(bias);
        }
        if (preluActivationWeights) {
            inputs.push(preluActivationWeights);
        }
        if (hasLeakyreluAlpha) {
            const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.createScalarValue(leakyreluAlpha, 'float32'));
            inputs.push($leakyreluAlpha);
            intermediates.push($leakyreluAlpha);
        }
        out = backend.runWebGLProgram(program, inputs, 'float32');
    }
    const outReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_4__.reshape)({ inputs: { x: out }, backend, attrs: { shape: convInfo.outShape } });
    intermediates.push(out);
    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return outReshaped;
}
const fusedConv2DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.FusedConv2D,
    backendName: 'webgl',
    kernelFunc: fusedConv2d,
};
//# sourceMappingURL=FusedConv2D.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fusedDepthwiseConv2D": () => (/* binding */ fusedDepthwiseConv2D),
/* harmony export */   "fusedDepthwiseConv2DConfig": () => (/* binding */ fusedDepthwiseConv2DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _conv_gpu_depthwise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../conv_gpu_depthwise */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js");
/* harmony import */ var _conv_packed_gpu_depthwise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../conv_packed_gpu_depthwise */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function fusedDepthwiseConv2D(args) {
    const { inputs, backend, attrs } = args;
    const { x, filter, bias, preluActivationWeights } = inputs;
    const { strides, pad, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    const intermediates = [];
    let $dilations = dilations;
    if ($dilations == null) {
        $dilations = [1, 1];
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +
        `1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);
    const shouldPackDepthwiseConv = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_DEPTHWISECONV') &&
        convInfo.strideWidth <= 2 &&
        convInfo.outChannels / convInfo.inChannels === 1;
    const fusedActivation = activation ?
        (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.mapActivationToShaderProgram)(activation, shouldPackDepthwiseConv) :
        null;
    const programInputs = [x, filter];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    if (hasBias) {
        programInputs.push(bias);
    }
    if (hasPreluActivationWeights) {
        programInputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.createScalarValue(leakyreluAlpha, 'float32'));
        programInputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
    }
    let program;
    if (shouldPackDepthwiseConv) {
        program = new _conv_packed_gpu_depthwise__WEBPACK_IMPORTED_MODULE_2__.DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    }
    else {
        program = new _conv_gpu_depthwise__WEBPACK_IMPORTED_MODULE_3__.DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    }
    const result = backend.runWebGLProgram(program, programInputs, 'float32');
    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return result;
}
const fusedDepthwiseConv2DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.FusedDepthwiseConv2D,
    backendName: 'webgl',
    kernelFunc: fusedDepthwiseConv2D,
};
//# sourceMappingURL=FusedDepthwiseConv2D.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gatherNd": () => (/* binding */ gatherNd),
/* harmony export */   "gatherNdConfig": () => (/* binding */ gatherNdConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _gather_nd_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gather_nd_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function gatherNd(args) {
    const { inputs, backend } = args;
    const { params, indices } = inputs;
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const [resultShape, numSlices, sliceSize, strides] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.prepareAndValidate(params, indices);
    const flattenIndices = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: indices }, backend, attrs: { shape: [numSlices, sliceRank] } });
    const flattenX = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({
        inputs: { x: params },
        backend,
        attrs: { shape: [(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(params.shape) / sliceSize), sliceSize] }
    });
    const program = new _gather_nd_gpu__WEBPACK_IMPORTED_MODULE_2__.GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);
    const res = backend.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);
    const reshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: res }, backend, attrs: { shape: resultShape } });
    backend.disposeIntermediateTensorInfo(flattenIndices);
    backend.disposeIntermediateTensorInfo(flattenX);
    backend.disposeIntermediateTensorInfo(res);
    return reshaped;
}
const gatherNdConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.GatherNd,
    backendName: 'webgl',
    kernelFunc: gatherNd
};
//# sourceMappingURL=GatherNd.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gatherV2": () => (/* binding */ gatherV2),
/* harmony export */   "gatherV2Config": () => (/* binding */ gatherV2Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _gather_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gather_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function gatherV2(args) {
    const { inputs, backend, attrs } = args;
    const { x, indices } = inputs;
    const { axis, batchDims } = attrs;
    const parsedAxis = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape)[0];
    const shapeInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
    const indicesSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(indices.shape);
    const toDispose = [];
    const flattenX = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({
        inputs: { x },
        backend,
        attrs: {
            shape: [
                shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,
                shapeInfo.sliceSize
            ]
        }
    });
    const flattenIndex = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({
        inputs: { x: indices },
        backend,
        attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
    });
    toDispose.push(flattenX);
    toDispose.push(flattenIndex);
    const flattenOutputShape = [
        shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,
        shapeInfo.sliceSize
    ];
    if (backend.shouldExecuteOnCPU([x, indices]) || x.dtype === 'string') {
        const indicesBuf = backend.bufferSync(flattenIndex);
        const xBuf = backend.bufferSync(flattenX);
        const outBuf = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.gatherV2ImplCPU)(xBuf, indicesBuf, flattenOutputShape);
        toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));
        return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new _gather_gpu__WEBPACK_IMPORTED_MODULE_3__.GatherProgram(flattenX.shape, flattenOutputShape);
    const res = backend.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);
    toDispose.push(res);
    const reshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: res }, backend, attrs: { shape: shapeInfo.outputShape } });
    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return reshaped;
}
const gatherV2Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.GatherV2,
    backendName: 'webgl',
    kernelFunc: gatherV2
};
//# sourceMappingURL=GatherV2.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "greater": () => (/* binding */ greater),
/* harmony export */   "greaterConfig": () => (/* binding */ greaterConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const GREATER = `return float(a > b);`;
const GREATER_PACKED = `
  return vec4(greaterThan(a, b));
`;
const greater = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({
    opSnippet: GREATER,
    packedOpSnippet: GREATER_PACKED,
    cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.greaterImplCPU,
    dtype: 'bool'
});
const greaterConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Greater,
    backendName: 'webgl',
    kernelFunc: greater
};
//# sourceMappingURL=Greater.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "greaterEqual": () => (/* binding */ greaterEqual),
/* harmony export */   "greaterEqualConfig": () => (/* binding */ greaterEqualConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const GREATER_EQUAL = `return float(a >= b);`;
const GREATER_EQUAL_PACKED = `
  return vec4(greaterThanEqual(a, b));
`;
const greaterEqual = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({
    opSnippet: GREATER_EQUAL,
    packedOpSnippet: GREATER_EQUAL_PACKED,
    dtype: 'bool'
});
const greaterEqualConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.GreaterEqual,
    backendName: 'webgl',
    kernelFunc: greaterEqual
};
//# sourceMappingURL=GreaterEqual.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ifft": () => (/* binding */ ifft),
/* harmony export */   "ifftConfig": () => (/* binding */ ifftConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _FFT_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FFT_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function ifft(args) {
    const { inputs, backend } = args;
    const { input } = inputs;
    return (0,_FFT_impl__WEBPACK_IMPORTED_MODULE_1__.fftImpl)(input, true /* inverse */, backend);
}
const ifftConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.IFFT,
    backendName: 'webgl',
    kernelFunc: ifft
};
//# sourceMappingURL=IFFT.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "identityConfig": () => (/* binding */ identityConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function identity(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    backend.incRef(x.dataId);
    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
}
const identityConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Identity,
    backendName: 'webgl',
    kernelFunc: identity
};
//# sourceMappingURL=Identity.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "imag": () => (/* binding */ imag),
/* harmony export */   "imagConfig": () => (/* binding */ imagConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function imag(args) {
    const { inputs, backend } = args;
    const { input } = inputs;
    const inputData = backend.texData.get(input.dataId);
    return (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x: inputData.complexTensorInfos.imag }, backend });
}
const imagConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Imag,
    backendName: 'webgl',
    kernelFunc: imag
};
//# sourceMappingURL=Imag.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFinite": () => (/* binding */ isFinite),
/* harmony export */   "isFiniteConfig": () => (/* binding */ isFiniteConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
const isFinite = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: IS_FINITE, dtype: 'bool' });
const isFiniteConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.IsFinite,
    backendName: 'webgl',
    kernelFunc: isFinite,
};
//# sourceMappingURL=IsFinite.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isInf": () => (/* binding */ isInf),
/* harmony export */   "isInfConfig": () => (/* binding */ isInfConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const IS_INF = `return float(isinf(x));`;
const isInf = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: IS_INF, dtype: 'bool' });
const isInfConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.IsInf,
    backendName: 'webgl',
    kernelFunc: isInf,
};
//# sourceMappingURL=IsInf.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isNaN": () => (/* binding */ isNaN),
/* harmony export */   "isNaNConfig": () => (/* binding */ isNaNConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const IS_NAN = `return float(isnan(x));`;
const isNaN = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: IS_NAN, dtype: 'bool' });
const isNaNConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.IsNan,
    backendName: 'webgl',
    kernelFunc: isNaN,
};
//# sourceMappingURL=IsNaN.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lrn": () => (/* binding */ lrn),
/* harmony export */   "LRNConfig": () => (/* binding */ LRNConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _lrn_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lrn_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js");
/* harmony import */ var _lrn_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lrn_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const lrn = (args) => {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_NORMALIZATION') ?
        new _lrn_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) :
        new _lrn_gpu__WEBPACK_IMPORTED_MODULE_2__.LRNProgram(x.shape, depthRadius, bias, alpha, beta);
    return backend.runWebGLProgram(program, [x], x.dtype);
};
// tslint:disable-next-line: variable-name
const LRNConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LRN,
    backendName: 'webgl',
    kernelFunc: lrn
};
//# sourceMappingURL=LRN.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lrnGrad": () => (/* binding */ lrnGrad),
/* harmony export */   "LRNGradConfig": () => (/* binding */ LRNGradConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _lrn_grad_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lrn_grad_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const lrnGrad = (args) => {
    const { inputs, backend, attrs } = args;
    const { x, y, dy } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = new _lrn_grad_gpu__WEBPACK_IMPORTED_MODULE_1__.LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);
    return backend.runWebGLProgram(program, [x, y, dy], x.dtype);
};
// tslint:disable-next-line: variable-name
const LRNGradConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LRNGrad,
    backendName: 'webgl',
    kernelFunc: lrnGrad
};
//# sourceMappingURL=LRNGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LEAKYRELU": () => (/* binding */ LEAKYRELU),
/* harmony export */   "LEAKYRELU_PACKED": () => (/* binding */ LEAKYRELU_PACKED),
/* harmony export */   "leakyRelu": () => (/* binding */ leakyRelu),
/* harmony export */   "leakyReluConfig": () => (/* binding */ leakyReluConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const LEAKYRELU = `return (a < 0.) ? b * a : a;`;
const LEAKYRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function leakyRelu(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { alpha } = attrs;
    const $alpha = backend.makeTensorInfo([], 'float32', _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.createScalarValue(alpha, 'float32'));
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?
        new _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) :
        new _binaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);
    const result = backend.runWebGLProgram(program, [x, $alpha], x.dtype);
    backend.disposeIntermediateTensorInfo($alpha);
    return result;
}
const leakyReluConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LeakyRelu,
    backendName: 'webgl',
    kernelFunc: leakyRelu
};
//# sourceMappingURL=LeakyRelu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "less": () => (/* binding */ less),
/* harmony export */   "lessConfig": () => (/* binding */ lessConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const LESS = `return float(a < b);`;
const LESS_PACKED = `
  return vec4(lessThan(a, b));
`;
const less = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({
    opSnippet: LESS,
    packedOpSnippet: LESS_PACKED,
    cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.lessImplCPU,
    dtype: 'bool'
});
const lessConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Less,
    backendName: 'webgl',
    kernelFunc: less
};
//# sourceMappingURL=Less.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LESS_EQUAL": () => (/* binding */ LESS_EQUAL),
/* harmony export */   "LESS_EQUAL_PACKED": () => (/* binding */ LESS_EQUAL_PACKED),
/* harmony export */   "lessEqual": () => (/* binding */ lessEqual),
/* harmony export */   "lessEqualConfig": () => (/* binding */ lessEqualConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const LESS_EQUAL = `return float(a <= b);`;
const LESS_EQUAL_PACKED = `
  return vec4(lessThanEqual(a, b));
`;
const lessEqual = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: LESS_EQUAL, packedOpSnippet: LESS_EQUAL_PACKED, dtype: 'bool' });
const lessEqualConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LessEqual,
    backendName: 'webgl',
    kernelFunc: lessEqual
};
//# sourceMappingURL=LessEqual.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linSpace": () => (/* binding */ linSpace),
/* harmony export */   "linSpaceConfig": () => (/* binding */ linSpaceConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function linSpace(args) {
    const { backend, attrs } = args;
    const { start, stop, num } = attrs;
    // TODO: Use CPU implementation due to the precision problem in Safari.
    const outVals = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.linSpaceImplCPU)(start, stop, num);
    return backend.makeTensorInfo([outVals.length], 'float32', outVals);
}
const linSpaceConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LinSpace,
    backendName: 'webgl',
    kernelFunc: linSpace
};
//# sourceMappingURL=LinSpace.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "logConfig": () => (/* binding */ logConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const LOG = `if (x < 0.0) return NAN;
  return log(x);`;
const LOG_PACKED = `
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`;
const log = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.logImplCPU });
const logConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Log,
    backendName: 'webgl',
    kernelFunc: log
};
//# sourceMappingURL=Log.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "log1p": () => (/* binding */ log1p),
/* harmony export */   "log1pConfig": () => (/* binding */ log1pConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const LOG1P = `return log(1.0 + x);`;
const log1p = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: LOG1P });
const log1pConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Log1p,
    backendName: 'webgl',
    kernelFunc: log1p,
};
//# sourceMappingURL=Log1p.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logicalAnd": () => (/* binding */ logicalAnd),
/* harmony export */   "logicalAndConfig": () => (/* binding */ logicalAndConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
const LOGICAL_AND_PACKED = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
const logicalAnd = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({
    opSnippet: LOGICAL_AND,
    packedOpSnippet: LOGICAL_AND_PACKED,
    dtype: 'bool'
});
const logicalAndConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LogicalAnd,
    backendName: 'webgl',
    kernelFunc: logicalAnd
};
//# sourceMappingURL=LogicalAnd.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logicalNot": () => (/* binding */ logicalNot),
/* harmony export */   "logicalNotConfig": () => (/* binding */ logicalNotConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const LOGICAL_NOT = `return float(!(x >= 1.0));`;
const logicalNot = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: LOGICAL_NOT });
const logicalNotConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LogicalNot,
    backendName: 'webgl',
    kernelFunc: logicalNot,
};
//# sourceMappingURL=LogicalNot.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logicalOr": () => (/* binding */ logicalOr),
/* harmony export */   "logicalOrConfig": () => (/* binding */ logicalOrConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
const LOGICAL_OR_PACKED = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
const logicalOr = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: 'bool' });
const logicalOrConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.LogicalOr,
    backendName: 'webgl',
    kernelFunc: logicalOr
};
//# sourceMappingURL=LogicalOr.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "maxConfig": () => (/* binding */ maxConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _Max_impl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Max_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





function max(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { reductionIndices, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
    const maxInputIsTransposed = permutedAxes != null;
    const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x]);
    let maxInput = x;
    if (maxInputIsTransposed) {
        if (shouldExecuteOnCPU) {
            const xTexData = backend.texData.get(maxInput.dataId);
            const values = xTexData.values;
            const newShape = new Array(xRank);
            for (let i = 0; i < newShape.length; i++) {
                newShape[i] = x.shape[permutedAxes[i]];
            }
            const maxInputValues = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_1__.transposeImplCPU)(values, x.shape, x.dtype, permutedAxes, newShape);
            maxInput = backend.makeTensorInfo(newShape, x.dtype);
            const maxInputData = backend.texData.get(maxInput.dataId);
            maxInputData.values = maxInputValues;
        }
        else {
            maxInput = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_2__.transposeImpl)(x, permutedAxes, backend);
        }
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, xRank);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('max', axes, xRank);
    const [maxOutShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(maxInput.shape, axes);
    let outShape = maxOutShape;
    if (keepDims) {
        // rather than reshape at the end, set the target shape here.
        outShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(maxOutShape, origAxes);
    }
    let out;
    if (shouldExecuteOnCPU) {
        const xTexData = backend.texData.get(maxInput.dataId);
        const values = xTexData.values;
        const outValues = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_1__.maxImplCPU)(values, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape), outShape, x.dtype);
        out = backend.makeTensorInfo(outShape, x.dtype);
        const outData = backend.texData.get(out.dataId);
        outData.values = outValues;
    }
    else {
        out = (0,_Max_impl__WEBPACK_IMPORTED_MODULE_3__.maxImpl)(maxInput, reduceShape, outShape, backend);
    }
    if (maxInputIsTransposed) {
        backend.disposeIntermediateTensorInfo(maxInput);
    }
    return out;
}
const maxConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Max,
    backendName: 'webgl',
    kernelFunc: max
};
//# sourceMappingURL=Max.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxPool": () => (/* binding */ maxPool),
/* harmony export */   "maxPoolConfig": () => (/* binding */ maxPoolConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _pool_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pool_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function maxPool(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, 'maxPool');
    const { filterSize, strides, pad, dimRoundingMode } = attrs;
    const dilations = 1;
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(convInfo.inShape, convInfo.outShape)) {
        return (0,_Identity__WEBPACK_IMPORTED_MODULE_2__.identity)({ inputs: { x }, backend });
    }
    const maxPoolProgram = new _pool_gpu__WEBPACK_IMPORTED_MODULE_3__.Pool2DProgram(convInfo, 'max', false);
    return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);
}
const maxPoolConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.MaxPool,
    backendName: 'webgl',
    kernelFunc: maxPool
};
//# sourceMappingURL=MaxPool.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxPool3d": () => (/* binding */ maxPool3d),
/* harmony export */   "maxPool3DConfig": () => (/* binding */ maxPool3DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _pool_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pool_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function maxPool3d(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad, dataFormat, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);
    const maxPoolProgram = new _pool_gpu__WEBPACK_IMPORTED_MODULE_1__.Pool3DProgram(convInfo, 'max', false);
    return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);
}
const maxPool3DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.MaxPool3D,
    backendName: 'webgl',
    kernelFunc: maxPool3d
};
//# sourceMappingURL=MaxPool3D.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxPool3DGrad": () => (/* binding */ maxPool3DGrad),
/* harmony export */   "maxPoolGrad3DConfig": () => (/* binding */ maxPoolGrad3DConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _max_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../max_pool_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js");
/* harmony import */ var _pool_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pool_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function maxPool3DGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input } = inputs;
    const x = input;
    const { filterSize, strides, pad, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    const maxPool3dPositionsProgram = new _pool_gpu__WEBPACK_IMPORTED_MODULE_1__.Pool3DProgram(convInfo, 'max', true /* get positions */);
    const maxPool3dPositions = backend.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);
    const maxPoolBackpropProgram = new _max_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_2__.MaxPool3DBackpropProgram(convInfo);
    const result = backend.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions], x.dtype);
    backend.disposeIntermediateTensorInfo(maxPool3dPositions);
    return result;
}
const maxPoolGrad3DConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.MaxPool3DGrad,
    backendName: 'webgl',
    kernelFunc: maxPool3DGrad
};
//# sourceMappingURL=MaxPool3DGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxPoolGrad": () => (/* binding */ maxPoolGrad),
/* harmony export */   "maxPoolGradConfig": () => (/* binding */ maxPoolGradConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _max_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../max_pool_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js");
/* harmony import */ var _pool_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pool_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function maxPoolGrad(args) {
    const { inputs, backend, attrs } = args;
    const { dy, input, output } = inputs;
    const x = input;
    (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)([input, output], 'maxPoolGrad');
    const { filterSize, strides, pad, dimRoundingMode } = attrs;
    const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad, dimRoundingMode);
    const getPositions = true;
    const maxPoolPositionsProgram = new _pool_gpu__WEBPACK_IMPORTED_MODULE_2__.Pool2DProgram(convInfo, 'max', getPositions);
    const maxPoolPositions = backend.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);
    const maxPoolBackPropProgram = new _max_pool_backprop_gpu__WEBPACK_IMPORTED_MODULE_3__.MaxPool2DBackpropProgram(convInfo);
    const result = backend.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);
    backend.disposeIntermediateTensorInfo(maxPoolPositions);
    return result;
}
const maxPoolGradConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.MaxPoolGrad,
    backendName: 'webgl',
    kernelFunc: maxPoolGrad
};
//# sourceMappingURL=MaxPoolGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxPoolWithArgmaxConfig": () => (/* binding */ maxPoolWithArgmaxConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _MaxPoolWithArgmax_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MaxPoolWithArgmax_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const maxPoolWithArgmaxConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.MaxPoolWithArgmax,
    backendName: 'webgl',
    kernelFunc: ({ inputs, attrs, backend }) => {
        const { x } = inputs;
        const { filterSize, strides, pad, includeBatchInIndex } = attrs;
        const webglBackend = backend;
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);
        const dilations = [1, 1];
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool: Either strides or dilations must be 1. ' +
            `Got strides ${strides} and dilations '${dilations}'`);
        const convInfo = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad);
        const [result, indexes] = (0,_MaxPoolWithArgmax_impl__WEBPACK_IMPORTED_MODULE_1__.maxPoolWithArgmaxImpl)(x, includeBatchInIndex, convInfo, webglBackend);
        return [result, indexes];
    }
};
//# sourceMappingURL=MaxPoolWithArgmax.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxPoolWithArgmaxImpl": () => (/* binding */ maxPoolWithArgmaxImpl)
/* harmony export */ });
/* harmony import */ var _pool_gpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pool_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

function maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, backend) {
    let program = new _pool_gpu__WEBPACK_IMPORTED_MODULE_0__.Pool2DProgram(convInfo, 'max', false);
    const poolOutput = backend.runWebGLProgram(program, [x], 'float32');
    program = new _pool_gpu__WEBPACK_IMPORTED_MODULE_0__.Pool2DProgram(convInfo, 'max', true, true, includeBatchInIndex);
    const indexOutput = backend.runWebGLProgram(program, [x], 'float32');
    return [poolOutput, indexOutput];
}
//# sourceMappingURL=MaxPoolWithArgmax_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxImpl": () => (/* binding */ maxImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/reduce */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js");
/* harmony import */ var _kernels_Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernels/Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function maxImpl(x, reduceShape, outShape, backend) {
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
    const xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = (0,_kernels_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend });
    const reduced = (0,_kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_2__.reduce)(reshapedInput, x.dtype, 'max', backend);
    const reshapedOutput = (0,_kernels_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
}
//# sourceMappingURL=Max_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maximum": () => (/* binding */ maximum),
/* harmony export */   "maximumConfig": () => (/* binding */ maximumConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





const MAXIMUM = _binaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  return max(a, b);
`;
const MAXIMUM_PACKED = `
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` +
    _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.CHECK_NAN_SNIPPET + `
  return result;
`;
const maximum = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_3__.binaryKernelFunc)({
    opSnippet: MAXIMUM,
    packedOpSnippet: MAXIMUM_PACKED,
    cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_4__.maximumImplCPU
});
const maximumConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Maximum,
    backendName: 'webgl',
    kernelFunc: maximum
};
//# sourceMappingURL=Maximum.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "meanConfig": () => (/* binding */ meanConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Mean_impl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Mean_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const meanConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Mean,
    backendName: 'webgl',
    kernelFunc: ({ inputs, attrs, backend }) => {
        const { x } = inputs;
        const { keepDims, axis } = attrs;
        const webglBackend = backend;
        const xRank = x.shape.length;
        const origAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
        let axes = origAxes;
        const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
        const meanInputIsTransposed = permutedAxes != null;
        const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);
        const intermediates = [];
        let meanInput = x;
        if (meanInputIsTransposed) {
            if (shouldExecuteOnCPU) {
                const xTexData = webglBackend.texData.get(meanInput.dataId);
                const values = xTexData.values;
                const newShape = new Array(xRank);
                for (let i = 0; i < newShape.length; i++) {
                    newShape[i] = x.shape[permutedAxes[i]];
                }
                const meanInputValues = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_1__.transposeImplCPU)(values, x.shape, x.dtype, permutedAxes, newShape);
                meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);
                const meanInputData = webglBackend.texData.get(meanInput.dataId);
                meanInputData.values = meanInputValues;
            }
            else {
                meanInput = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_2__.transposeImpl)(x, permutedAxes, webglBackend);
            }
            intermediates.push(meanInput);
            axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, xRank);
        }
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);
        const [meanOutShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(meanInput.shape, axes);
        let outShape = meanOutShape;
        if (keepDims) {
            // rather than reshape at the end, set the target shape here.
            outShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(meanOutShape, origAxes);
        }
        const out = (0,_Mean_impl__WEBPACK_IMPORTED_MODULE_3__.meanImpl)(meanInput, reduceShape, outShape, webglBackend);
        for (const i of intermediates) {
            webglBackend.disposeIntermediateTensorInfo(i);
        }
        return out;
    }
};
//# sourceMappingURL=Mean.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "meanImpl": () => (/* binding */ meanImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/reduce */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js");
/* harmony import */ var _kernels_Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernels/Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function meanImpl(x, reduceShape, outShape, backend) {
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
    const xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = (0,_kernels_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend });
    const reduced = (0,_kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_2__.reduce)(reshapedInput, 'float32', 'mean', backend);
    const reshapedOutput = (0,_kernels_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
}
//# sourceMappingURL=Mean_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "minConfig": () => (/* binding */ minConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/reduce */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function min(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, x.shape.length);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('min', axes, xRank);
    const [outShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
    const a2D = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    const reduced = (0,_kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__.reduce)(a2D, a2D.dtype, 'min', backend);
    let res;
    if (keepDims) {
        const newShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(outShape, origAxes);
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: newShape } });
    }
    else {
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
    }
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
        backend.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
}
const minConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Min,
    backendName: 'webgl',
    kernelFunc: min
};
//# sourceMappingURL=Min.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "minimum": () => (/* binding */ minimum),
/* harmony export */   "minimumConfig": () => (/* binding */ minimumConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





const MINIMUM = _binaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  return min(a, b);
`;
const MINIMUM_PACKED = `
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` +
    _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.CHECK_NAN_SNIPPET + `
  return result;
`;
const minimum = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_3__.binaryKernelFunc)({
    opSnippet: MINIMUM,
    packedOpSnippet: MINIMUM_PACKED,
    cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_4__.minimumImplCPU
});
const minimumConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Minimum,
    backendName: 'webgl',
    kernelFunc: minimum
};
//# sourceMappingURL=Minimum.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mirrorPadKernelFunc": () => (/* binding */ mirrorPadKernelFunc),
/* harmony export */   "mirrorPadConfig": () => (/* binding */ mirrorPadConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _mirror_pad_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mirror_pad_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js");
/* harmony import */ var _mirror_pad_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mirror_pad_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const mirrorPadKernelFunc = ({ inputs, backend, attrs }) => {
    const { x } = inputs;
    const { paddings, mode } = attrs;
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?
        new _mirror_pad_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.MirrorPadPackedProgram(x.shape, paddings, mode) :
        new _mirror_pad_gpu__WEBPACK_IMPORTED_MODULE_2__.MirrorPadProgram(x.shape, paddings, mode);
    const output = backend.runWebGLProgram(program, [x], x.dtype);
    return output;
};
const mirrorPadConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.MirrorPad,
    backendName: 'webgl',
    kernelFunc: mirrorPadKernelFunc,
};
//# sourceMappingURL=MirrorPad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mod": () => (/* binding */ mod),
/* harmony export */   "modConfig": () => (/* binding */ modConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`;
const MOD_PACKED = `
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  ` +
    _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  return result;
`;
const mod = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)({
    opSnippet: MOD,
    packedOpSnippet: MOD_PACKED,
});
const modConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Mod,
    backendName: 'webgl',
    kernelFunc: mod
};
//# sourceMappingURL=Mod.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multinomial": () => (/* binding */ multinomial),
/* harmony export */   "multinomialConfig": () => (/* binding */ multinomialConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _multinomial_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../multinomial_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js");
/* harmony import */ var _Softmax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Softmax */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function multinomial(args) {
    const { inputs, backend, attrs } = args;
    const { logits } = inputs;
    const { numSamples, seed, normalized } = attrs;
    const probs = normalized ?
        logits :
        (0,_Softmax__WEBPACK_IMPORTED_MODULE_1__.softmax)({ inputs: { logits }, backend, attrs: { dim: logits.shape.length - 1 } });
    const batchSize = probs.shape[0];
    const numOutcomes = probs.shape[1];
    const program = new _multinomial_gpu__WEBPACK_IMPORTED_MODULE_2__.MultinomialProgram(batchSize, numOutcomes, numSamples);
    const customSetup = program.getCustomSetupFunc(seed);
    const res = backend.runWebGLProgram(program, [probs], 'int32', customSetup);
    if (!normalized) {
        backend.disposeIntermediateTensorInfo(probs);
    }
    return res;
}
const multinomialConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Multinomial,
    backendName: 'webgl',
    kernelFunc: multinomial
};
//# sourceMappingURL=Multinomial.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "multiplyConfig": () => (/* binding */ multiplyConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_complex_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_complex_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js");
/* harmony import */ var _binaryop_gpu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../binaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _Complex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */







const MUL = 'return a * b;';
function multiply(args) {
    const { inputs, backend } = args;
    const { a, b } = inputs;
    const dtype = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.upcastType(a.dtype, b.dtype);
    if (a.dtype === 'complex64') {
        const aData = backend.texData.get(a.dataId);
        const bData = backend.texData.get(b.dataId);
        const realProgram = new _binaryop_complex_gpu__WEBPACK_IMPORTED_MODULE_1__.BinaryOpComplexProgram(_binaryop_complex_gpu__WEBPACK_IMPORTED_MODULE_1__.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);
        const imagProgram = new _binaryop_complex_gpu__WEBPACK_IMPORTED_MODULE_1__.BinaryOpComplexProgram(_binaryop_complex_gpu__WEBPACK_IMPORTED_MODULE_1__.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);
        const inputs = [
            {
                dataId: aData.complexTensorInfos.real.dataId,
                dtype: aData.complexTensorInfos.real.dtype,
                shape: a.shape
            },
            {
                dataId: aData.complexTensorInfos.imag.dataId,
                dtype: aData.complexTensorInfos.imag.dtype,
                shape: a.shape
            },
            {
                dataId: bData.complexTensorInfos.real.dataId,
                dtype: bData.complexTensorInfos.real.dtype,
                shape: b.shape
            },
            {
                dataId: bData.complexTensorInfos.imag.dataId,
                dtype: bData.complexTensorInfos.imag.dtype,
                shape: b.shape
            }
        ];
        const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');
        const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');
        const complexOutput = (0,_Complex__WEBPACK_IMPORTED_MODULE_2__.complex)({ inputs: { real: realPart, imag: imagPart }, backend });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(imagPart);
        // TODO(annxingyuan): CPU forwarding for complex inputs.
        return complexOutput;
    }
    if (backend.shouldExecuteOnCPU([a, b])) {
        const aData = backend.texData.get(a.dataId);
        const bData = backend.texData.get(b.dataId);
        const [outValues, outShape] = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_3__.multiplyImplCPU)(a.shape, b.shape, aData.values, bData.values, dtype);
        const out = backend.makeTensorInfo(outShape, dtype);
        const outData = backend.texData.get(out.dataId);
        outData.values = outValues;
        return out;
    }
    let program;
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {
        program = new _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_4__.BinaryOpPackedProgram(MUL, a.shape, b.shape);
    }
    else {
        program = new _binaryop_gpu__WEBPACK_IMPORTED_MODULE_5__.BinaryOpProgram(MUL, a.shape, b.shape);
    }
    return backend.runWebGLProgram(program, [a, b], dtype);
}
const multiplyConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Multiply,
    backendName: 'webgl',
    kernelFunc: multiply
};
//# sourceMappingURL=Multiply.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "neg": () => (/* binding */ neg),
/* harmony export */   "negConfig": () => (/* binding */ negConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/* harmony import */ var _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../unaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




const NEG = `return -x;`;
// This doesn't use unaryKernelFunc because negImplCPU is not of type
// SimpleUnaryKernelImplCPU.
function neg(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    if (backend.shouldExecuteOnCPU([x])) {
        const xData = backend.texData.get(x.dataId);
        const [outValues, newShape] = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.negImplCPU)(xData.values, x.shape, x.dtype);
        return backend.makeTensorInfo(newShape, x.dtype, outValues);
    }
    let program;
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {
        program = new _unaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.UnaryOpPackedProgram(x.shape, NEG);
    }
    else {
        program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_3__.UnaryOpProgram(x.shape, NEG);
    }
    return backend.runWebGLProgram(program, [x], x.dtype);
}
const negConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Neg,
    backendName: 'webgl',
    kernelFunc: neg
};
//# sourceMappingURL=Neg.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nonMaxSuppressionV3": () => (/* binding */ nonMaxSuppressionV3),
/* harmony export */   "nonMaxSuppressionV3Config": () => (/* binding */ nonMaxSuppressionV3Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

const nonMaxSuppressionV3Impl = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.kernel_impls.nonMaxSuppressionV3Impl;
function nonMaxSuppressionV3(args) {
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +
        'Call tf.nonMaxSuppressionAsync() instead');
    const { inputs, backend, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    return backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices));
}
const nonMaxSuppressionV3Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.NonMaxSuppressionV3,
    backendName: 'webgl',
    kernelFunc: nonMaxSuppressionV3
};
//# sourceMappingURL=NonMaxSuppressionV3.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nonMaxSuppressionV4": () => (/* binding */ nonMaxSuppressionV4),
/* harmony export */   "nonMaxSuppressionV4Config": () => (/* binding */ nonMaxSuppressionV4Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

const nonMaxSuppressionV4Impl = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.kernel_impls.nonMaxSuppressionV4Impl;
function nonMaxSuppressionV4(args) {
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +
        'Call tf.nonMaxSuppressionAsync() instead');
    const { inputs, backend, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    return [
        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),
        backend.makeTensorInfo([], 'int32', new Int32Array([validOutputs]))
    ];
}
const nonMaxSuppressionV4Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.NonMaxSuppressionV4,
    backendName: 'webgl',
    kernelFunc: nonMaxSuppressionV4
};
//# sourceMappingURL=NonMaxSuppressionV4.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nonMaxSuppressionV5": () => (/* binding */ nonMaxSuppressionV5),
/* harmony export */   "nonMaxSuppressionV5Config": () => (/* binding */ nonMaxSuppressionV5Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

const nonMaxSuppressionV5Impl = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.kernel_impls.nonMaxSuppressionV5Impl;
function nonMaxSuppressionV5(args) {
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +
        'Call tf.nonMaxSuppressionAsync() instead');
    const { inputs, backend, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const maxOutputSizeVal = maxOutputSize;
    const iouThresholdVal = iouThreshold;
    const scoreThresholdVal = scoreThreshold;
    const softNmsSigmaVal = softNmsSigma;
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
    return [
        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),
        backend.makeTensorInfo([selectedScores.length], 'float32', new Float32Array(selectedScores))
    ];
}
const nonMaxSuppressionV5Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.NonMaxSuppressionV5,
    backendName: 'webgl',
    kernelFunc: nonMaxSuppressionV5
};
//# sourceMappingURL=NonMaxSuppressionV5.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "notEqual": () => (/* binding */ notEqual),
/* harmony export */   "notEqualConfig": () => (/* binding */ notEqualConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const NOT_EQUAL = `return float(a != b);`;
const notEqual = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: NOT_EQUAL, dtype: 'bool' });
const notEqualConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.NotEqual,
    backendName: 'webgl',
    kernelFunc: notEqual,
};
//# sourceMappingURL=NotEqual.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "oneHot": () => (/* binding */ oneHot),
/* harmony export */   "oneHotConfig": () => (/* binding */ oneHotConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _onehot_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../onehot_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const oneHot = (args) => {
    const { inputs, backend, attrs } = args;
    const { indices } = inputs;
    const { depth, onValue, offValue } = attrs;
    const indicesSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(indices.shape);
    const program = new _onehot_gpu__WEBPACK_IMPORTED_MODULE_1__.OneHotProgram(indicesSize, depth, onValue, offValue);
    const reshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: indices }, backend, attrs: { shape: [indicesSize] } });
    const result = backend.runWebGLProgram(program, [reshaped], indices.dtype);
    backend.disposeIntermediateTensorInfo(reshaped);
    const outShape = [...indices.shape, depth];
    const out = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: result }, backend, attrs: { shape: outShape } });
    backend.disposeIntermediateTensorInfo(result);
    return out;
};
const oneHotConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.OneHot,
    backendName: 'webgl',
    kernelFunc: oneHot
};
//# sourceMappingURL=OneHot.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onesLike": () => (/* binding */ onesLike),
/* harmony export */   "onesLikeConfig": () => (/* binding */ onesLikeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Complex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/* harmony import */ var _Fill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Fill */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js");
/* harmony import */ var _Imag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Imag */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js");
/* harmony import */ var _Real__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Real */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js");
/* harmony import */ var _ZerosLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ZerosLike */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */






function onesLike(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    if (x.dtype === 'string') {
        throw new Error('onesLike is not supported under string dtype');
    }
    else if (x.dtype === 'complex64') {
        const realPart = (0,_Real__WEBPACK_IMPORTED_MODULE_1__.real)({ inputs: { input: x }, backend });
        const r = onesLike({ inputs: { x: realPart }, backend });
        const imagPart = (0,_Imag__WEBPACK_IMPORTED_MODULE_2__.imag)({ inputs: { input: x }, backend });
        const i = (0,_ZerosLike__WEBPACK_IMPORTED_MODULE_3__.zerosLike)({ inputs: { x: imagPart }, backend });
        const result = (0,_Complex__WEBPACK_IMPORTED_MODULE_4__.complex)({ inputs: { real: r, imag: i }, backend });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result;
    }
    else {
        // TODO(cais, smilkov): Add WebGL shader for onesLike:
        //   https://github.com/tensorflow/tfjs/issues/1293
        return (0,_Fill__WEBPACK_IMPORTED_MODULE_5__.fill)({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend });
    }
}
const onesLikeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.OnesLike,
    backendName: 'webgl',
    kernelFunc: onesLike
};
//# sourceMappingURL=OnesLike.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pack": () => (/* binding */ pack),
/* harmony export */   "packConfig": () => (/* binding */ packConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Concat */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js");
/* harmony import */ var _ExpandDims__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExpandDims */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function pack(args) {
    const { inputs, backend, attrs } = args;
    const { axis } = attrs;
    if (inputs.length === 1) {
        return (0,_ExpandDims__WEBPACK_IMPORTED_MODULE_1__.expandDims)({ inputs: { input: inputs[0] }, backend, attrs: { dim: axis } });
    }
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach(t => {
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(dtype === t.dtype, () => 'All tensors passed to stack must have matching dtypes');
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map(t => {
        const expandedT = (0,_ExpandDims__WEBPACK_IMPORTED_MODULE_1__.expandDims)({ inputs: { input: t }, backend, attrs: { dim: axis } });
        intermediateTensorInfos.push(expandedT);
        return expandedT;
    });
    const result = (0,_Concat__WEBPACK_IMPORTED_MODULE_2__.concat)({ inputs: expandedTensors, backend, attrs: { axis } });
    intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return result;
}
const packConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Pack,
    backendName: 'webgl',
    kernelFunc: pack
};
//# sourceMappingURL=Pack.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "padV2": () => (/* binding */ padV2),
/* harmony export */   "padV2Config": () => (/* binding */ padV2Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _pad_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pad_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js");
/* harmony import */ var _pad_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pad_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const padV2 = (args) => {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { paddings, constantValue } = attrs;
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?
        new _pad_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.PadPackedProgram(x.shape, paddings, constantValue) :
        new _pad_gpu__WEBPACK_IMPORTED_MODULE_2__.PadProgram(x.shape, paddings, constantValue);
    return backend.runWebGLProgram(program, [x], x.dtype);
};
const padV2Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.PadV2,
    backendName: 'webgl',
    kernelFunc: padV2
};
//# sourceMappingURL=PadV2.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "powConfig": () => (/* binding */ powConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const POW = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
const POW_PACKED = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  ` +
    _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  return result;
`;
const pow = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.binaryKernelFunc)({ opSnippet: POW, packedOpSnippet: POW_PACKED });
const powConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Pow,
    backendName: 'webgl',
    kernelFunc: pow
};
//# sourceMappingURL=Pow.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PRELU": () => (/* binding */ PRELU),
/* harmony export */   "PRELU_PACKED": () => (/* binding */ PRELU_PACKED),
/* harmony export */   "prelu": () => (/* binding */ prelu),
/* harmony export */   "preluConfig": () => (/* binding */ preluConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _binaryop_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js");
/* harmony import */ var _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binaryop_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const PRELU = `return (a < 0.) ? b * a : a;`;
const PRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function prelu(args) {
    const { inputs, backend } = args;
    const { x, alpha } = inputs;
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?
        new _binaryop_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) :
        new _binaryop_gpu__WEBPACK_IMPORTED_MODULE_2__.BinaryOpProgram(PRELU, x.shape, alpha.shape);
    return backend.runWebGLProgram(program, [x, alpha], x.dtype);
}
const preluConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Prelu,
    backendName: 'webgl',
    kernelFunc: prelu
};
//# sourceMappingURL=Prelu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prod": () => (/* binding */ prod),
/* harmony export */   "prodConfig": () => (/* binding */ prodConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../kernel_utils/reduce */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





function prod(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const toDispose = [];
    const origAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutedAxes } });
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, xRank);
        toDispose.push(permutedX);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('prod', axes, xRank);
    let res;
    if (backend.shouldExecuteOnCPU([permutedX])) {
        const xVals = backend.texData.get(permutedX.dataId).values;
        const { outVals, outShape, outDtype } = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.prodImplCPU)(permutedX.shape, permutedX.dtype, xVals, axes);
        res = backend.makeTensorInfo(outShape, outDtype, outVals);
    }
    else {
        const [outShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
        const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
        const a2D = (0,_Reshape__WEBPACK_IMPORTED_MODULE_3__.reshape)({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
        const outputDType = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sumOutType)(x.dtype);
        const reduced = (0,_kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_4__.reduce)(a2D, outputDType, 'prod', backend);
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_3__.reshape)({ inputs: { x: reduced }, backend, attrs: { shape: outShape } });
        toDispose.push(a2D);
        toDispose.push(reduced);
    }
    if (keepDims) {
        toDispose.push(res);
        const newShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(res.shape, origAxes);
        res = (0,_Reshape__WEBPACK_IMPORTED_MODULE_3__.reshape)({ inputs: { x: res }, backend, attrs: { shape: newShape } });
    }
    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return res;
}
const prodConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Prod,
    backendName: 'webgl',
    kernelFunc: prod
};
//# sourceMappingURL=Prod.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "rangeConfig": () => (/* binding */ rangeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const range = (args) => {
    const { backend, attrs } = args;
    const { start, stop, step, dtype } = attrs;
    const values = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.rangeImplCPU)(start, stop, step, dtype);
    return backend.makeTensorInfo([values.length], dtype, values);
};
const rangeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Range,
    backendName: 'webgl',
    kernelFunc: range
};
//# sourceMappingURL=Range.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "real": () => (/* binding */ real),
/* harmony export */   "realConfig": () => (/* binding */ realConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function real(args) {
    const { inputs, backend } = args;
    const { input } = inputs;
    const inputData = backend.texData.get(input.dataId);
    return (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x: inputData.complexTensorInfos.real }, backend });
}
const realConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Real,
    backendName: 'webgl',
    kernelFunc: real
};
//# sourceMappingURL=Real.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "realDiv": () => (/* binding */ realDiv),
/* harmony export */   "realDivConfig": () => (/* binding */ realDivConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


// Without the equality check div produces 0.9999 for a = b, which when
// floored can cause errors.
const DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`;
// We do the same as in ./binaryop_gpu, with vec4 and ivec4.
// On Linux, the vectorized implementation produces NaNs when a and b are 0.
const DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
const realDiv = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });
const realDivConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.RealDiv,
    backendName: 'webgl',
    kernelFunc: realDiv,
};
//# sourceMappingURL=RealDiv.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reciprocal": () => (/* binding */ reciprocal),
/* harmony export */   "reciprocalConfig": () => (/* binding */ reciprocalConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const RECIPROCAL = `return 1.0 / x;`;
const reciprocal = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: RECIPROCAL });
const reciprocalConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Reciprocal,
    backendName: 'webgl',
    kernelFunc: reciprocal,
};
//# sourceMappingURL=Reciprocal.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "relu": () => (/* binding */ relu),
/* harmony export */   "reluConfig": () => (/* binding */ reluConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const RELU = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
const RELU_PACKED = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const relu = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: RELU, packedOpSnippet: RELU_PACKED });
const reluConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Relu,
    backendName: 'webgl',
    kernelFunc: relu
};
//# sourceMappingURL=Relu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "relu6": () => (/* binding */ relu6),
/* harmony export */   "relu6Config": () => (/* binding */ relu6Config)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const RELU6 = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
const RELU6_PACKED = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const relu6 = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_2__.unaryKernelFunc)({ opSnippet: RELU6, packedOpSnippet: RELU6_PACKED });
const relu6Config = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Relu6,
    backendName: 'webgl',
    kernelFunc: relu6
};
//# sourceMappingURL=Relu6.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reshape": () => (/* binding */ reshape),
/* harmony export */   "reshapeConfig": () => (/* binding */ reshapeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function reshape(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { shape } = attrs;
    const webglBackend = backend;
    const xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape);
    const $shape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.inferFromImplicitShape(shape, xSize);
    const $xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape($shape);
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old ` +
        `shape (${x.shape}) has ${xSize} elements. The new shape and old ` +
        `shape must have the same number of elements.`);
    const xTexData = webglBackend.texData.get(x.dataId);
    if (xTexData.isPacked && !(0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isReshapeFree)(x.shape, $shape) &&
        !(xTexData.texture !== null && (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.isReshapeFree)(xTexData.shape, $shape))) {
        return (0,_kernel_utils_reshape__WEBPACK_IMPORTED_MODULE_2__.packedReshape)(x, $shape, webglBackend);
    }
    webglBackend.incRef(x.dataId);
    return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
}
const reshapeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Reshape,
    backendName: 'webgl',
    kernelFunc: reshape
};
//# sourceMappingURL=Reshape.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resizeBilinear": () => (/* binding */ resizeBilinear),
/* harmony export */   "resizeBilinearConfig": () => (/* binding */ resizeBilinearConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _resize_bilinear_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resize_bilinear_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js");
/* harmony import */ var _resize_bilinear_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resize_bilinear_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function resizeBilinear(args) {
    const { inputs, backend, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size } = attrs;
    const [newHeight, newWidth] = size;
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?
        new _resize_bilinear_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) :
        new _resize_bilinear_gpu__WEBPACK_IMPORTED_MODULE_2__.ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend.runWebGLProgram(program, [images], 'float32');
}
const resizeBilinearConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ResizeBilinear,
    backendName: 'webgl',
    kernelFunc: resizeBilinear
};
//# sourceMappingURL=ResizeBilinear.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resizeBilinearGrad": () => (/* binding */ resizeBilinearGrad),
/* harmony export */   "resizeBilinearGradConfig": () => (/* binding */ resizeBilinearGradConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _resize_bilinear_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resize_bilinear_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function resizeBilinearGrad(args) {
    const { inputs, backend, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new _resize_bilinear_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__.ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend.runWebGLProgram(program, [dy], dy.dtype);
}
const resizeBilinearGradConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ResizeBilinearGrad,
    backendName: 'webgl',
    kernelFunc: resizeBilinearGrad
};
//# sourceMappingURL=ResizeBilinearGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resizeNearestNeighbor": () => (/* binding */ resizeNearestNeighbor),
/* harmony export */   "resizeNearestNeighborConfig": () => (/* binding */ resizeNearestNeighborConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _resize_nearest_neighbor_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resize_nearest_neighbor_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function resizeNearestNeighbor(args) {
    const { inputs, backend, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size } = attrs;
    const [newHeight, newWidth] = size;
    const program = new _resize_nearest_neighbor_gpu__WEBPACK_IMPORTED_MODULE_1__.ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend.runWebGLProgram(program, [images], images.dtype);
}
const resizeNearestNeighborConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ResizeNearestNeighbor,
    backendName: 'webgl',
    kernelFunc: resizeNearestNeighbor
};
//# sourceMappingURL=ResizeNearestNeighbor.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resizeNearestNeighborGrad": () => (/* binding */ resizeNearestNeighborGrad),
/* harmony export */   "resizeNearestNeighborGradConfig": () => (/* binding */ resizeNearestNeighborGradConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _resize_nearest_neighbor_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resize_nearest_neighbor_backprop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function resizeNearestNeighborGrad(args) {
    const { inputs, backend, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new _resize_nearest_neighbor_backprop_gpu__WEBPACK_IMPORTED_MODULE_1__.ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend.runWebGLProgram(program, [dy], dy.dtype);
}
const resizeNearestNeighborGradConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ResizeNearestNeighborGrad,
    backendName: 'webgl',
    kernelFunc: resizeNearestNeighborGrad
};
//# sourceMappingURL=ResizeNearestNeighborGrad.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reverse": () => (/* binding */ reverse),
/* harmony export */   "reverseConfig": () => (/* binding */ reverseConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _reverse_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reverse_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js");
/* harmony import */ var _reverse_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../reverse_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js");
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function reverse(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { dims } = attrs;
    const xRank = x.shape.length;
    const $dims = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(dims, x.shape);
    if (xRank === 0) {
        return (0,_Identity__WEBPACK_IMPORTED_MODULE_1__.identity)({ inputs: { x }, backend });
    }
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?
        new _reverse_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.ReversePackedProgram(x.shape, $dims) :
        new _reverse_gpu__WEBPACK_IMPORTED_MODULE_3__.ReverseProgram(x.shape, $dims);
    return backend.runWebGLProgram(program, [x], x.dtype);
}
const reverseConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Reverse,
    backendName: 'webgl',
    kernelFunc: reverse
};
//# sourceMappingURL=Reverse.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rotateWithOffsetConfig": () => (/* binding */ rotateWithOffsetConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _rotate_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotate_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const rotateWithOffsetConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.RotateWithOffset,
    backendName: 'webgl',
    kernelFunc: ({ inputs, attrs, backend }) => {
        const { image } = inputs;
        const { radians, fillValue, center } = attrs;
        const webglBackend = backend;
        const program = new _rotate_gpu__WEBPACK_IMPORTED_MODULE_1__.RotateProgram(image.shape, radians, fillValue, center);
        const output = webglBackend.runWebGLProgram(program, [image], image.dtype);
        return output;
    }
};
//# sourceMappingURL=RotateWithOffset.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "roundConfig": () => (/* binding */ roundConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
const round = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: ROUND });
const roundConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Round,
    backendName: 'webgl',
    kernelFunc: round,
};
//# sourceMappingURL=Round.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rsqrt": () => (/* binding */ rsqrt),
/* harmony export */   "rsqrtConfig": () => (/* binding */ rsqrtConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const RSQRT = `return inversesqrt(x);`;
const rsqrt = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: RSQRT, cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.rsqrtImplCPU });
const rsqrtConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Rsqrt,
    backendName: 'webgl',
    kernelFunc: rsqrt
};
//# sourceMappingURL=Rsqrt.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scatterNd": () => (/* binding */ scatterNd),
/* harmony export */   "scatterNdConfig": () => (/* binding */ scatterNdConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _scatter_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scatter_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function scatterNd(args) {
    const { inputs, backend, attrs } = args;
    const { indices, updates } = inputs;
    const { shape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.calculateShapes(updates, indices, shape);
    const flattenShape = [outputSize / sliceSize, sliceSize];
    if (outputSize === 0) {
        return backend.makeTensorInfo(shape, indices.dtype);
    }
    const flattenIndices = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: indices }, backend, attrs: { shape: [numUpdates, sliceRank] } });
    const flattenX = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: updates }, backend, attrs: { shape: [numUpdates, sliceSize] } });
    const defaultValue = backend.makeTensorInfo([], 'float32', new Float32Array([0])); // scalar(0)
    const program = new _scatter_gpu__WEBPACK_IMPORTED_MODULE_2__.ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
    const res = backend.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);
    const reshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: res }, backend, attrs: { shape } });
    backend.disposeIntermediateTensorInfo(flattenIndices);
    backend.disposeIntermediateTensorInfo(flattenX);
    backend.disposeIntermediateTensorInfo(res);
    backend.disposeIntermediateTensorInfo(defaultValue);
    return reshaped;
}
const scatterNdConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ScatterNd,
    backendName: 'webgl',
    kernelFunc: scatterNd
};
//# sourceMappingURL=ScatterNd.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "select": () => (/* binding */ select),
/* harmony export */   "selectConfig": () => (/* binding */ selectConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _select_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../select_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function select(args) {
    const { inputs, backend } = args;
    const { condition, t, e } = inputs;
    const program = new _select_gpu__WEBPACK_IMPORTED_MODULE_1__.SelectProgram(condition.shape.length, t.shape, t.shape.length);
    return backend.runWebGLProgram(program, [condition, t, e], (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.upcastType)(t.dtype, e.dtype));
}
const selectConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Select,
    backendName: 'webgl',
    kernelFunc: select
};
//# sourceMappingURL=Select.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selu": () => (/* binding */ selu),
/* harmony export */   "seluConfig": () => (/* binding */ seluConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.SELU_SCALEALPHA};
  float scale = ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
const selu = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SELU });
const seluConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Selu,
    backendName: 'webgl',
    kernelFunc: selu,
};
//# sourceMappingURL=Selu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sigmoid": () => (/* binding */ sigmoid),
/* harmony export */   "sigmoidConfig": () => (/* binding */ sigmoidConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;
const sigmoid = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SIGMOID });
const sigmoidConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sigmoid,
    backendName: 'webgl',
    kernelFunc: sigmoid,
};
//# sourceMappingURL=Sigmoid.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "signConfig": () => (/* binding */ signConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


// Sign does not propagate NANs.
const SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
const sign = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SIGN });
const signConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sign,
    backendName: 'webgl',
    kernelFunc: sign,
};
//# sourceMappingURL=Sign.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "sinConfig": () => (/* binding */ sinConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SIN = _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET_UNARY + `
  return sin(x);
`;
const sin = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SIN });
const sinConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sin,
    backendName: 'webgl',
    kernelFunc: sin,
};
//# sourceMappingURL=Sin.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sinh": () => (/* binding */ sinh),
/* harmony export */   "sinhConfig": () => (/* binding */ sinhConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
const sinh = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SINH });
const sinhConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sinh,
    backendName: 'webgl',
    kernelFunc: sinh,
};
//# sourceMappingURL=Sinh.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "sliceConfig": () => (/* binding */ sliceConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _slice_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../slice_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js");
/* harmony import */ var _slice_packed_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../slice_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function shallowSlice(x, begin, size, backend) {
    const xTexData = backend.texData.get(x.dataId);
    const t = backend.makeTensorInfo(size, x.dtype);
    const newTexData = backend.texData.get(t.dataId);
    // Copy texture data from the original tensor.
    Object.assign(newTexData, xTexData);
    newTexData.complexParentRefCount = 0;
    newTexData.refCount = 1;
    newTexData.shape = size;
    newTexData.dtype = x.dtype;
    let flatOffset = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.computeFlatOffset(begin, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(x.shape));
    if (xTexData.slice) {
        // We are slicing an already sliced tensor, so we have to accumulate
        // the offset.
        flatOffset += xTexData.slice.flatOffset;
    }
    newTexData.slice = {
        flatOffset,
        // Point to the original dataId, which is used to do ref counting.
        origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId
    };
    // Increase the ref count for that data bucket.
    const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;
    backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
    return t;
}
function slice(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { begin, size } = attrs;
    const [$begin, $size] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.parseSliceParams(x, begin, size);
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.assertParamsValid(x, $begin, $size);
    if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape($size) === 0) {
        return backend.makeTensorInfo($size, x.dtype, []);
    }
    // Run on cpu if dtype is string. For string, the backend represents it
    // as Uint8Array[], where each Uint8Array is a character. Given that the
    // computation is only on the outer array, uploading the whole data onto
    // gpu is wasteful. Also, currently webgl doesn't have a design to
    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we
    // just run the kernel on cpu if dtype is string.
    if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {
        const xTexData = backend.texData.get(x.dataId);
        const outValues = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.sliceImplCPU)(xTexData.values, $begin, $size, x.shape, x.dtype);
        return backend.makeTensorInfo($size, x.dtype, outValues);
    }
    const { isPacked } = backend.texData.get(x.dataId);
    const isContinous = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.isSliceContinous(x.shape, $begin, $size);
    if (isPacked || !isContinous) {
        const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?
            new _slice_packed_gpu__WEBPACK_IMPORTED_MODULE_2__.SlicePackedProgram($size) :
            new _slice_gpu__WEBPACK_IMPORTED_MODULE_3__.SliceProgram($size);
        const customSetup = program.getCustomSetupFunc($begin);
        return backend.runWebGLProgram(program, [x], x.dtype, customSetup);
    }
    backend.uploadToGPU(x.dataId);
    return shallowSlice(x, $begin, $size, backend);
}
const sliceConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Slice,
    backendName: 'webgl',
    kernelFunc: slice
};
//# sourceMappingURL=Slice.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "softmax": () => (/* binding */ softmax),
/* harmony export */   "softmaxConfig": () => (/* binding */ softmaxConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Exp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Exp */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js");
/* harmony import */ var _Max__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Max */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js");
/* harmony import */ var _RealDiv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RealDiv */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Sub__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Sub */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js");
/* harmony import */ var _Sum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Sum */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */







function softmax(args) {
    const { inputs, backend, attrs } = args;
    const { logits } = inputs;
    const { dim } = attrs;
    const axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam([dim], logits.shape);
    const maxLogit = (0,_Max__WEBPACK_IMPORTED_MODULE_1__.max)({
        inputs: { x: logits },
        backend,
        attrs: { reductionIndices: axes, keepDims: false }
    });
    const expandedShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(maxLogit.shape, axes);
    const maxLogitsReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: maxLogit }, backend, attrs: { shape: expandedShape } });
    const a = (0,_Sub__WEBPACK_IMPORTED_MODULE_3__.sub)({ inputs: { a: logits, b: maxLogitsReshaped }, backend });
    const b = (0,_Exp__WEBPACK_IMPORTED_MODULE_4__.exp)({ inputs: { x: a }, backend });
    const sumExp = (0,_Sum__WEBPACK_IMPORTED_MODULE_5__.sum)({ inputs: { x: b }, backend, attrs: { axis: axes, keepDims: false } });
    const sumExpReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: sumExp }, backend, attrs: { shape: expandedShape } });
    const res = (0,_RealDiv__WEBPACK_IMPORTED_MODULE_6__.realDiv)({ inputs: { a: b, b: sumExpReshaped }, backend });
    backend.disposeIntermediateTensorInfo(maxLogit);
    backend.disposeIntermediateTensorInfo(maxLogitsReshaped);
    backend.disposeIntermediateTensorInfo(a);
    backend.disposeIntermediateTensorInfo(b);
    backend.disposeIntermediateTensorInfo(sumExp);
    backend.disposeIntermediateTensorInfo(sumExpReshaped);
    return res;
}
const softmaxConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Softmax,
    backendName: 'webgl',
    kernelFunc: softmax
};
//# sourceMappingURL=Softmax.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "softplus": () => (/* binding */ softplus),
/* harmony export */   "softplusConfig": () => (/* binding */ softplusConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
const softplus = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SOFTPLUS });
const softplusConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Softplus,
    backendName: 'webgl',
    kernelFunc: softplus,
};
//# sourceMappingURL=Softplus.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spaceToBatchND": () => (/* binding */ spaceToBatchND),
/* harmony export */   "spaceToBatchNDConfig": () => (/* binding */ spaceToBatchNDConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _PadV2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PadV2 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




const spaceToBatchND = (args) => {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { blockShape, paddings } = attrs;
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(x.shape.length <= 4, () => 'spaceToBatchND for rank > 4 with a WebGL backend not ' +
        'implemented yet');
    const prod = blockShape.reduce((a, b) => a * b);
    const completePaddings = [[0, 0]];
    completePaddings.push(...paddings);
    for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {
        completePaddings.push([0, 0]);
    }
    const toDispose = [];
    const paddedX = (0,_PadV2__WEBPACK_IMPORTED_MODULE_1__.padV2)({
        inputs: { x },
        backend,
        attrs: { paddings: completePaddings, constantValue: 0 }
    });
    const reshapedPaddedShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getReshaped(paddedX.shape, blockShape, prod, false);
    const permutedReshapedPaddedPermutation = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);
    const reshapedPaddedX = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: paddedX }, backend, attrs: { shape: reshapedPaddedShape } });
    const paddedXT = (0,_Transpose__WEBPACK_IMPORTED_MODULE_3__.transpose)({
        inputs: { x: reshapedPaddedX },
        backend,
        attrs: { perm: permutedReshapedPaddedPermutation }
    });
    const result = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: paddedXT }, backend, attrs: { shape: flattenShape } });
    toDispose.push(paddedX);
    toDispose.push(reshapedPaddedX);
    toDispose.push(paddedXT);
    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return result;
};
const spaceToBatchNDConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.SpaceToBatchND,
    backendName: 'webgl',
    kernelFunc: spaceToBatchND
};
//# sourceMappingURL=SpaceToBatchND.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sparseToDense": () => (/* binding */ sparseToDense),
/* harmony export */   "sparseToDenseConfig": () => (/* binding */ sparseToDenseConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _scatter_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scatter_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function sparseToDense(args) {
    const { inputs, backend, attrs } = args;
    const { sparseIndices, sparseValues, defaultValue } = inputs;
    const { outputShape } = attrs;
    const { sliceRank, numUpdates, strides, outputSize } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);
    const sumDupeIndices = false;
    const program = new _scatter_gpu__WEBPACK_IMPORTED_MODULE_1__.ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);
    const res = backend.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);
    const reshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: res }, backend, attrs: { shape: outputShape } });
    backend.disposeIntermediateTensorInfo(res);
    return reshaped;
}
const sparseToDenseConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.SparseToDense,
    backendName: 'webgl',
    kernelFunc: sparseToDense
};
//# sourceMappingURL=SparseToDense.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitV": () => (/* binding */ splitV),
/* harmony export */   "splitVConfig": () => (/* binding */ splitVConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Slice */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function splitV(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { numOrSizeSplits, axis } = attrs;
    const $axis = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(axis, x.shape)[0];
    const splitSizes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);
    const xRank = x.shape.length;
    const begin = new Array(xRank).fill(0);
    const size = x.shape.slice();
    return splitSizes.map(s => {
        const sliceSize = [...size];
        sliceSize[$axis] = s;
        const sliceT = (0,_Slice__WEBPACK_IMPORTED_MODULE_1__.slice)({ inputs: { x }, backend, attrs: { begin, size: sliceSize } });
        begin[$axis] += s;
        return sliceT;
    });
}
const splitVConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.SplitV,
    backendName: 'webgl',
    kernelFunc: splitV
};
//# sourceMappingURL=SplitV.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "sqrtConfig": () => (/* binding */ sqrtConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SQRT = `return sqrt(x);`;
const sqrt = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SQRT });
const sqrtConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sqrt,
    backendName: 'webgl',
    kernelFunc: sqrt
};
//# sourceMappingURL=Sqrt.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "square": () => (/* binding */ square),
/* harmony export */   "squareConfig": () => (/* binding */ squareConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SQUARE = `return x * x;`;
const square = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: SQUARE });
const squareConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Square,
    backendName: 'webgl',
    kernelFunc: square,
};
//# sourceMappingURL=Square.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "squaredDifference": () => (/* binding */ squaredDifference),
/* harmony export */   "squaredDifferenceConfig": () => (/* binding */ squaredDifferenceConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';
const squaredDifference = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });
const squaredDifferenceConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.SquaredDifference,
    backendName: 'webgl',
    kernelFunc: squaredDifference,
};
//# sourceMappingURL=SquaredDifference.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "step": () => (/* binding */ step),
/* harmony export */   "stepConfig": () => (/* binding */ stepConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unaryop_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function step({ inputs, attrs, backend }) {
    const { x } = inputs;
    const opSnippet = _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.CHECK_NAN_SNIPPET + `
    return x > 0.0 ? 1.0 : float(${attrs.alpha});
  `;
    const program = new _unaryop_gpu__WEBPACK_IMPORTED_MODULE_1__.UnaryOpProgram(x.shape, opSnippet);
    return backend.runWebGLProgram(program, [x], x.dtype);
}
const stepConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Step,
    backendName: 'webgl',
    kernelFunc: step,
};
//# sourceMappingURL=Step.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stridedSlice": () => (/* binding */ stridedSlice),
/* harmony export */   "stridedSliceConfig": () => (/* binding */ stridedSliceConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _strided_slice_gpu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../strided_slice_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Slice */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





function stridedSlice(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
    const { nonStrided, $begin, $strides, size, newShape, outShape } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    const $x = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x }, backend, attrs: { shape: newShape } });
    let result;
    if (nonStrided) {
        const sliced = (0,_Slice__WEBPACK_IMPORTED_MODULE_2__.slice)({ inputs: { x: $x }, backend, attrs: { begin: $begin, size } });
        result = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: sliced }, backend, attrs: { shape: outShape } });
        backend.disposeIntermediateTensorInfo(sliced);
    }
    else if (outShape.some(axis => axis === 0)) {
        result = backend.makeTensorInfo(outShape, x.dtype, []);
    }
    else {
        const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([$x]);
        if (shouldExecuteOnCPU) {
            const xTexData = backend.texData.get($x.dataId);
            const values = xTexData.values;
            const xBuf = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)($x.shape, $x.dtype, values);
            const resultValues = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_3__.stridedSliceImplCPU)(outShape, xBuf, $strides, $begin);
            result = backend.makeTensorInfo(outShape, $x.dtype, resultValues.values);
        }
        else {
            const program = new _strided_slice_gpu__WEBPACK_IMPORTED_MODULE_4__.StridedSliceProgram($begin, $strides, outShape);
            result = backend.runWebGLProgram(program, [$x], $x.dtype);
        }
    }
    const resultReshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_1__.reshape)({ inputs: { x: result }, backend, attrs: { shape: outShape } });
    backend.disposeIntermediateTensorInfo($x);
    backend.disposeIntermediateTensorInfo(result);
    return resultReshaped;
}
const stridedSliceConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.StridedSlice,
    backendName: 'webgl',
    kernelFunc: stridedSlice
};
//# sourceMappingURL=StridedSlice.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "subConfig": () => (/* binding */ subConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



const SUB = 'return a - b;';
const sub = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.binaryKernelFunc)({
    opSnippet: SUB,
    packedOpSnippet: SUB,
    supportsComplex: true,
    cpuKernelImpl: _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.subImplCPU
});
const subConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sub,
    backendName: 'webgl',
    kernelFunc: sub
};
//# sourceMappingURL=Sub.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sum": () => (/* binding */ sum),
/* harmony export */   "sumConfig": () => (/* binding */ sumConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Sum_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sum_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function sum(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    return (0,_Sum_impl__WEBPACK_IMPORTED_MODULE_1__.sumImpl)(x, axis, keepDims, backend);
}
const sumConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Sum,
    backendName: 'webgl',
    kernelFunc: sum
};
//# sourceMappingURL=Sum.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sumImpl": () => (/* binding */ sumImpl)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/reduce */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function sumImpl(x, axis, keepDims, backend) {
    const reductionIndices = axis;
    const xRank = x.shape.length;
    const origAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation(axes, xRank);
    const sumInputIsTransposed = permutedAxes != null;
    let sumInput = x;
    if (sumInputIsTransposed) {
        sumInput = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_1__.transposeImpl)(x, permutedAxes, backend);
        axes = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(axes.length, xRank);
    }
    _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);
    const [sumOutShape, reduceShape] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.computeOutAndReduceShapes(sumInput.shape, axes);
    let outShape = sumOutShape;
    if (keepDims) {
        // rather than reshape at the end, set the target shape here.
        outShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.expandShapeToKeepDim(sumOutShape, origAxes);
    }
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(reduceShape);
    const xSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend });
    const outType = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sumOutType)(x.dtype);
    const reduced = (0,_kernel_utils_reduce__WEBPACK_IMPORTED_MODULE_3__.reduce)(reshapedInput, outType, 'sum', backend);
    const out = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: reduced }, attrs: { shape: outShape }, backend });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    if (sumInputIsTransposed) {
        backend.disposeIntermediateTensorInfo(sumInput);
    }
    return out;
}
//# sourceMappingURL=Sum_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tan": () => (/* binding */ tan),
/* harmony export */   "tanConfig": () => (/* binding */ tanConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const TAN = `return tan(x);`;
const tan = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: TAN });
const tanConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Tan,
    backendName: 'webgl',
    kernelFunc: tan,
};
//# sourceMappingURL=Tan.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tanh": () => (/* binding */ tanh),
/* harmony export */   "tanhConfig": () => (/* binding */ tanhConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/kernel_funcs_utils */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


const TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
const tanh = (0,_kernel_utils_kernel_funcs_utils__WEBPACK_IMPORTED_MODULE_1__.unaryKernelFunc)({ opSnippet: TANH });
const tanhConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Tanh,
    backendName: 'webgl',
    kernelFunc: tanh,
};
//# sourceMappingURL=Tanh.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tile": () => (/* binding */ tile),
/* harmony export */   "tileConfig": () => (/* binding */ tileConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _tile_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tile_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function tile(params) {
    const { inputs, backend, attrs } = params;
    const { x } = inputs;
    const { reps } = attrs;
    if (x.dtype === 'string') {
        // Even thought string tensor is always on CPU, just to be consistent on how
        // to access tensor data.
        const data = backend.readSync(x.dataId);
        const decodedData = data.map(d => _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.decodeString(d));
        const buf = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.buffer)(x.shape, x.dtype, decodedData);
        const outBuf = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.tileImplCPU)(buf, reps);
        return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
    }
    const program = new _tile_gpu__WEBPACK_IMPORTED_MODULE_2__.TileProgram(x.shape, reps);
    const output = backend.runWebGLProgram(program, [x], x.dtype);
    return output;
}
const tileConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Tile,
    backendName: 'webgl',
    kernelFunc: tile,
};
//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "topK": () => (/* binding */ topK),
/* harmony export */   "topKConfig": () => (/* binding */ topKConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function topK(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { k, sorted } = attrs;
    const xVals = backend.readSync(x.dataId);
    const [allTopKVals, allTopKIndices] = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_1__.topKImplCPU)(xVals, x.shape, x.dtype, k, sorted);
    return [
        backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
        backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
    ];
}
const topKConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.TopK,
    backendName: 'webgl',
    kernelFunc: topK
};
//# sourceMappingURL=TopK.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "transposeConfig": () => (/* binding */ transposeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js");
/* harmony import */ var _Transpose_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function transpose(args) {
    const { inputs, backend, attrs } = args;
    const { x } = inputs;
    const { perm } = attrs;
    const webglBackend = backend;
    const xRank = x.shape.length;
    const newShape = new Array(xRank);
    for (let i = 0; i < newShape.length; i++) {
        newShape[i] = x.shape[perm[i]];
    }
    let out;
    if (webglBackend.shouldExecuteOnCPU([x])) {
        const xTexData = webglBackend.texData.get(x.dataId);
        const values = xTexData.values;
        const outValues = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_1__.transposeImplCPU)(values, x.shape, x.dtype, perm, newShape);
        out = webglBackend.makeTensorInfo(newShape, x.dtype);
        const outData = webglBackend.texData.get(out.dataId);
        outData.values = outValues;
    }
    else {
        out = (0,_Transpose_impl__WEBPACK_IMPORTED_MODULE_2__.transposeImpl)(x, perm, webglBackend);
    }
    return out;
}
const transposeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Transpose,
    backendName: 'webgl',
    kernelFunc: transpose
};
//# sourceMappingURL=Transpose.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transposeImpl": () => (/* binding */ transposeImpl),
/* harmony export */   "transposeImplCPU": () => (/* reexport safe */ _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_3__.transposeImplCPU)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _transpose_gpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transpose_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js");
/* harmony import */ var _transpose_packed_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transpose_packed_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */




function transposeImpl(x, perm, backend) {
    const program = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?
        new _transpose_packed_gpu__WEBPACK_IMPORTED_MODULE_1__.TransposePackedProgram(x.shape, perm) :
        new _transpose_gpu__WEBPACK_IMPORTED_MODULE_2__.TransposeProgram(x.shape, perm);
    return backend.runWebGLProgram(program, [x], x.dtype);
}

//# sourceMappingURL=Transpose_impl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unique": () => (/* binding */ unique),
/* harmony export */   "uniqueConfig": () => (/* binding */ uniqueConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel_utils/shared */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function unique(args) {
    const { inputs, attrs, backend } = args;
    const { axis } = attrs;
    const { x } = inputs;
    (0,_webgl_util__WEBPACK_IMPORTED_MODULE_1__.assertNotComplex)(x, 'unique');
    // For now, always forward calculation to the CPU backend.
    console.warn('WARNING: ', 'UI might be locked temporarily as data is being downloaded');
    const values = backend.readSync(x.dataId);
    const { outputValues, outputShape, indices } = (0,_kernel_utils_shared__WEBPACK_IMPORTED_MODULE_2__.uniqueImplCPU)(values, axis, x.shape, x.dtype);
    return [
        backend.makeTensorInfo(outputShape, x.dtype, outputValues),
        backend.makeTensorInfo([indices.length], 'int32', indices),
    ];
}
const uniqueConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Unique,
    backendName: 'webgl',
    kernelFunc: unique,
};
//# sourceMappingURL=Unique.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unpack": () => (/* binding */ unpack),
/* harmony export */   "unpackConfig": () => (/* binding */ unpackConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Slice */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function unpack(args) {
    const { inputs, backend, attrs } = args;
    const { value } = inputs;
    let { axis } = attrs;
    if (axis < 0) {
        axis += value.shape.length;
    }
    const x = value;
    const xRank = x.shape.length;
    const num = value.shape[axis];
    const outShape = new Array(xRank - 1);
    let outIndex = 0;
    for (let i = 0; i < xRank; i++) {
        if (i !== axis) {
            outShape[outIndex++] = x.shape[i];
        }
    }
    const toDispose = [];
    const begin = new Array(xRank).fill(0);
    const size = x.shape.slice();
    size[axis] = 1;
    const res = new Array(num);
    for (let i = 0; i < res.length; i++) {
        begin[axis] = i;
        const sliced = (0,_Slice__WEBPACK_IMPORTED_MODULE_1__.slice)({ inputs: { x }, backend, attrs: { begin, size } });
        const reshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: sliced }, backend, attrs: { shape: outShape } });
        res[i] = reshaped;
        toDispose.push(sliced);
    }
    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return res;
}
const unpackConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Unpack,
    backendName: 'webgl',
    kernelFunc: unpack
};
//# sourceMappingURL=Unpack.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unsortedSegmentSum": () => (/* binding */ unsortedSegmentSum),
/* harmony export */   "unsortedSegmentSumConfig": () => (/* binding */ unsortedSegmentSumConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _segment_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../segment_gpu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js");
/* harmony import */ var _Range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Range */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js");
/* harmony import */ var _Reshape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _Tile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Tile */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js");
/* harmony import */ var _Transpose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */






function unsortedSegmentSum(args) {
    const { inputs, backend, attrs } = args;
    const { x, segmentIds } = inputs;
    const { numSegments } = attrs;
    const xRank = x.shape.length;
    const toDispose = [];
    let axis = 0;
    const permutation = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getAxesPermutation([axis], xRank);
    let permutedX = x;
    if (permutation != null) {
        permutedX = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x }, backend, attrs: { perm: permutation } });
        toDispose.push(permutedX);
        axis = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getInnerMostAxes(1, xRank)[0];
    }
    const outShape = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape([permutedX.shape[axis]]);
    const a2D = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });
    toDispose.push(a2D);
    const outputDType = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sumOutType)(x.dtype);
    const segOpCompute = (x, segOpType, segmentIds, dtype, numSegments) => {
        const batchSize = x.shape[0];
        const inSize = x.shape[1];
        const windowSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);
        const segOpInfo = { windowSize, inSize, batchSize, numSegments };
        const program = new _segment_gpu__WEBPACK_IMPORTED_MODULE_3__.SegmentOpProgram(segOpInfo, segOpType);
        const output = backend.compileAndRun(program, [x, segmentIds], dtype);
        toDispose.push(output);
        // No need to run another GPGPU program.
        if (output.shape[1] === numSegments) {
            return output;
        }
        const rangeInfo = (0,_Range__WEBPACK_IMPORTED_MODULE_4__.range)({
            backend,
            attrs: { start: 0, stop: numSegments, step: 1, dtype: 'float32' }
        });
        const tileInfo = (0,_Tile__WEBPACK_IMPORTED_MODULE_5__.tile)({
            inputs: { x: rangeInfo },
            backend,
            attrs: { reps: [inSize / windowSize] }
        });
        toDispose.push(rangeInfo);
        toDispose.push(tileInfo);
        const result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);
        return result;
    };
    const segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);
    const reshaped = (0,_Reshape__WEBPACK_IMPORTED_MODULE_2__.reshape)({ inputs: { x: segOpResult }, backend, attrs: { shape: outShape } });
    let result = reshaped;
    if (permutation != null) {
        toDispose.push(reshaped);
        const perm = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getUndoAxesPermutation(permutation);
        result = (0,_Transpose__WEBPACK_IMPORTED_MODULE_1__.transpose)({ inputs: { x: result }, backend, attrs: { perm } });
    }
    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));
    return result;
}
const unsortedSegmentSumConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.UnsortedSegmentSum,
    backendName: 'webgl',
    kernelFunc: unsortedSegmentSum
};
//# sourceMappingURL=UnsortedSegmentSum.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zerosLike": () => (/* binding */ zerosLike),
/* harmony export */   "zerosLikeConfig": () => (/* binding */ zerosLikeConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _Complex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/* harmony import */ var _Fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Fill */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js");
/* harmony import */ var _Imag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Imag */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js");
/* harmony import */ var _Real__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Real */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */





function zerosLike(args) {
    const { inputs, backend } = args;
    const { x } = inputs;
    if (x.dtype === 'complex64') {
        const realPart = (0,_Real__WEBPACK_IMPORTED_MODULE_1__.real)({ inputs: { input: x }, backend });
        const r = zerosLike({ inputs: { x: realPart }, backend });
        const imagPart = (0,_Imag__WEBPACK_IMPORTED_MODULE_2__.imag)({ inputs: { input: x }, backend });
        const i = zerosLike({ inputs: { x: imagPart }, backend });
        const result = (0,_Complex__WEBPACK_IMPORTED_MODULE_3__.complex)({ inputs: { real: r, imag: i }, backend });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result;
    }
    else {
        return (0,_Fill__WEBPACK_IMPORTED_MODULE_4__.fill)({
            attrs: {
                shape: x.shape,
                dtype: x.dtype,
                value: x.dtype === 'string' ? '' : 0
            },
            backend
        });
    }
}
const zerosLikeConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ZerosLike,
    backendName: 'webgl',
    kernelFunc: zerosLike
};
//# sourceMappingURL=ZerosLike.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_fusedMatMul": () => (/* binding */ _fusedMatMul),
/* harmony export */   "_fusedMatMulConfig": () => (/* binding */ _fusedMatMulConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BatchMatMul_impl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


function _fusedMatMul(args) {
    const { inputs, backend, attrs } = args;
    const { a, b, bias, preluActivationWeights } = inputs;
    const { transposeA, transposeB, activation, leakyreluAlpha } = attrs;
    return (0,_BatchMatMul_impl__WEBPACK_IMPORTED_MODULE_1__.batchMatMulImpl)({
        a,
        b,
        transposeA,
        transposeB,
        backend,
        bias,
        preluActivationWeights,
        leakyreluAlpha,
        activation
    });
}
const _fusedMatMulConfig = {
    kernelName: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__._FusedMatMul,
    backendName: 'webgl',
    kernelFunc: _fusedMatMul,
};
//# sourceMappingURL=_FusedMatMul.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LRNProgram": () => (/* binding */ LRNProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class LRNProgram {
    constructor(xShape, radius, bias, alpha, beta) {
        this.variableNames = ['x'];
        this.outputShape = [];
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        // optimize pow(bias + alpha * sum, -beta)
        // src: https://github.com/tensorflow/tensorflow/..
        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..
        // tensorflow/core/kernels/mkl_lrn_op.cc#L320
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) {
            powOperator = `inversesqrt(${basis})`;
        }
        else if (beta === 1.0) {
            powOperator = `1.0/(${basis})`;
        }
        else {
            powOperator = `exp(log(${basis}) * float(-${beta}));`;
        }
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
    }
}
//# sourceMappingURL=lrn_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LRNGradProgram": () => (/* binding */ LRNGradProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class LRNGradProgram {
    constructor(inputShape, depthRadius, bias, alpha, beta) {
        this.variableNames = ['inputImage', 'outputImage', 'dy'];
        this.outputShape = [];
        this.outputShape = inputShape;
        this.depth = inputShape[3];
        this.depthRadius = depthRadius;
        this.bias = bias;
        this.alpha = alpha;
        this.beta = beta;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=lrn_grad_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LRNPackedProgram": () => (/* binding */ LRNPackedProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class LRNPackedProgram {
    constructor(xShape, radius, bias, alpha, beta) {
        this.variableNames = ['x'];
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        // optimize pow(bias + alpha * sum, -beta)
        // src: https://github.com/tensorflow/tensorflow/..
        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..
        // tensorflow/core/kernels/mkl_lrn_op.cc#L320
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) {
            powOperator = `inversesqrt(${basis})`;
        }
        else if (beta === 1.0) {
            powOperator = `1.0/(${basis})`;
        }
        else {
            powOperator = `exp(log(${basis}) * float(-${beta}));`;
        }
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=lrn_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaxPool2DBackpropProgram": () => (/* binding */ MaxPool2DBackpropProgram),
/* harmony export */   "MaxPool3DBackpropProgram": () => (/* binding */ MaxPool3DBackpropProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MaxPool2DBackpropProgram {
    constructor(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class MaxPool3DBackpropProgram {
    constructor(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
//# sourceMappingURL=max_pool_backprop_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeanProgram": () => (/* binding */ MeanProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class MeanProgram {
    constructor(reduceInfo, divisor) {
        this.variableNames = ['x'];
        const { windowSize, batchSize, inSize, outSize } = reduceInfo;
        this.outputShape = [batchSize, outSize];
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `sumValue += dot(values, ones);`;
        if (divisor != null) {
            const denominator = 1 / divisor;
            updateSnippet = `sumValue += dot(values * ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.isInt(denominator) ? denominator.toPrecision(2) :
                denominator}, ones);`;
        }
        let checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
        }
        this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
    }
}
//# sourceMappingURL=mean_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MirrorPadProgram": () => (/* binding */ MirrorPadProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class MirrorPadProgram {
    constructor(xShape, paddings, mode) {
        this.variableNames = ['x'];
        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);
        const rank = xShape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(rank);
        const start = paddings.map(p => p[0]).join(',');
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');
        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);
        const offset = mode === 'reflect' ? 0 : 1;
        if (rank === 1) {
            this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
            return;
        }
        this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
    }
}
//# sourceMappingURL=mirror_pad_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MirrorPadPackedProgram": () => (/* binding */ MirrorPadPackedProgram)
/* harmony export */ });
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


/**
 * Example shader code for
 * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`
 * ```
 *    const int start = int(2);
 *    const int end = int(5);
 *
 *    void main() {
 *       int outputLoc = getOutputCoords();
 *       vec4 result = vec4(0.);
 *
 *       int rc = outputLoc;
 *
 *       int source = rc;
 *       if (source < start) {
 *         source = start * 2 - source - 0;
 *       } else if (source >= end) {
 *         source = (end - 1) * 2 - source + 0;
 *       }
 *       source -= start;
 *
 *       result[0] = getChannel(getX(source), source);
 *       rc += 1;
 *       if(rc < 6) {
 *          int source = rc;
 *          if (source < start) {
 *            source = start * 2 - source - 0;
 *          } else if (source >= end) {
 *            source = (end - 1) * 2 - source + 0;
 *          }
 *          source -= start;
 *
 *         result[1] = getChannel(getX(source), source);
 *       }
 *
 *       setOutput(result);
 *     }
 * ```
 */
class MirrorPadPackedProgram {
    constructor(xShape, paddings, mode) {
        this.variableNames = ['x'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);
        const rank = xShape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(rank);
        const start = paddings.map(p => p[0]).join(',');
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');
        const coords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_1__.getChannels)('rc', rank);
        const source = (0,_packing_util__WEBPACK_IMPORTED_MODULE_1__.getChannels)('source', rank);
        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;
        const offset = mode === 'reflect' ? 0 : 1;
        let mainLoop = '';
        if (rank === 1) {
            const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
            mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
        }
        else {
            const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
            mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords[rank - 2]} += 1;
        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
        }
        this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=mirror_pad_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MatMulPackedProgram": () => (/* binding */ MatMulPackedProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MatMulPackedProgram {
    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false) {
        this.variableNames = ['matrixA', 'matrixB'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const sharedDim = transposeA ? aShape[1] : aShape[2];
        const sharedDimensionPacked = Math.ceil(sharedDim / 2);
        const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';
        const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';
        const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];
        const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivation) {
                activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            }
            else if (hasLeakyreluActivation) {
                activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            }
            else {
                activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
            }
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivation) {
            this.variableNames.push('preluActivationWeights');
        }
        if (hasLeakyreluActivation) {
            this.variableNames.push('leakyreluAlpha');
        }
        let batchASnippet = 'rc.x';
        let batchBSnippet = 'rc.x';
        if (aShape[0] < bShape[0]) {
            batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;
        }
        else if (bShape[0] < aShape[0]) {
            batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;
        }
        this.userCode = `
      ${activationSnippet}

      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          int batchA = ${batchASnippet};
          int batchB = ${batchBSnippet};
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=mulmat_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultinomialProgram": () => (/* binding */ MultinomialProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MultinomialProgram {
    constructor(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = `
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
    }
    getCustomSetupFunc(seed) {
        return (gpgpu, webGLProgram) => {
            if (this.seedLoc == null) {
                this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(this.seedLoc, seed);
        };
    }
}
//# sourceMappingURL=multinomial_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OneHotProgram": () => (/* binding */ OneHotProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OneHotProgram {
    constructor(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
    }
}
//# sourceMappingURL=onehot_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PackProgram": () => (/* binding */ PackProgram)
/* harmony export */ });
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


class PackProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        this.packedInputs = false;
        this.packedOutput = true;
        // Only input / output 3D tensors.
        this.outputShape = outputShape;
        const rank = outputShape.length;
        if (rank === 0) {
            this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
        }
        else {
            const channels = (0,_packing_util__WEBPACK_IMPORTED_MODULE_0__.getChannels)('rc', rank);
            const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_1__.getCoordsDataType)(rank);
            const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);
            const setup = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);
            const output = getOutput(outputShape, channels);
            this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup}

            setOutput(vec4(${output}));
          }
        }
      `;
        }
    }
}
function getSourceCoordsArr(rank, dims) {
    const coords = [];
    for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
            let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;
            for (let d = 2; d < rank; d++) {
                coord = `${dims[dims.length - 1 - d]},` + coord;
            }
            coords.push(coord);
        }
    }
    return coords;
}
function getOutOfBoundsCondition(rank, shape, dims) {
    if (rank === 1) {
        return `rc > ${shape[0]}`;
    }
    let cond = '';
    for (let i = rank - 2; i < rank; i++) {
        cond += `${dims[i]} >= ${shape[i]}`;
        if (i < rank - 1) {
            cond += '||';
        }
    }
    return cond;
}
function getSetup(rank, cols, rows, dims) {
    if (rank === 1) {
        return '';
    }
    const innerDims = dims.slice(-2);
    return `
    int r = ${innerDims[0]};
    int c = ${innerDims[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${cols};
    bool rEdge = rp1 >= ${rows};
  `;
}
function getOutput(shape, dims) {
    const rank = shape.length;
    const sourceCoords = getSourceCoordsArr(rank, dims);
    if (rank === 1) {
        return `getA(rc),
            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),
            0, 0`;
    }
    return `getA(${sourceCoords[0]}),
          cEdge ? 0. : getA(${sourceCoords[1]}),
          rEdge ? 0. : getA(${sourceCoords[2]}),
          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
}
//# sourceMappingURL=pack_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getVecChannels": () => (/* binding */ getVecChannels),
/* harmony export */   "getChannels": () => (/* binding */ getChannels),
/* harmony export */   "getSourceCoords": () => (/* binding */ getSourceCoords)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getVecChannels(name, rank) {
    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);
}
function getChannels(name, rank) {
    if (rank === 1) {
        return [name];
    }
    return getVecChannels(name, rank);
}
function getSourceCoords(rank, dims) {
    if (rank === 1) {
        return 'rc';
    }
    let coords = '';
    for (let i = 0; i < rank; i++) {
        coords += dims[i];
        if (i < rank - 1) {
            coords += ',';
        }
    }
    return coords;
}
//# sourceMappingURL=packing_util.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PadProgram": () => (/* binding */ PadProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class PadProgram {
    constructor(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);
        const rank = xShape.length;
        const type = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(rank);
        const start = paddings.map(p => p[0]).join(',');
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');
        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);
        if (rank === 1) {
            this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(${constantValue}));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
            return;
        }
        this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(${constantValue}));
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
    }
}
//# sourceMappingURL=pad_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PadPackedProgram": () => (/* binding */ PadPackedProgram)
/* harmony export */ });
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


class PadPackedProgram {
    constructor(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);
        const rank = xShape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(rank);
        const start = paddings.map(p => p[0]).join(',');
        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');
        const coords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_1__.getChannels)('rc', rank);
        const source = (0,_packing_util__WEBPACK_IMPORTED_MODULE_1__.getChannels)('source', rank);
        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;
        const componentSetup = [
            `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;
       if(${cLimit}) {
      `,
            rank === 1 ? '' : `}
       rc = outputLoc;
       ${coords[rank - 2]} += 1;
       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
            rank === 1 ? '' : `  ${coords[rank - 1]} += 1;
         if(${cLimit}) {`
        ];
        const paddingArea = rank === 1 ?
            'rc < start || rc >= end' :
            'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';
        let mainLoop = '';
        for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {
            mainLoop += `
        ${componentSetup[i]}
        if (${paddingArea}) {
          result[${i}] = float(${constantValue});
        } else {
          ${dtype} source = rc - start;
          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
        }
        mainLoop += (rank === 1 ? `} ` : `}}`);
        this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
}
//# sourceMappingURL=pad_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Pool2DProgram": () => (/* binding */ Pool2DProgram),
/* harmony export */   "Pool3DProgram": () => (/* binding */ Pool3DProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Pool2DProgram {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === 'avg';
        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        let initializationValue = '0.0';
        if (!isAvgPool) {
            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
            initializationValue = '-1.0 / 1e-20';
        }
        if (computePositions) {
            const compareOp = '>=';
            this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :
                flattenPositionStr) :
                `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
            return;
        }
        const compareOp = 'max';
        let returnValue = `${poolType}(${poolType}(${poolType}(` +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = `avgValue / count`;
        }
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
    }
}
class Pool3DProgram {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === 'avg';
        let initializationValue = '0.0';
        if (!isAvgPool) {
            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
            initializationValue = '-1.0 / 1e-20';
        }
        if (computePositions) {
            const compareOp = '>=';
            this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ?
                (includeBatchInIndex ?
                    `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` :
                    `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :
                `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
            return;
        }
        const compareOp = 'max';
        let returnValue = `${poolType}(${poolType}(${poolType}(` +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = `avgValue / count`;
        }
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
          setOutput(${returnValue});
        }
      }
    `;
    }
}
//# sourceMappingURL=pool_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReduceProgram": () => (/* binding */ ReduceProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ReduceProgram {
    constructor(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        const { windowSize, batchSize, inSize, outSize } = reduceInfo;
        this.outputShape = [batchSize, outSize];
        let initializationValue = '0.0';
        let compareOp = ``;
        if (reduceType === 'prod') {
            initializationValue = '1.0';
        }
        else if (reduceType === 'min') {
            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
            initializationValue = '1.0 / 1e-20';
            compareOp = `min`;
        }
        else if (reduceType === 'max') {
            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
            initializationValue = '-1.0 / 1e-20';
            compareOp = `max`;
        }
        let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = `sumValue`;
        }
        else if (reduceType === 'prod') {
            returnValue = `prodValue`;
        }
        else if (reduceType === 'all') {
            returnValue = `allValue`;
        }
        else if (reduceType === 'any') {
            returnValue = `anyValue`;
        }
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `
      if (${reduceType === 'sum'}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === 'prod'}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        let vecType = `vec4`;
        if (reduceType === 'all') {
            initializationValue = '1.0';
            updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
            vecType = `bvec4`;
        }
        else if (reduceType === 'any') {
            initializationValue = '0.0';
            updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
            vecType = `bvec4`;
        }
        let checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
        }
        this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
}
//# sourceMappingURL=reduce_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _kernels_FusedMatMul__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./kernels/_FusedMatMul */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js");
/* harmony import */ var _kernels_Abs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./kernels/Abs */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js");
/* harmony import */ var _kernels_Acos__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./kernels/Acos */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js");
/* harmony import */ var _kernels_Acosh__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./kernels/Acosh */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js");
/* harmony import */ var _kernels_Add__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./kernels/Add */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js");
/* harmony import */ var _kernels_AddN__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./kernels/AddN */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js");
/* harmony import */ var _kernels_All__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./kernels/All */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/All.js");
/* harmony import */ var _kernels_Any__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./kernels/Any */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js");
/* harmony import */ var _kernels_ArgMax__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./kernels/ArgMax */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js");
/* harmony import */ var _kernels_ArgMin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./kernels/ArgMin */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js");
/* harmony import */ var _kernels_Asin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./kernels/Asin */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js");
/* harmony import */ var _kernels_Asinh__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./kernels/Asinh */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js");
/* harmony import */ var _kernels_Atan__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./kernels/Atan */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js");
/* harmony import */ var _kernels_Atan2__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./kernels/Atan2 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js");
/* harmony import */ var _kernels_Atanh__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./kernels/Atanh */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js");
/* harmony import */ var _kernels_AvgPool__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./kernels/AvgPool */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js");
/* harmony import */ var _kernels_AvgPool3D__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./kernels/AvgPool3D */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js");
/* harmony import */ var _kernels_AvgPool3DGrad__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./kernels/AvgPool3DGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js");
/* harmony import */ var _kernels_AvgPoolGrad__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./kernels/AvgPoolGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js");
/* harmony import */ var _kernels_BatchMatMul__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./kernels/BatchMatMul */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js");
/* harmony import */ var _kernels_BatchNorm__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./kernels/BatchNorm */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js");
/* harmony import */ var _kernels_BatchToSpaceND__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./kernels/BatchToSpaceND */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js");
/* harmony import */ var _kernels_Bincount__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./kernels/Bincount */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js");
/* harmony import */ var _kernels_Cast__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./kernels/Cast */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js");
/* harmony import */ var _kernels_Ceil__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./kernels/Ceil */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js");
/* harmony import */ var _kernels_ClipByValue__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./kernels/ClipByValue */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js");
/* harmony import */ var _kernels_Complex__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./kernels/Complex */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js");
/* harmony import */ var _kernels_ComplexAbs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./kernels/ComplexAbs */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js");
/* harmony import */ var _kernels_Concat__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./kernels/Concat */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js");
/* harmony import */ var _kernels_Conv2D__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./kernels/Conv2D */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js");
/* harmony import */ var _kernels_Conv2DBackpropFilter__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./kernels/Conv2DBackpropFilter */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js");
/* harmony import */ var _kernels_Conv2DBackpropInput__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./kernels/Conv2DBackpropInput */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js");
/* harmony import */ var _kernels_Conv3D__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./kernels/Conv3D */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js");
/* harmony import */ var _kernels_Conv3DBackpropFilterV2__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./kernels/Conv3DBackpropFilterV2 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js");
/* harmony import */ var _kernels_Conv3DBackpropInputV2__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./kernels/Conv3DBackpropInputV2 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js");
/* harmony import */ var _kernels_Cos__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./kernels/Cos */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js");
/* harmony import */ var _kernels_Cosh__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./kernels/Cosh */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js");
/* harmony import */ var _kernels_CropAndResize__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./kernels/CropAndResize */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js");
/* harmony import */ var _kernels_Cumsum__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./kernels/Cumsum */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js");
/* harmony import */ var _kernels_DenseBincount__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./kernels/DenseBincount */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js");
/* harmony import */ var _kernels_DepthToSpace__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./kernels/DepthToSpace */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js");
/* harmony import */ var _kernels_DepthwiseConv2dNative__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./kernels/DepthwiseConv2dNative */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js");
/* harmony import */ var _kernels_DepthwiseConv2dNativeBackpropFilter__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./kernels/DepthwiseConv2dNativeBackpropFilter */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js");
/* harmony import */ var _kernels_DepthwiseConv2dNativeBackpropInput__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./kernels/DepthwiseConv2dNativeBackpropInput */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js");
/* harmony import */ var _kernels_Diag__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./kernels/Diag */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js");
/* harmony import */ var _kernels_Dilation2D__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./kernels/Dilation2D */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js");
/* harmony import */ var _kernels_Elu__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./kernels/Elu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js");
/* harmony import */ var _kernels_EluGrad__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./kernels/EluGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js");
/* harmony import */ var _kernels_Equal__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./kernels/Equal */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js");
/* harmony import */ var _kernels_Erf__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./kernels/Erf */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js");
/* harmony import */ var _kernels_Exp__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./kernels/Exp */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js");
/* harmony import */ var _kernels_ExpandDims__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./kernels/ExpandDims */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js");
/* harmony import */ var _kernels_Expm1__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./kernels/Expm1 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js");
/* harmony import */ var _kernels_FFT__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./kernels/FFT */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js");
/* harmony import */ var _kernels_Fill__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./kernels/Fill */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js");
/* harmony import */ var _kernels_FlipLeftRight__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./kernels/FlipLeftRight */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js");
/* harmony import */ var _kernels_Floor__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./kernels/Floor */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js");
/* harmony import */ var _kernels_FloorDiv__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./kernels/FloorDiv */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js");
/* harmony import */ var _kernels_FromPixels__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./kernels/FromPixels */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js");
/* harmony import */ var _kernels_FusedConv2D__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./kernels/FusedConv2D */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js");
/* harmony import */ var _kernels_FusedDepthwiseConv2D__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./kernels/FusedDepthwiseConv2D */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js");
/* harmony import */ var _kernels_GatherNd__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./kernels/GatherNd */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js");
/* harmony import */ var _kernels_GatherV2__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./kernels/GatherV2 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js");
/* harmony import */ var _kernels_Greater__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./kernels/Greater */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js");
/* harmony import */ var _kernels_GreaterEqual__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./kernels/GreaterEqual */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js");
/* harmony import */ var _kernels_Identity__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./kernels/Identity */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js");
/* harmony import */ var _kernels_IFFT__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./kernels/IFFT */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js");
/* harmony import */ var _kernels_Imag__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./kernels/Imag */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js");
/* harmony import */ var _kernels_IsFinite__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./kernels/IsFinite */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js");
/* harmony import */ var _kernels_IsInf__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./kernels/IsInf */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js");
/* harmony import */ var _kernels_IsNaN__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./kernels/IsNaN */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js");
/* harmony import */ var _kernels_LeakyRelu__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./kernels/LeakyRelu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js");
/* harmony import */ var _kernels_Less__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./kernels/Less */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js");
/* harmony import */ var _kernels_LessEqual__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./kernels/LessEqual */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js");
/* harmony import */ var _kernels_LinSpace__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./kernels/LinSpace */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js");
/* harmony import */ var _kernels_Log__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./kernels/Log */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js");
/* harmony import */ var _kernels_Log1p__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./kernels/Log1p */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js");
/* harmony import */ var _kernels_LogicalAnd__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./kernels/LogicalAnd */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js");
/* harmony import */ var _kernels_LogicalNot__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./kernels/LogicalNot */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js");
/* harmony import */ var _kernels_LogicalOr__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./kernels/LogicalOr */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js");
/* harmony import */ var _kernels_LRN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kernels/LRN */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js");
/* harmony import */ var _kernels_LRNGrad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kernels/LRNGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js");
/* harmony import */ var _kernels_Max__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./kernels/Max */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js");
/* harmony import */ var _kernels_Maximum__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./kernels/Maximum */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js");
/* harmony import */ var _kernels_MaxPool__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./kernels/MaxPool */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js");
/* harmony import */ var _kernels_MaxPool3D__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./kernels/MaxPool3D */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js");
/* harmony import */ var _kernels_MaxPool3DGrad__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./kernels/MaxPool3DGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js");
/* harmony import */ var _kernels_MaxPoolGrad__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./kernels/MaxPoolGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js");
/* harmony import */ var _kernels_MaxPoolWithArgmax__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./kernels/MaxPoolWithArgmax */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js");
/* harmony import */ var _kernels_Mean__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./kernels/Mean */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js");
/* harmony import */ var _kernels_Min__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./kernels/Min */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js");
/* harmony import */ var _kernels_Minimum__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./kernels/Minimum */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js");
/* harmony import */ var _kernels_MirrorPad__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./kernels/MirrorPad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js");
/* harmony import */ var _kernels_Mod__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./kernels/Mod */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js");
/* harmony import */ var _kernels_Multinomial__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./kernels/Multinomial */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js");
/* harmony import */ var _kernels_Multiply__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./kernels/Multiply */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js");
/* harmony import */ var _kernels_Neg__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./kernels/Neg */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js");
/* harmony import */ var _kernels_NonMaxSuppressionV3__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./kernels/NonMaxSuppressionV3 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js");
/* harmony import */ var _kernels_NonMaxSuppressionV4__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./kernels/NonMaxSuppressionV4 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js");
/* harmony import */ var _kernels_NonMaxSuppressionV5__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./kernels/NonMaxSuppressionV5 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js");
/* harmony import */ var _kernels_NotEqual__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./kernels/NotEqual */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js");
/* harmony import */ var _kernels_OneHot__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./kernels/OneHot */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js");
/* harmony import */ var _kernels_OnesLike__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./kernels/OnesLike */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js");
/* harmony import */ var _kernels_Pack__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./kernels/Pack */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js");
/* harmony import */ var _kernels_PadV2__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./kernels/PadV2 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js");
/* harmony import */ var _kernels_Pow__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./kernels/Pow */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js");
/* harmony import */ var _kernels_Prelu__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./kernels/Prelu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js");
/* harmony import */ var _kernels_Prod__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./kernels/Prod */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js");
/* harmony import */ var _kernels_Range__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./kernels/Range */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js");
/* harmony import */ var _kernels_Real__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./kernels/Real */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js");
/* harmony import */ var _kernels_RealDiv__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./kernels/RealDiv */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js");
/* harmony import */ var _kernels_Reciprocal__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./kernels/Reciprocal */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js");
/* harmony import */ var _kernels_Relu__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./kernels/Relu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js");
/* harmony import */ var _kernels_Relu6__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./kernels/Relu6 */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js");
/* harmony import */ var _kernels_Reshape__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./kernels/Reshape */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js");
/* harmony import */ var _kernels_ResizeBilinear__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./kernels/ResizeBilinear */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js");
/* harmony import */ var _kernels_ResizeBilinearGrad__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./kernels/ResizeBilinearGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js");
/* harmony import */ var _kernels_ResizeNearestNeighbor__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./kernels/ResizeNearestNeighbor */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js");
/* harmony import */ var _kernels_ResizeNearestNeighborGrad__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./kernels/ResizeNearestNeighborGrad */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js");
/* harmony import */ var _kernels_Reverse__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./kernels/Reverse */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js");
/* harmony import */ var _kernels_RotateWithOffset__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./kernels/RotateWithOffset */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js");
/* harmony import */ var _kernels_Round__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./kernels/Round */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js");
/* harmony import */ var _kernels_Rsqrt__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./kernels/Rsqrt */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js");
/* harmony import */ var _kernels_ScatterNd__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./kernels/ScatterNd */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js");
/* harmony import */ var _kernels_Select__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./kernels/Select */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js");
/* harmony import */ var _kernels_Selu__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./kernels/Selu */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js");
/* harmony import */ var _kernels_Sigmoid__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./kernels/Sigmoid */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js");
/* harmony import */ var _kernels_Sign__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./kernels/Sign */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js");
/* harmony import */ var _kernels_Sin__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./kernels/Sin */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js");
/* harmony import */ var _kernels_Sinh__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./kernels/Sinh */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js");
/* harmony import */ var _kernels_Slice__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./kernels/Slice */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js");
/* harmony import */ var _kernels_Softmax__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./kernels/Softmax */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js");
/* harmony import */ var _kernels_Softplus__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./kernels/Softplus */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js");
/* harmony import */ var _kernels_SpaceToBatchND__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./kernels/SpaceToBatchND */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js");
/* harmony import */ var _kernels_SparseToDense__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./kernels/SparseToDense */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js");
/* harmony import */ var _kernels_SplitV__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./kernels/SplitV */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js");
/* harmony import */ var _kernels_Sqrt__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./kernels/Sqrt */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js");
/* harmony import */ var _kernels_Square__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./kernels/Square */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js");
/* harmony import */ var _kernels_SquaredDifference__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./kernels/SquaredDifference */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js");
/* harmony import */ var _kernels_Step__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./kernels/Step */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js");
/* harmony import */ var _kernels_StridedSlice__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./kernels/StridedSlice */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js");
/* harmony import */ var _kernels_Sub__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./kernels/Sub */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js");
/* harmony import */ var _kernels_Sum__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./kernels/Sum */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js");
/* harmony import */ var _kernels_Tan__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./kernels/Tan */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js");
/* harmony import */ var _kernels_Tanh__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./kernels/Tanh */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js");
/* harmony import */ var _kernels_Tile__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./kernels/Tile */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js");
/* harmony import */ var _kernels_TopK__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./kernels/TopK */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js");
/* harmony import */ var _kernels_Transpose__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./kernels/Transpose */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js");
/* harmony import */ var _kernels_Unique__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./kernels/Unique */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js");
/* harmony import */ var _kernels_Unpack__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./kernels/Unpack */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js");
/* harmony import */ var _kernels_UnsortedSegmentSum__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./kernels/UnsortedSegmentSum */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js");
/* harmony import */ var _kernels_ZerosLike__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./kernels/ZerosLike */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

























































































































































// List all kernel configs here
const kernelConfigs = [
    _kernels_LRN__WEBPACK_IMPORTED_MODULE_1__.LRNConfig,
    _kernels_LRNGrad__WEBPACK_IMPORTED_MODULE_2__.LRNGradConfig,
    _kernels_FusedMatMul__WEBPACK_IMPORTED_MODULE_3__._fusedMatMulConfig,
    _kernels_Abs__WEBPACK_IMPORTED_MODULE_4__.absConfig,
    _kernels_Acos__WEBPACK_IMPORTED_MODULE_5__.acosConfig,
    _kernels_Acosh__WEBPACK_IMPORTED_MODULE_6__.acoshConfig,
    _kernels_Add__WEBPACK_IMPORTED_MODULE_7__.addConfig,
    _kernels_AddN__WEBPACK_IMPORTED_MODULE_8__.addNConfig,
    _kernels_All__WEBPACK_IMPORTED_MODULE_9__.allConfig,
    _kernels_Any__WEBPACK_IMPORTED_MODULE_10__.anyConfig,
    _kernels_ArgMax__WEBPACK_IMPORTED_MODULE_11__.argMaxConfig,
    _kernels_ArgMin__WEBPACK_IMPORTED_MODULE_12__.argMinConfig,
    _kernels_Asin__WEBPACK_IMPORTED_MODULE_13__.asinConfig,
    _kernels_Asinh__WEBPACK_IMPORTED_MODULE_14__.asinhConfig,
    _kernels_Atan2__WEBPACK_IMPORTED_MODULE_15__.atan2Config,
    _kernels_Atan__WEBPACK_IMPORTED_MODULE_16__.atanConfig,
    _kernels_Atanh__WEBPACK_IMPORTED_MODULE_17__.atanhConfig,
    _kernels_AvgPool3D__WEBPACK_IMPORTED_MODULE_18__.avgPool3DConfig,
    _kernels_AvgPool__WEBPACK_IMPORTED_MODULE_19__.avgPoolConfig,
    _kernels_AvgPool3DGrad__WEBPACK_IMPORTED_MODULE_20__.avgPoolGrad3DConfig,
    _kernels_AvgPoolGrad__WEBPACK_IMPORTED_MODULE_21__.avgPoolGradConfig,
    _kernels_BatchMatMul__WEBPACK_IMPORTED_MODULE_22__.batchMatMulConfig,
    _kernels_BatchNorm__WEBPACK_IMPORTED_MODULE_23__.batchNormConfig,
    _kernels_BatchToSpaceND__WEBPACK_IMPORTED_MODULE_24__.batchToSpaceNDConfig,
    _kernels_Bincount__WEBPACK_IMPORTED_MODULE_25__.bincountConfig,
    _kernels_Cast__WEBPACK_IMPORTED_MODULE_26__.castConfig,
    _kernels_Ceil__WEBPACK_IMPORTED_MODULE_27__.ceilConfig,
    _kernels_ClipByValue__WEBPACK_IMPORTED_MODULE_28__.clipByValueConfig,
    _kernels_ComplexAbs__WEBPACK_IMPORTED_MODULE_29__.complexAbsConfig,
    _kernels_Complex__WEBPACK_IMPORTED_MODULE_30__.complexConfig,
    _kernels_Concat__WEBPACK_IMPORTED_MODULE_31__.concatConfig,
    _kernels_Conv2DBackpropFilter__WEBPACK_IMPORTED_MODULE_32__.conv2DBackpropFilterConfig,
    _kernels_Conv2DBackpropInput__WEBPACK_IMPORTED_MODULE_33__.conv2DBackpropInputConfig,
    _kernels_Conv2D__WEBPACK_IMPORTED_MODULE_34__.conv2DConfig,
    _kernels_Conv3DBackpropFilterV2__WEBPACK_IMPORTED_MODULE_35__.conv3DBackpropFilterV2Config,
    _kernels_Conv3DBackpropInputV2__WEBPACK_IMPORTED_MODULE_36__.conv3DBackpropInputConfig,
    _kernels_Conv3D__WEBPACK_IMPORTED_MODULE_37__.conv3DConfig,
    _kernels_Cos__WEBPACK_IMPORTED_MODULE_38__.cosConfig,
    _kernels_Cosh__WEBPACK_IMPORTED_MODULE_39__.coshConfig,
    _kernels_CropAndResize__WEBPACK_IMPORTED_MODULE_40__.cropAndResizeConfig,
    _kernels_Cumsum__WEBPACK_IMPORTED_MODULE_41__.cumsumConfig,
    _kernels_DenseBincount__WEBPACK_IMPORTED_MODULE_42__.denseBincountConfig,
    _kernels_DepthToSpace__WEBPACK_IMPORTED_MODULE_43__.depthToSpaceConfig,
    _kernels_DepthwiseConv2dNativeBackpropFilter__WEBPACK_IMPORTED_MODULE_44__.depthwiseConv2dNativeBackpropFilterConfig,
    _kernels_DepthwiseConv2dNativeBackpropInput__WEBPACK_IMPORTED_MODULE_45__.depthwiseConv2dNativeBackpropInputConfig,
    _kernels_DepthwiseConv2dNative__WEBPACK_IMPORTED_MODULE_46__.depthwiseConv2dNativeConfig,
    _kernels_Diag__WEBPACK_IMPORTED_MODULE_47__.diagConfig,
    _kernels_Dilation2D__WEBPACK_IMPORTED_MODULE_48__.dilation2DConfig,
    _kernels_Elu__WEBPACK_IMPORTED_MODULE_49__.eluConfig,
    _kernels_EluGrad__WEBPACK_IMPORTED_MODULE_50__.eluGradConfig,
    _kernels_Equal__WEBPACK_IMPORTED_MODULE_51__.equalConfig,
    _kernels_Erf__WEBPACK_IMPORTED_MODULE_52__.erfConfig,
    _kernels_Exp__WEBPACK_IMPORTED_MODULE_53__.expConfig,
    _kernels_ExpandDims__WEBPACK_IMPORTED_MODULE_54__.expandDimsConfig,
    _kernels_Expm1__WEBPACK_IMPORTED_MODULE_55__.expm1Config,
    _kernels_FFT__WEBPACK_IMPORTED_MODULE_56__.fftConfig,
    _kernels_Fill__WEBPACK_IMPORTED_MODULE_57__.fillConfig,
    _kernels_FlipLeftRight__WEBPACK_IMPORTED_MODULE_58__.flipLeftRightConfig,
    _kernels_Floor__WEBPACK_IMPORTED_MODULE_59__.floorConfig,
    _kernels_FloorDiv__WEBPACK_IMPORTED_MODULE_60__.floorDivConfig,
    _kernels_FromPixels__WEBPACK_IMPORTED_MODULE_61__.fromPixelsConfig,
    _kernels_FusedConv2D__WEBPACK_IMPORTED_MODULE_62__.fusedConv2DConfig,
    _kernels_FusedDepthwiseConv2D__WEBPACK_IMPORTED_MODULE_63__.fusedDepthwiseConv2DConfig,
    _kernels_GatherNd__WEBPACK_IMPORTED_MODULE_64__.gatherNdConfig,
    _kernels_GatherV2__WEBPACK_IMPORTED_MODULE_65__.gatherV2Config,
    _kernels_Greater__WEBPACK_IMPORTED_MODULE_66__.greaterConfig,
    _kernels_GreaterEqual__WEBPACK_IMPORTED_MODULE_67__.greaterEqualConfig,
    _kernels_Identity__WEBPACK_IMPORTED_MODULE_68__.identityConfig,
    _kernels_IFFT__WEBPACK_IMPORTED_MODULE_69__.ifftConfig,
    _kernels_Imag__WEBPACK_IMPORTED_MODULE_70__.imagConfig,
    _kernels_IsFinite__WEBPACK_IMPORTED_MODULE_71__.isFiniteConfig,
    _kernels_IsInf__WEBPACK_IMPORTED_MODULE_72__.isInfConfig,
    _kernels_IsNaN__WEBPACK_IMPORTED_MODULE_73__.isNaNConfig,
    _kernels_LeakyRelu__WEBPACK_IMPORTED_MODULE_74__.leakyReluConfig,
    _kernels_Less__WEBPACK_IMPORTED_MODULE_75__.lessConfig,
    _kernels_LessEqual__WEBPACK_IMPORTED_MODULE_76__.lessEqualConfig,
    _kernels_LinSpace__WEBPACK_IMPORTED_MODULE_77__.linSpaceConfig,
    _kernels_Log1p__WEBPACK_IMPORTED_MODULE_78__.log1pConfig,
    _kernels_Log__WEBPACK_IMPORTED_MODULE_79__.logConfig,
    _kernels_LogicalAnd__WEBPACK_IMPORTED_MODULE_80__.logicalAndConfig,
    _kernels_LogicalNot__WEBPACK_IMPORTED_MODULE_81__.logicalNotConfig,
    _kernels_LogicalOr__WEBPACK_IMPORTED_MODULE_82__.logicalOrConfig,
    _kernels_Max__WEBPACK_IMPORTED_MODULE_83__.maxConfig,
    _kernels_MaxPool3D__WEBPACK_IMPORTED_MODULE_84__.maxPool3DConfig,
    _kernels_MaxPool__WEBPACK_IMPORTED_MODULE_85__.maxPoolConfig,
    _kernels_MaxPool3DGrad__WEBPACK_IMPORTED_MODULE_86__.maxPoolGrad3DConfig,
    _kernels_MaxPoolGrad__WEBPACK_IMPORTED_MODULE_87__.maxPoolGradConfig,
    _kernels_MaxPoolWithArgmax__WEBPACK_IMPORTED_MODULE_88__.maxPoolWithArgmaxConfig,
    _kernels_Maximum__WEBPACK_IMPORTED_MODULE_89__.maximumConfig,
    _kernels_Mean__WEBPACK_IMPORTED_MODULE_90__.meanConfig,
    _kernels_Min__WEBPACK_IMPORTED_MODULE_91__.minConfig,
    _kernels_Minimum__WEBPACK_IMPORTED_MODULE_92__.minimumConfig,
    _kernels_MirrorPad__WEBPACK_IMPORTED_MODULE_93__.mirrorPadConfig,
    _kernels_Mod__WEBPACK_IMPORTED_MODULE_94__.modConfig,
    _kernels_Multinomial__WEBPACK_IMPORTED_MODULE_95__.multinomialConfig,
    _kernels_Multiply__WEBPACK_IMPORTED_MODULE_96__.multiplyConfig,
    _kernels_Neg__WEBPACK_IMPORTED_MODULE_97__.negConfig,
    _kernels_NonMaxSuppressionV3__WEBPACK_IMPORTED_MODULE_98__.nonMaxSuppressionV3Config,
    _kernels_NonMaxSuppressionV4__WEBPACK_IMPORTED_MODULE_99__.nonMaxSuppressionV4Config,
    _kernels_NonMaxSuppressionV5__WEBPACK_IMPORTED_MODULE_100__.nonMaxSuppressionV5Config,
    _kernels_NotEqual__WEBPACK_IMPORTED_MODULE_101__.notEqualConfig,
    _kernels_OneHot__WEBPACK_IMPORTED_MODULE_102__.oneHotConfig,
    _kernels_OnesLike__WEBPACK_IMPORTED_MODULE_103__.onesLikeConfig,
    _kernels_Pack__WEBPACK_IMPORTED_MODULE_104__.packConfig,
    _kernels_PadV2__WEBPACK_IMPORTED_MODULE_105__.padV2Config,
    _kernels_Pow__WEBPACK_IMPORTED_MODULE_106__.powConfig,
    _kernels_Prelu__WEBPACK_IMPORTED_MODULE_107__.preluConfig,
    _kernels_Prod__WEBPACK_IMPORTED_MODULE_108__.prodConfig,
    _kernels_Range__WEBPACK_IMPORTED_MODULE_109__.rangeConfig,
    _kernels_Real__WEBPACK_IMPORTED_MODULE_110__.realConfig,
    _kernels_RealDiv__WEBPACK_IMPORTED_MODULE_111__.realDivConfig,
    _kernels_Reciprocal__WEBPACK_IMPORTED_MODULE_112__.reciprocalConfig,
    _kernels_Relu6__WEBPACK_IMPORTED_MODULE_113__.relu6Config,
    _kernels_Relu__WEBPACK_IMPORTED_MODULE_114__.reluConfig,
    _kernels_Reshape__WEBPACK_IMPORTED_MODULE_115__.reshapeConfig,
    _kernels_ResizeBilinear__WEBPACK_IMPORTED_MODULE_116__.resizeBilinearConfig,
    _kernels_ResizeBilinearGrad__WEBPACK_IMPORTED_MODULE_117__.resizeBilinearGradConfig,
    _kernels_ResizeNearestNeighbor__WEBPACK_IMPORTED_MODULE_118__.resizeNearestNeighborConfig,
    _kernels_ResizeNearestNeighborGrad__WEBPACK_IMPORTED_MODULE_119__.resizeNearestNeighborGradConfig,
    _kernels_Reverse__WEBPACK_IMPORTED_MODULE_120__.reverseConfig,
    _kernels_RotateWithOffset__WEBPACK_IMPORTED_MODULE_121__.rotateWithOffsetConfig,
    _kernels_Round__WEBPACK_IMPORTED_MODULE_122__.roundConfig,
    _kernels_Rsqrt__WEBPACK_IMPORTED_MODULE_123__.rsqrtConfig,
    _kernels_ScatterNd__WEBPACK_IMPORTED_MODULE_124__.scatterNdConfig,
    _kernels_Select__WEBPACK_IMPORTED_MODULE_125__.selectConfig,
    _kernels_Selu__WEBPACK_IMPORTED_MODULE_126__.seluConfig,
    _kernels_Sigmoid__WEBPACK_IMPORTED_MODULE_127__.sigmoidConfig,
    _kernels_Sign__WEBPACK_IMPORTED_MODULE_128__.signConfig,
    _kernels_Sin__WEBPACK_IMPORTED_MODULE_129__.sinConfig,
    _kernels_Sinh__WEBPACK_IMPORTED_MODULE_130__.sinhConfig,
    _kernels_Slice__WEBPACK_IMPORTED_MODULE_131__.sliceConfig,
    _kernels_Softmax__WEBPACK_IMPORTED_MODULE_132__.softmaxConfig,
    _kernels_Softplus__WEBPACK_IMPORTED_MODULE_133__.softplusConfig,
    _kernels_SpaceToBatchND__WEBPACK_IMPORTED_MODULE_134__.spaceToBatchNDConfig,
    _kernels_SparseToDense__WEBPACK_IMPORTED_MODULE_135__.sparseToDenseConfig,
    _kernels_SplitV__WEBPACK_IMPORTED_MODULE_136__.splitVConfig,
    _kernels_Sqrt__WEBPACK_IMPORTED_MODULE_137__.sqrtConfig,
    _kernels_Square__WEBPACK_IMPORTED_MODULE_138__.squareConfig,
    _kernels_SquaredDifference__WEBPACK_IMPORTED_MODULE_139__.squaredDifferenceConfig,
    _kernels_Step__WEBPACK_IMPORTED_MODULE_140__.stepConfig,
    _kernels_StridedSlice__WEBPACK_IMPORTED_MODULE_141__.stridedSliceConfig,
    _kernels_Sub__WEBPACK_IMPORTED_MODULE_142__.subConfig,
    _kernels_Sum__WEBPACK_IMPORTED_MODULE_143__.sumConfig,
    _kernels_Tan__WEBPACK_IMPORTED_MODULE_144__.tanConfig,
    _kernels_Tanh__WEBPACK_IMPORTED_MODULE_145__.tanhConfig,
    _kernels_Tile__WEBPACK_IMPORTED_MODULE_146__.tileConfig,
    _kernels_TopK__WEBPACK_IMPORTED_MODULE_147__.topKConfig,
    _kernels_Transpose__WEBPACK_IMPORTED_MODULE_148__.transposeConfig,
    _kernels_Unique__WEBPACK_IMPORTED_MODULE_149__.uniqueConfig,
    _kernels_Unpack__WEBPACK_IMPORTED_MODULE_150__.unpackConfig,
    _kernels_UnsortedSegmentSum__WEBPACK_IMPORTED_MODULE_151__.unsortedSegmentSumConfig,
    _kernels_ZerosLike__WEBPACK_IMPORTED_MODULE_152__.zerosLikeConfig
];
for (const kernelConfig of kernelConfigs) {
    (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.registerKernel)(kernelConfig);
}
//# sourceMappingURL=register_all_kernels.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReshapePackedProgram": () => (/* binding */ ReshapePackedProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class ReshapePackedProgram {
    constructor(outputShape, inputShape) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        let mainLoop = ``;
        for (let i = 0; i < 4; i++) {
            let thisRC = `thisRC = rc;`;
            if (i % 2 === 1) {
                thisRC += `thisRC.z += 1;`;
            }
            if (i > 1) {
                thisRC += `thisRC.y += 1;`;
            }
            mainLoop += `
        ${thisRC}
        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? '}' : ''}
      `;
        }
        this.userCode = `
      ${getReshapedInputCoords(inputShape)}
      ${_shader_compiler_util__WEBPACK_IMPORTED_MODULE_0__.getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${outputShape[1]};
        int cols = ${outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
    }
}
function getReshapedInputCoords(shape) {
    const coordsFromIndexSnippet = _shader_compiler_util__WEBPACK_IMPORTED_MODULE_0__.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}
//# sourceMappingURL=reshape_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResizeBilinearBackpropProgram": () => (/* binding */ ResizeBilinearBackpropProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ResizeBilinearBackpropProgram {
    constructor(dyShape, inputShape, alignCorners) {
        this.variableNames = ['dy'];
        this.outputShape = [];
        this.outputShape = inputShape;
        const [, xHeight, xWidth,] = inputShape;
        const [, yHeight, yWidth] = dyShape;
        // In the backwards pass, we want to find the pixels that were generated for
        // each pixel in the input image the forward pass and add the corresponding
        // coefficient from dy to the gradient (with some interpolation).
        const effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        // This defines the size of the window of values around a particular
        // index in dy that we want to search for contributions to dx.
        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;
        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
}
//# sourceMappingURL=resize_bilinear_backprop_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResizeBilinearProgram": () => (/* binding */ ResizeBilinearProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ResizeBilinearProgram {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
        this.variableNames = ['A'];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        let sourceFracIndexRC;
        if (halfPixelCenters) {
            sourceFracIndexRC =
                `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +
                    ` - vec2(0.5)`;
        }
        else {
            sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
        }
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
}
//# sourceMappingURL=resize_bilinear_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResizeBilinearPackedProgram": () => (/* binding */ ResizeBilinearPackedProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ResizeBilinearPackedProgram {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        let sourceFracIndexRC;
        if (halfPixelCenters) {
            sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * ` +
                `effectiveInputOverOutputRatioRC - vec3(0.5)`;
        }
        else {
            sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
        }
        this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
}
//# sourceMappingURL=resize_bilinear_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResizeNearestNeigborBackpropProgram": () => (/* binding */ ResizeNearestNeigborBackpropProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ResizeNearestNeigborBackpropProgram {
    constructor(dyShape, inputShape, alignCorners) {
        this.variableNames = ['dy'];
        this.outputShape = [];
        this.outputShape = inputShape;
        const [, xHeight, xWidth,] = inputShape;
        const [, yHeight, yWidth] = dyShape;
        // In the backwards pass, we want to find the pixels that were generated for
        // each pixel in the input image the forward pass and add the corresponding
        // coefficient from dy to the gradient (with some interpolation).
        const effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        // This defines the size of the window of values around a particular
        // index in dy that we want to search for contributions to dx.
        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;
        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
}
//# sourceMappingURL=resize_nearest_neighbor_backprop_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResizeNearestNeighborProgram": () => (/* binding */ ResizeNearestNeighborProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ResizeNearestNeighborProgram {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
        this.variableNames = ['A'];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        // When align corners is false, we rounds the value with floor.
        const roundBase = alignCorners ? '0.5' : '0.0';
        let sourceFracIndexRC;
        if (halfPixelCenters) {
            sourceFracIndexRC =
                `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +
                    `, vec2(0.0))`;
        }
        else {
            sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
        }
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
}
//# sourceMappingURL=resize_nearest_neighbor_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReverseProgram": () => (/* binding */ ReverseProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class ReverseProgram {
    constructor(xShape, axis) {
        this.variableNames = ['x'];
        const rank = xShape.length;
        if (rank > 4) {
            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        }
        this.outputShape = xShape;
        if (rank === 1) {
            this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
            return;
        }
        const getInCoord = (i) => {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                return `${xShape[i]} - coords[${i}] - 1`;
            }
            return `coords[${i}]`;
        };
        const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');
        const type = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(rank);
        this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
    }
}
//# sourceMappingURL=reverse_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReversePackedProgram": () => (/* binding */ ReversePackedProgram)
/* harmony export */ });
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


class ReversePackedProgram {
    constructor(xShape, axis) {
        this.variableNames = ['x'];
        this.packedInputs = true;
        this.packedOutput = true;
        const rank = xShape.length;
        if (rank > 4) {
            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        }
        this.outputShape = xShape;
        const channels = (0,_packing_util__WEBPACK_IMPORTED_MODULE_0__.getChannels)('rc', rank);
        const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
        const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
        const type = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_1__.getCoordsDataType)(rank);
        if (rank === 1) {
            this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
        }
        else {
            this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;
        }
        function getR(channels) {
            return getChannel(channels);
        }
        function getG(channels) {
            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;
            return getChannel(channels);
        }
        function getB(channels) {
            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;
            return getChannel(channels);
        }
        function getA(channels) {
            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;
            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;
            return getChannel(channels);
        }
        function getChannel(channels) {
            const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));
            const inCoords = inCoordsArray.join(',');
            const innerDims = inCoordsArray.slice(-2).join(',');
            return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
        }
        function getInCoord(i, channels1) {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                return `${xShape[i]} - ${channels1[i]} - 1`;
            }
            else {
                return `${channels1[i]}`;
            }
        }
    }
}
//# sourceMappingURL=reverse_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RotateProgram": () => (/* binding */ RotateProgram)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class RotateProgram {
    constructor(imageShape, radians, fillValue, center) {
        this.variableNames = ['Image'];
        this.outputShape = [];
        const imageHeight = imageShape[1];
        const imageWidth = imageShape[2];
        const sinFactor = Math.sin(radians).toFixed(3);
        const cosFactor = Math.cos(radians).toFixed(3);
        this.outputShape = imageShape;
        const [centerX, centerY] = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util.getImageCenter(center, imageHeight, imageWidth);
        const centerXString = centerX.toFixed(3);
        const centerYString = centerY.toFixed(3);
        let fillSnippet = '';
        if (typeof fillValue === 'number') {
            fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
        }
        else {
            fillSnippet = `
        vec3 fill = vec3(${fillValue.join(',')});
        float outputValue = fill[coords[3]];`;
        }
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - ${centerXString}) * ${cosFactor} - (float(y) - ${centerYString}) * ${sinFactor};
          float coordYFloat = (float(x) - ${centerXString}) * ${sinFactor} + (float(y) - ${centerYString}) * ${cosFactor};
          int coordX = int(round(coordXFloat + ${centerXString}));
          int coordY = int(round(coordYFloat + ${centerYString}));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
}
//# sourceMappingURL=rotate_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScatterProgram": () => (/* binding */ ScatterProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class ScatterProgram {
    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {
        this.variableNames = ['updates', 'indices', 'defaultValue'];
        this.outputShape = shape;
        const stridesType = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(strides.length);
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(shape.length);
        let indicesString = '';
        if (indicesRank === 1) {
            indicesString = 'i';
        }
        else if (indicesRank === 2) {
            indicesString = 'i, j';
        }
        const indicesSnippet = `getIndices(${indicesString})`;
        let updatesString = '';
        if (updatesRank === 1) {
            updatesString = 'i';
        }
        else if (updatesRank === 2) {
            updatesString = 'i, coords[1]';
        }
        const updatesSnippet = `getUpdates(${updatesString})`;
        const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';
        this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
    }
}
//# sourceMappingURL=scatter_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SegmentOpProgram": () => (/* binding */ SegmentOpProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class SegmentOpProgram {
    constructor(segOpInfo, segOpType) {
        this.variableNames = ['x', 'segmentIds'];
        const windowSize = segOpInfo.windowSize;
        const batchSize = segOpInfo.batchSize;
        const inSize = segOpInfo.inSize;
        const numSegments = segOpInfo.numSegments;
        const outSize = numSegments * Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        const initializationValue = '0.0';
        const returnValue = `sumValue`;
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
        let checkValueOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
        }
        let checkSegmentIdOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
        }
        this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
}
//# sourceMappingURL=segment_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectProgram": () => (/* binding */ SelectProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class SelectProgram {
    constructor(cRank, shape, rank) {
        this.variableNames = ['c', 'a', 'b'];
        this.outputShape = shape;
        let cCoords;
        let abCoords;
        if (rank > 4) {
            throw Error(`Where for rank ${rank} is not yet supported`);
        }
        if (rank === 1) {
            abCoords = `resRC`;
            cCoords = `resRC`;
        }
        else {
            const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
            const cCoordVars = [];
            const abCoordVars = [];
            for (let i = 0; i < shape.length; i++) {
                abCoordVars.push(`${currentCoords[i]}`);
                if (i < cRank) {
                    cCoordVars.push(`${currentCoords[i]}`);
                }
            }
            cCoords = cCoordVars.join();
            abCoords = abCoordVars.join();
        }
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(rank);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
    }
}
//# sourceMappingURL=select_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeShader": () => (/* binding */ makeShader),
/* harmony export */   "getCoordsDataType": () => (/* binding */ getCoordsDataType)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _glsl_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glsl_version */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js");
/* harmony import */ var _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader_compiler_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

const { getBroadcastDims } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.backend_util;


function makeShader(inputsInfo, outputShape, userCode, usesPackedTextures) {
    const prefixSnippets = [];
    inputsInfo.forEach(x => {
        const size = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(x.shapeInfo.logicalShape);
        // Snippet when we decided to upload the values as uniform.
        if (x.shapeInfo.isUniform) {
            prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);
        }
        else {
            prefixSnippets.push(`uniform sampler2D ${x.name};`);
            prefixSnippets.push(`uniform int offset${x.name};`);
        }
    });
    const inputPrefixSnippet = prefixSnippets.join('\n');
    const inputSamplingSnippet = inputsInfo
        .map(x => getInputSamplingSnippet(x, outputShape, usesPackedTextures))
        .join('\n');
    const outTexShape = outputShape.texShape;
    const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
    const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
    let outputSamplingSnippet;
    let floatTextureSetOutputSnippet;
    let shaderPrefix = getShaderPrefix(glsl);
    if (outputShape.isPacked) {
        outputSamplingSnippet =
            getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
        floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
    }
    else {
        outputSamplingSnippet =
            getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
        floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
    }
    if (usesPackedTextures) {
        shaderPrefix += SHADER_PACKED_PREFIX;
    }
    const source = [
        shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,
        inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
function getSamplerFromInInfo(inInfo) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        case 5:
            return getSampler5D(inInfo);
        case 6:
            return getSampler6D(inInfo);
        default:
            throw new Error(`${shape.length}-D input sampling` +
                ` is not yet supported`);
    }
}
function getPackedSamplerFromInInfo(inInfo) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getPackedSamplerScalar(inInfo);
        case 1:
            return getPackedSampler1D(inInfo);
        case 2:
            return getPackedSampler2D(inInfo);
        case 3:
            return getPackedSampler3D(inInfo);
        default:
            return getPackedSamplerND(inInfo);
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false) {
    let res = '';
    if (usesPackedTextures) {
        res += getPackedSamplerFromInInfo(inInfo);
    }
    else {
        res += getSamplerFromInInfo(inInfo);
    }
    const inShape = inInfo.shapeInfo.logicalShape;
    const outShape = outShapeInfo.logicalShape;
    if (inShape.length <= outShape.length) {
        if (usesPackedTextures) {
            res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
        }
        else {
            res += getSamplerAtOutputCoords(inInfo, outShapeInfo);
        }
    }
    return res;
}
function getPackedOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutputPacked1DCoords(outShape, outTexShape);
        case 2:
            return getOutputPacked2DCoords(outShape, outTexShape);
        case 3:
            return getOutputPacked3DCoords(outShape, outTexShape);
        default:
            return getOutputPackedNDCoords(outShape, outTexShape);
    }
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        case 5:
            return getOutput5DCoords(outShape, outTexShape);
        case 6:
            return getOutput6DCoords(outShape, outTexShape);
        default:
            throw new Error(`${outShape.length}-D output sampling is not yet supported`);
    }
}
function getFloatTextureSampleSnippet(glsl) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
}
function getFloatTextureSetRSnippet(glsl) {
    return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
}
function getFloatTextureSetRGBASnippet(glsl) {
    return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
}
function getShaderPrefix(glsl) {
    const SHADER_PREFIX = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;
    return SHADER_PREFIX;
}
const SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
const SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
const SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
const SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function getOutputScalarCoords() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
}
function getOutputPacked1DCoords(shape, texShape) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (packedTexShape[0] === 1) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
    }
    if (packedTexShape[1] === 1) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
    }
    if (texShape[1] === 1) {
        return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
}
function getOutputPacked3DCoords(shape, texShape) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
}
function getOutput3DCoords(shape, texShape) {
    const coordsFromIndexSnippet = _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}
function getOutputPackedNDCoords(shape, texShape) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
    let texelsInBatchN = texelsInBatch;
    let batches = ``;
    let coords = 'b, r, c';
    for (let b = 2; b < shape.length - 1; b++) {
        texelsInBatchN *= shape[shape.length - b - 1];
        batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
        coords = `b${b}, ` + coords;
    }
    return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords});
    }
  `;
}
function getOutput4DCoords(shape, texShape) {
    const coordsFromIndexSnippet = _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2'], shape);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
}
function getOutput5DCoords(shape, texShape) {
    const coordsFromIndexSnippet = _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3'], shape);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
}
function getOutput6DCoords(shape, texShape) {
    const coordsFromIndexSnippet = _shader_compiler_util__WEBPACK_IMPORTED_MODULE_2__.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
}
function getOutputPacked2DCoords(shape, texShape) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(shape, texShape)) {
        return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
    }
    // texels needed to accommodate a logical row
    const texelsInLogicalRow = Math.ceil(shape[1] / 2);
    /**
     * getOutputCoords
     *
     * resTexRC: The rows and columns of the texels. If you move over one
     * texel to the right in the packed texture, you are moving over one column
     * (not two).
     *
     * index: The texel index
     */
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
}
function getOutput2DCoords(shape, texShape) {
    if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(shape, texShape)) {
        return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
    }
    if (shape[1] === 1) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
    }
    if (shape[0] === 1) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
    }
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
}
function getFlatOffsetUniformName(texName) {
    return `offset${texName}`;
}
function getPackedSamplerScalar(inputInfo) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
    return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
}
function getSamplerScalar(inputInfo) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
        return `float ${funcName}() {return ${texName};}`;
    }
    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
    if (texNumR === 1 && texNumC === 1) {
        return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getPackedSampler1D(inputInfo) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
    return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler1D(inputInfo) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
        // Uniform arrays will be less than 65505 (no risk of float16 overflow).
        return `
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const tNumR = texShape[0];
    const tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (tNumC === 1) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (tNumR === 1) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getPackedSampler2D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
    if (texShape != null && _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(shape, texShape)) {
        return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const valuesPerRow = Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler2D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    if (texShape != null && _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(shape, texShape)) {
        const texNumR = texShape[0];
        const texNumC = texShape[1];
        return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const { newShape, keptDims } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ['row', 'col'];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
        // Uniform arrays will be less than 65505 (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const offset = getFlatOffsetUniformName(texName);
    if (texNumC === 1) {
        // index is used directly as physical (no risk of float16 overflow).
        return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (texNumR === 1) {
        // index is used directly as physical (no risk of float16 overflow).
        return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
}
function getPackedSampler3D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (shape[0] === 1) {
        const squeezedShape = shape.slice(1);
        const keptDims = [1, 2];
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ['b', 'row', 'col'];
        return `
        ${getPackedSamplerFromInInfo(newInputInfo)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
    const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
    return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler3D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride0 = shape[1] * shape[2];
    const stride1 = shape[2];
    const { newShape, keptDims } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ['row', 'col', 'depth'];
        return `
        ${getSamplerFromInInfo(newInputInfo)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    if (inputInfo.shapeInfo.isUniform) {
        // Uniform arrays will be less than 65505 (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    if (texNumC === stride0 && flatOffset == null) {
        // texC is used directly as physical (no risk of float16 overflow).
        return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
    }
    if (texNumC === stride1 && flatOffset == null) {
        // texR is used directly as physical (no risk of float16 overflow).
        return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
}
function getPackedSamplerND(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const rank = shape.length;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
    let params = `int b, int row, int col`;
    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
    for (let b = 2; b < rank - 1; b++) {
        params = `int b${b}, ` + params;
        texelsInBatch *= shape[rank - b - 1];
        index = `b${b} * ${texelsInBatch} + ` + index;
    }
    const glsl = (0,_glsl_version__WEBPACK_IMPORTED_MODULE_1__.getGlslDifferences)();
    return `
    vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler4D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride2 = shape[3];
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.squeezeShape(shape);
    if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ['row', 'col', 'depth', 'depth2'];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
        // Uniform arrays will be less than 65505 (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
        // texC is used directly as physical (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride2 && flatOffset == null) {
        // texR is used directly as physical (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getSampler5D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride3 = shape[4];
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.squeezeShape(shape);
    if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ['row', 'col', 'depth', 'depth2', 'depth3'];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
        // Uniform arrays will be less than 65505 (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
        // texC is used directly as physical (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride3 && flatOffset == null) {
        // texR is used directly as physical (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getSampler6D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const { newShape, keptDims } = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.squeezeShape(shape);
    if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    const stride4 = shape[5];
    const stride3 = shape[4] * stride4;
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    if (inputInfo.shapeInfo.isUniform) {
        // Uniform arrays will be less than 65505 (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
        // texC is used directly as physical (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride4 && flatOffset == null) {
        // texR is used directly as physical (no risk of float16 overflow).
        return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getUniformSampler(inputInfo) {
    const texName = inputInfo.name;
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    if (inSize < 2) {
        return `return ${texName};`;
    }
    return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
}
function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const type = getCoordsDataType(outRank);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)
                .join('\n');
    }
    let unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map((s, i) => `coords.${fields[i + rankDiff]}`)
            .join(', ');
    }
    let output = `return outputValue;`;
    const inSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    const isInputScalar = inSize === 1;
    const outSize = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(outShapeInfo.logicalShape);
    const isOutputScalar = outSize === 1;
    if (inRank === 1 && !isInputScalar && !isOutputScalar) {
        output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    }
    else if (isInputScalar && !isOutputScalar) {
        if (outRank === 1) {
            output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
        }
        else {
            output = `
        return vec4(outputValue.x);
      `;
        }
    }
    else if (broadcastDims.length) {
        const rows = inRank - 2;
        const cols = inRank - 1;
        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
            output = `return vec4(outputValue.x);`;
        }
        else if (broadcastDims.indexOf(rows) > -1) {
            output = `return vec4(outputValue.x, outputValue.y, ` +
                `outputValue.x, outputValue.y);`;
        }
        else if (broadcastDims.indexOf(cols) > -1) {
            output = `return vec4(outputValue.xx, outputValue.zz);`;
        }
    }
    return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    const outTexShape = outShapeInfo.texShape;
    const inTexShape = inputInfo.shapeInfo.texShape;
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&
        inputInfo.shapeInfo.flatOffset == null &&
        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(inTexShape, outTexShape)) {
        return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
    }
    const type = getCoordsDataType(outRank);
    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)
                .join('\n');
    }
    let unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map((s, i) => `coords.${fields[i + rankDiff]}`)
            .join(', ');
    }
    return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
}
function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else if (rank === 5) {
        return 'ivec5';
    }
    else if (rank === 6) {
        return 'ivec6';
    }
    else {
        throw Error(`GPU for rank ${rank} is not yet supported`);
    }
}
/** Returns a new input info (a copy) that has a squeezed logical shape. */
function squeezeInputInfo(inInfo, squeezedShape) {
    // Deep copy.
    const newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(d => params[d]).join(', ');
}
//# sourceMappingURL=shader_compiler.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLogicalCoordinatesFromFlatIndex": () => (/* binding */ getLogicalCoordinatesFromFlatIndex),
/* harmony export */   "dotify": () => (/* binding */ dotify),
/* harmony export */   "getFlatIndexFrom3D": () => (/* binding */ getFlatIndexFrom3D),
/* harmony export */   "ENCODE_FLOAT_SNIPPET": () => (/* binding */ ENCODE_FLOAT_SNIPPET)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

/**
 * Produces GLSL code that derives logical coordinates from a flat
 * index. The code performs integer division with each stride and decrements
 * the index until the index equals the final dimension coordinate.
 */
function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {
    const strides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(shape);
    return strides
        .map((stride, i) => {
        const line1 = `int ${coords[i]} = ${index} / ${stride}`;
        const line2 = i === strides.length - 1 ?
            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :
            `index -= ${coords[i]} * ${stride}`;
        return `${line1}; ${line2};`;
    })
        .join('');
}
function buildVec(x) {
    if (x.length === 1) {
        return `${x[0]}`;
    }
    return `vec${x.length}(${x.join(',')})`;
}
/**
 * Produces GLSL code that computes the dot product of the input x and y
 * vectors. Handles splitting inputs into increments of vec4s when necessary.
 */
function dotify(x, y) {
    if (x.length !== y.length) {
        throw new Error(`Vectors to be dotted must be of the same length -` +
            `got ${x.length} and ${y.length}`);
    }
    const slices = [];
    const nearestVec4 = Math.floor(x.length / 4);
    const nearestVec4Remainder = x.length % 4;
    for (let i = 0; i < nearestVec4; i++) {
        const xSlice = x.slice(i * 4, i * 4 + 4);
        const ySlice = y.slice(i * 4, i * 4 + 4);
        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);
    }
    if (nearestVec4Remainder !== 0) {
        let xSlice = x.slice(nearestVec4 * 4);
        let ySlice = y.slice(nearestVec4 * 4);
        if (xSlice.length === 1) {
            xSlice = xSlice.map(d => `float(${d})`);
            ySlice = ySlice.map(d => `float(${d})`);
        }
        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);
    }
    return slices.map((d, i) => `dot(${d})`).join('+');
}
/**
 * Produces GLSL that computes the flat index from 3D coordinates.
 */
function getFlatIndexFrom3D(shape) {
    const strides = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.computeStrides(shape).map(d => d.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
}
const ENCODE_FLOAT_SNIPPET = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
//# sourceMappingURL=shader_compiler_util.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SliceProgram": () => (/* binding */ SliceProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class SliceProgram {
    constructor(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(this.rank);
        const uniformPart = `uniform int start[${this.rank}];`;
        const sourceCoords = getCoords(this.rank);
        let body;
        const coordSum = destSize.map((_, i) => {
            return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;
        });
        body = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join('\n')}
      `;
        this.userCode = `
      ${uniformPart}
      void main() {
        ${body}
        setOutput(getSource(${sourceCoords}));
      }
    `;
    }
    getCustomSetupFunc(start) {
        if (start.length !== this.rank) {
            throw Error(`The rank (${this.rank}) of the program must match the ` +
                `length of start (${start.length})`);
        }
        return (gpgpu, webGLProgram) => {
            if (this.startLoc == null) {
                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (this.startLoc == null) {
                    // This means the compiler has optimized and realized it doesn't need
                    // the uniform.
                    return;
                }
            }
            gpgpu.gl.uniform1iv(this.startLoc, start);
        };
    }
}
const coords = ['x', 'y', 'z', 'w', 'u', 'v'];
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank <= 6) {
        return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');
    }
    else {
        throw Error(`Slicing for rank ${rank} is not yet supported`);
    }
}
//# sourceMappingURL=slice_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SlicePackedProgram": () => (/* binding */ SlicePackedProgram)
/* harmony export */ });
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


class SlicePackedProgram {
    constructor(destSize) {
        this.variableNames = ['source'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = destSize;
        this.rank = destSize.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(this.rank);
        const coords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_1__.getChannels)('coords', this.rank);
        const sourceLoc = (0,_packing_util__WEBPACK_IMPORTED_MODULE_1__.getChannels)('sourceLoc', this.rank);
        const innerDims = this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;
        const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
        const upperRow = `
      result.x = ${getChannel};
      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
        const lowerRow = this.rank === 1 ? '' : `
      --${coords[this.rank - 1]};
      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
        const sourceLocSetup = this.rank <= 4 ?
            `sourceLoc = coords +
            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :
            destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)
                .join('\n');
        this.userCode = `
      uniform int start[${this.rank}];
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
    }
    getCustomSetupFunc(start) {
        if (start.length !== this.rank) {
            throw Error(`The rank (${this.rank}) of the program must match the ` +
                `length of start (${start.length})`);
        }
        return (gpgpu, webGLProgram) => {
            if (this.startLoc == null) {
                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (this.startLoc == null) {
                    // This means the compiler has optimized and realized it doesn't need
                    // the uniform.
                    return;
                }
            }
            gpgpu.gl.uniform1iv(this.startLoc, start);
        };
    }
}
//# sourceMappingURL=slice_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StridedSliceProgram": () => (/* binding */ StridedSliceProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class StridedSliceProgram {
    constructor(begin, strides, size) {
        this.variableNames = ['x'];
        this.outputShape = size;
        const rank = size.length;
        const inputDtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(size.length);
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(size.length);
        let newCoords = '';
        if (rank === 1) {
            newCoords = 'coords * strides + begin';
        }
        else {
            let outputAxis = 0;
            newCoords =
                size.map((_, i) => {
                    outputAxis++;
                    return size.length === 1 ?
                        `coords * strides[${i}] + begin[${i}]` :
                        `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;
                })
                    .join(',');
        }
        this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
    }
}
//# sourceMappingURL=strided_slice_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PackingScheme": () => (/* binding */ PackingScheme),
/* harmony export */   "TextureUsage": () => (/* binding */ TextureUsage),
/* harmony export */   "PhysicalTextureType": () => (/* binding */ PhysicalTextureType),
/* harmony export */   "getUnpackedMatrixTextureShapeWidthHeight": () => (/* binding */ getUnpackedMatrixTextureShapeWidthHeight),
/* harmony export */   "getUnpackedArraySizeFromMatrixSize": () => (/* binding */ getUnpackedArraySizeFromMatrixSize),
/* harmony export */   "getColorMatrixTextureShapeWidthHeight": () => (/* binding */ getColorMatrixTextureShapeWidthHeight),
/* harmony export */   "getDenseTexShape": () => (/* binding */ getDenseTexShape),
/* harmony export */   "getMatrixSizeFromUnpackedArraySize": () => (/* binding */ getMatrixSizeFromUnpackedArraySize),
/* harmony export */   "decodeMatrixFromUnpackedColorRGBAArray": () => (/* binding */ decodeMatrixFromUnpackedColorRGBAArray),
/* harmony export */   "getPackedMatrixTextureShapeWidthHeight": () => (/* binding */ getPackedMatrixTextureShapeWidthHeight),
/* harmony export */   "getPackedRGBAArraySizeFromMatrixShape": () => (/* binding */ getPackedRGBAArraySizeFromMatrixShape),
/* harmony export */   "getTextureConfig": () => (/* binding */ getTextureConfig)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

var PackingScheme;
(function (PackingScheme) {
    /**
     * All values in a single texel are densely packed without any constraints.
     *
     * This is how the shader encodes a tensor with shape = [2, 3, 4]
     * (indices are [batch, row, col]).
     *
     * 000|001   010|011   020|021
     * -------   -------   -------
     * 002|003   012|013   022|023
     *
     * 100|101   110|111   120|121
     * -------   -------   -------
     * 102|103   112|113   122|123
     *
     */
    PackingScheme[PackingScheme["DENSE"] = 0] = "DENSE";
    /**
     * Single texels contain only values from the same batch, and from adjacent
     * rows and columns.
     *
     * This is how the shader encodes a tensor with shape = [2, 3, 5]
     * (indices are [batch, row, col]).
     *
     * 000|001   002|003   004|xxx   020|021   022|023   024|xxx
     * -------   -------   -------   -------   -------   -------
     * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx
     *
     * 100|101   102|103   104|xxx   120|121   122|123   124|xxx
     * -------   -------   -------   -------   -------   -------
     * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx
     *
     */
    PackingScheme[PackingScheme["SHARED_BATCH"] = 1] = "SHARED_BATCH";
})(PackingScheme || (PackingScheme = {}));
var TextureUsage;
(function (TextureUsage) {
    TextureUsage[TextureUsage["RENDER"] = 0] = "RENDER";
    TextureUsage[TextureUsage["UPLOAD"] = 1] = "UPLOAD";
    TextureUsage[TextureUsage["PIXELS"] = 2] = "PIXELS";
    TextureUsage[TextureUsage["DOWNLOAD"] = 3] = "DOWNLOAD";
})(TextureUsage || (TextureUsage = {}));
var PhysicalTextureType;
(function (PhysicalTextureType) {
    PhysicalTextureType[PhysicalTextureType["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
    PhysicalTextureType[PhysicalTextureType["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
    PhysicalTextureType[PhysicalTextureType["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    PhysicalTextureType[PhysicalTextureType["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
    PhysicalTextureType[PhysicalTextureType["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
})(PhysicalTextureType || (PhysicalTextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
/**
 * Get shape for densely packed RGBA texture.
 */
function getDenseTexShape(shape) {
    const size = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(shape);
    const texelsNeeded = Math.ceil(size / 4);
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeToSquarishShape(texelsNeeded);
}
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error(`unpackedSize (${unpackedSize}) must be a multiple of ` +
            `${channelsPerTexture}`);
    }
    return unpackedSize / channelsPerTexture;
}
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    const requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error(`matrix length (${matrix.length}) must be >= ${requiredSize}`);
    }
    let dst = 0;
    for (let src = 0; src < unpackedArray.length; src += 4) {
        for (let c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [
        Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))
    ];
}
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return w * h * 4;
}
function getTextureConfig(
// tslint:disable-next-line:no-any
gl, textureHalfFloatExtension) {
    // tslint:disable-next-line:no-any
    const glany = gl;
    let internalFormatFloat;
    let internalFormatHalfFloat;
    let internalFormatPackedHalfFloat;
    let internalFormatPackedFloat;
    let textureFormatFloat;
    let downloadTextureFormat;
    let downloadUnpackNumChannels;
    let defaultNumChannels;
    let textureTypeHalfFloat;
    let textureTypeFloat;
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_VERSION') === 2) {
        internalFormatFloat = glany.R32F;
        internalFormatHalfFloat = glany.R16F;
        internalFormatPackedHalfFloat = glany.RGBA16F;
        internalFormatPackedFloat = glany.RGBA32F;
        textureFormatFloat = glany.RED;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 1;
        textureTypeHalfFloat = glany.HALF_FLOAT;
        textureTypeFloat = glany.FLOAT;
    }
    else {
        internalFormatFloat = gl.RGBA;
        internalFormatHalfFloat = gl.RGBA;
        internalFormatPackedHalfFloat = gl.RGBA;
        internalFormatPackedFloat = glany.RGBA;
        textureFormatFloat = gl.RGBA;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 4;
        textureTypeHalfFloat = textureHalfFloatExtension != null ?
            textureHalfFloatExtension.HALF_FLOAT_OES :
            null;
        textureTypeFloat = gl.FLOAT;
    }
    downloadTextureFormat = gl.RGBA;
    return {
        internalFormatFloat,
        internalFormatHalfFloat,
        internalFormatPackedHalfFloat,
        internalFormatPackedFloat,
        textureFormatFloat,
        downloadTextureFormat,
        downloadUnpackNumChannels,
        defaultNumChannels,
        textureTypeHalfFloat,
        textureTypeFloat
    };
}
//# sourceMappingURL=tex_util.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureManager": () => (/* binding */ TextureManager),
/* harmony export */   "computeBytes": () => (/* binding */ computeBytes)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _gpgpu_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gpgpu_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



class TextureManager {
    constructor(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0; // How many bytes that have been allocated
        // are available for reuse.
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextures = {};
    }
    acquireTexture(shapeRC, usage, isPacked) {
        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextures)) {
            this.usedTextures[shapeKey] = [];
        }
        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this._numBytesFree -= texBytes;
            this.log();
            const newTexture = this.freeTextures[shapeKey].shift();
            this.usedTextures[shapeKey].push(newTexture);
            return newTexture;
        }
        let newTexture;
        if (physicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_2X2_FLOAT32) {
            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_2X2_FLOAT16) {
            newTexture =
                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.UNPACKED_FLOAT32) {
            newTexture =
                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.UNPACKED_FLOAT16) {
            newTexture =
                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
        }
        else if (physicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
            newTexture =
                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        this.usedTextures[shapeKey].push(newTexture);
        this.numUsedTextures++;
        this._numBytesAllocated += texBytes;
        this.log();
        return newTexture;
    }
    releaseTexture(texture, shape, logicalTexType, isPacked) {
        if (this.freeTextures == null) {
            // Already disposed.
            return;
        }
        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        const deleteTexThreshold = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().get('WEBGL_DELETE_TEXTURE_THRESHOLD');
        if (deleteTexThreshold !== -1 &&
            this._numBytesAllocated > deleteTexThreshold) {
            this.gpgpu.deleteMatrixTexture(texture);
            this._numBytesAllocated -= texBytes;
        }
        else {
            this.freeTextures[shapeKey].push(texture);
            this.numFreeTextures++;
            this._numBytesFree += texBytes;
        }
        this.numUsedTextures--;
        const texList = this.usedTextures[shapeKey];
        const texIndex = texList.indexOf(texture);
        if (texIndex < 0) {
            throw new Error('Cannot release a texture that was never provided by this ' +
                'texture manager');
        }
        texList.splice(texIndex, 1);
        this.log();
    }
    log() {
        if (!this.logEnabled) {
            return;
        }
        const total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
        const freeRatio = this._numBytesFree / this._numBytesAllocated;
        console.log(`Bytes allocated: ${this._numBytesAllocated}`);
        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
    }
    get numBytesAllocated() {
        return this._numBytesAllocated;
    }
    get numBytesFree() {
        return this._numBytesFree;
    }
    getNumUsedTextures() {
        return this.numUsedTextures;
    }
    getNumFreeTextures() {
        return this.numFreeTextures;
    }
    dispose() {
        if (this.freeTextures == null) {
            // Already disposed.
            return;
        }
        for (const texShape in this.freeTextures) {
            this.freeTextures[texShape].forEach(tex => {
                this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        for (const texShape in this.usedTextures) {
            this.usedTextures[texShape].forEach(tex => {
                this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        this.freeTextures = null;
        this.usedTextures = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0;
    }
}
function numBytesForInternalFormat(gl, internalFormat) {
    // tslint:disable-next-line:no-any
    const glany = gl;
    if (internalFormat === glany.R32F) {
        return 4;
    }
    else if (internalFormat === glany.R16F) {
        return 2;
    }
    else if (internalFormat === glany.RGBA32F) {
        return 16;
    }
    else if (internalFormat === gl.RGBA) {
        return 16;
    }
    else if (internalFormat === glany.RGBA16F) {
        return 8;
    }
    throw new Error(`Unknown internal format ${internalFormat}`);
}
function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {
    // It is not possible to infer packed status from the texture type because
    // depending on the textureConfig, different  texture types may resolve to the
    // same internal format (e.g. in WebGL1, the internal format for
    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`
    // explicitly.
    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
    let numElements;
    if (isPacked) {
        const [packedWidth, packedHeight] = (0,_tex_util__WEBPACK_IMPORTED_MODULE_1__.getPackedMatrixTextureShapeWidthHeight)(shape[0], shape[1]);
        numElements = packedWidth * packedHeight;
    }
    else {
        const [width, height] = (0,_tex_util__WEBPACK_IMPORTED_MODULE_1__.getUnpackedMatrixTextureShapeWidthHeight)(shape[0], shape[1]);
        numElements = width * height;
    }
    const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);
    return numElements * bytesPerElement;
}
function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
    switch (physicalTexType) {
        case _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_2X2_FLOAT32:
            return (0,_gpgpu_util__WEBPACK_IMPORTED_MODULE_2__.getInternalFormatForPackedMatrixTexture)(textureConfig);
        case _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_2X2_FLOAT16:
            return (0,_gpgpu_util__WEBPACK_IMPORTED_MODULE_2__.getInternalFormatForFloat16PackedMatrixTexture)(textureConfig);
        case _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.UNPACKED_FLOAT32:
            return (0,_gpgpu_util__WEBPACK_IMPORTED_MODULE_2__.getInternalFormatForFloat32MatrixTexture)(textureConfig);
        case _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.UNPACKED_FLOAT16:
            return (0,_gpgpu_util__WEBPACK_IMPORTED_MODULE_2__.getInternalFormatForFloat16MatrixTexture)(textureConfig);
        case _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
            return (0,_gpgpu_util__WEBPACK_IMPORTED_MODULE_2__.getInternalFormatForUnsignedBytesMatrixTexture)(textureConfig);
        default:
            throw new Error(`Unknown physical texture type ${physicalTexType}`);
    }
}
function getPhysicalTextureForRendering(isPacked) {
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {
        if (isPacked) {
            return _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_2X2_FLOAT32;
        }
        return _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.UNPACKED_FLOAT32;
    }
    if (isPacked) {
        return _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_2X2_FLOAT16;
    }
    return _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.UNPACKED_FLOAT16;
}
function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
    if (logicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.UPLOAD) {
        return _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_2X2_FLOAT32;
    }
    else if (logicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.RENDER || logicalTexType == null) {
        return getPhysicalTextureForRendering(isPacked);
    }
    else if (logicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.DOWNLOAD ||
        logicalTexType === _tex_util__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.PIXELS) {
        return _tex_util__WEBPACK_IMPORTED_MODULE_1__.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
    }
    throw new Error(`Unknown logical texture type ${logicalTexType}`);
}
function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
}
//# sourceMappingURL=texture_manager.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TileProgram": () => (/* binding */ TileProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class TileProgram {
    constructor(aShape, reps) {
        this.variableNames = ['A'];
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(this.rank);
        const sourceCoords = getSourceCoords(aShape);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
    }
}
function getSourceCoords(aShape) {
    const rank = aShape.length;
    if (rank > 5) {
        throw Error(`Tile for rank ${rank} is not yet supported`);
    }
    if (rank === 1) {
        return `imod(resRC, ${aShape[0]})`;
    }
    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];
    const sourceCoords = [];
    for (let i = 0; i < aShape.length; i++) {
        sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);
    }
    return sourceCoords.join();
}
//# sourceMappingURL=tile_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransposeProgram": () => (/* binding */ TransposeProgram)
/* harmony export */ });
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

class TransposeProgram {
    constructor(aShape, newDim) {
        this.variableNames = ['A'];
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(this.rank);
        const switched = getSwitchedCoords(newDim);
        this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
    }
}
function getSwitchedCoords(newDim) {
    const rank = newDim.length;
    if (rank > 6) {
        throw Error(`Transpose for rank ${rank} is not yet supported`);
    }
    const originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];
    const switchedCoords = new Array(rank);
    for (let i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}
//# sourceMappingURL=transpose_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransposePackedProgram": () => (/* binding */ TransposePackedProgram)
/* harmony export */ });
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


class TransposePackedProgram {
    constructor(aShape, newDim) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        if (this.rank > 6) {
            throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
        }
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_0__.getCoordsDataType)(this.rank);
        const outputOrder = (0,_packing_util__WEBPACK_IMPORTED_MODULE_1__.getVecChannels)('rc', this.rank);
        const switchedOrder = new Array(this.rank);
        for (let i = 0; i < newDim.length; i++) {
            switchedOrder[newDim[i]] = outputOrder[i];
        }
        const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
        const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
        const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
        this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
    }
}
//# sourceMappingURL=transpose_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnaryOpProgram": () => (/* binding */ UnaryOpProgram),
/* harmony export */   "CHECK_NAN_SNIPPET": () => (/* binding */ CHECK_NAN_SNIPPET),
/* harmony export */   "LINEAR": () => (/* binding */ LINEAR),
/* harmony export */   "ABS": () => (/* binding */ ABS),
/* harmony export */   "STEP": () => (/* binding */ STEP),
/* harmony export */   "ELU": () => (/* binding */ ELU),
/* harmony export */   "RELU": () => (/* binding */ RELU),
/* harmony export */   "RELU6": () => (/* binding */ RELU6),
/* harmony export */   "CLONE": () => (/* binding */ CLONE)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class UnaryOpProgram {
    constructor(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
}
const CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;
const LINEAR = `return x;`;
const ABS = `return abs(x);`;
function STEP(alpha = 0.0) {
    return CHECK_NAN_SNIPPET + `
    return x > 0.0 ? 1.0 : float(${alpha});
  `;
}
const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
const RELU = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
const RELU6 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
const CLONE = 'return x;';
//# sourceMappingURL=unaryop_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LINEAR": () => (/* binding */ LINEAR),
/* harmony export */   "ELU": () => (/* binding */ ELU),
/* harmony export */   "RELU": () => (/* binding */ RELU),
/* harmony export */   "RELU6": () => (/* binding */ RELU6),
/* harmony export */   "UnaryOpPackedProgram": () => (/* binding */ UnaryOpPackedProgram)
/* harmony export */ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const LINEAR = `return x;`;
const ELU = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
const RELU = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const RELU6 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
class UnaryOpPackedProgram {
    constructor(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = aShape;
        this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
}
//# sourceMappingURL=unaryop_packed_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnpackProgram": () => (/* binding */ UnpackProgram)
/* harmony export */ });
/* harmony import */ var _packing_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packing_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js");
/* harmony import */ var _shader_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_compiler */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */


class UnpackProgram {
    constructor(outputShape) {
        this.variableNames = ['A'];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outputShape = outputShape;
        const rank = outputShape.length;
        const channels = (0,_packing_util__WEBPACK_IMPORTED_MODULE_0__.getChannels)('rc', rank);
        const dtype = (0,_shader_compiler__WEBPACK_IMPORTED_MODULE_1__.getCoordsDataType)(rank);
        const sourceCoords = (0,_packing_util__WEBPACK_IMPORTED_MODULE_0__.getSourceCoords)(rank, channels);
        const innerDims = channels.slice(-2);
        const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;
        this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords}));
      }
    `;
    }
}
//# sourceMappingURL=unpack_gpu.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/version.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/** @license See the LICENSE file. */
// This code is auto-generated, do not modify this file!
const version = '2.8.6';

//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MathBackendWebGL": () => (/* reexport safe */ _backend_webgl__WEBPACK_IMPORTED_MODULE_1__.MathBackendWebGL),
/* harmony export */   "setWebGLContext": () => (/* reexport safe */ _canvas_util__WEBPACK_IMPORTED_MODULE_2__.setWebGLContext),
/* harmony export */   "GPGPUContext": () => (/* reexport safe */ _gpgpu_context__WEBPACK_IMPORTED_MODULE_3__.GPGPUContext),
/* harmony export */   "gpgpu_util": () => (/* reexport module object */ _gpgpu_util__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   "webgl_util": () => (/* reexport module object */ _webgl_util__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   "forceHalfFloat": () => (/* binding */ forceHalfFloat)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _gpgpu_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gpgpu_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js");
/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webgl_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js");
/* harmony import */ var _backend_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./backend_webgl */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js");
/* harmony import */ var _canvas_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js");
/* harmony import */ var _gpgpu_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gpgpu_context */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */






// WebGL specific utils.

/**
 * Enforce use of half precision textures if available on the platform.
 *
 * @doc {heading: 'Environment', namespace: 'webgl'}
 */
function forceHalfFloat() {
    (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().set('WEBGL_FORCE_F16_TEXTURES', true);
}
//# sourceMappingURL=webgl.js.map

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callAndCheck": () => (/* binding */ callAndCheck),
/* harmony export */   "canBeRepresented": () => (/* binding */ canBeRepresented),
/* harmony export */   "getWebGLErrorMessage": () => (/* binding */ getWebGLErrorMessage),
/* harmony export */   "getExtensionOrThrow": () => (/* binding */ getExtensionOrThrow),
/* harmony export */   "createVertexShader": () => (/* binding */ createVertexShader),
/* harmony export */   "createFragmentShader": () => (/* binding */ createFragmentShader),
/* harmony export */   "createProgram": () => (/* binding */ createProgram),
/* harmony export */   "linkProgram": () => (/* binding */ linkProgram),
/* harmony export */   "validateProgram": () => (/* binding */ validateProgram),
/* harmony export */   "createStaticVertexBuffer": () => (/* binding */ createStaticVertexBuffer),
/* harmony export */   "createStaticIndexBuffer": () => (/* binding */ createStaticIndexBuffer),
/* harmony export */   "getNumChannels": () => (/* binding */ getNumChannels),
/* harmony export */   "createTexture": () => (/* binding */ createTexture),
/* harmony export */   "validateTextureSize": () => (/* binding */ validateTextureSize),
/* harmony export */   "createFramebuffer": () => (/* binding */ createFramebuffer),
/* harmony export */   "bindVertexBufferToProgramAttribute": () => (/* binding */ bindVertexBufferToProgramAttribute),
/* harmony export */   "bindTextureUnit": () => (/* binding */ bindTextureUnit),
/* harmony export */   "unbindTextureUnit": () => (/* binding */ unbindTextureUnit),
/* harmony export */   "getProgramUniformLocationOrThrow": () => (/* binding */ getProgramUniformLocationOrThrow),
/* harmony export */   "getProgramUniformLocation": () => (/* binding */ getProgramUniformLocation),
/* harmony export */   "bindTextureToProgramUniformSampler": () => (/* binding */ bindTextureToProgramUniformSampler),
/* harmony export */   "bindCanvasToFramebuffer": () => (/* binding */ bindCanvasToFramebuffer),
/* harmony export */   "bindColorTextureToFramebuffer": () => (/* binding */ bindColorTextureToFramebuffer),
/* harmony export */   "unbindColorTextureFromFramebuffer": () => (/* binding */ unbindColorTextureFromFramebuffer),
/* harmony export */   "validateFramebuffer": () => (/* binding */ validateFramebuffer),
/* harmony export */   "getFramebufferErrorMessage": () => (/* binding */ getFramebufferErrorMessage),
/* harmony export */   "getBatchDim": () => (/* binding */ getBatchDim),
/* harmony export */   "getRowsCols": () => (/* binding */ getRowsCols),
/* harmony export */   "getShapeAs3D": () => (/* binding */ getShapeAs3D),
/* harmony export */   "getTextureShapeFromLogicalShape": () => (/* binding */ getTextureShapeFromLogicalShape),
/* harmony export */   "isReshapeFree": () => (/* binding */ isReshapeFree),
/* harmony export */   "getWebGLMaxTextureSize": () => (/* binding */ getWebGLMaxTextureSize),
/* harmony export */   "resetMaxTextureSize": () => (/* binding */ resetMaxTextureSize),
/* harmony export */   "resetMaxTexturesInShader": () => (/* binding */ resetMaxTexturesInShader),
/* harmony export */   "getMaxTexturesInShader": () => (/* binding */ getMaxTexturesInShader),
/* harmony export */   "getWebGLDisjointQueryTimerVersion": () => (/* binding */ getWebGLDisjointQueryTimerVersion),
/* harmony export */   "hasExtension": () => (/* binding */ hasExtension),
/* harmony export */   "isWebGLVersionEnabled": () => (/* binding */ isWebGLVersionEnabled),
/* harmony export */   "isCapableOfRenderingToFloatTexture": () => (/* binding */ isCapableOfRenderingToFloatTexture),
/* harmony export */   "isDownloadFloatTextureEnabled": () => (/* binding */ isDownloadFloatTextureEnabled),
/* harmony export */   "isWebGLFenceEnabled": () => (/* binding */ isWebGLFenceEnabled),
/* harmony export */   "assertNotComplex": () => (/* binding */ assertNotComplex)
/* harmony export */ });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/index.js");
/* harmony import */ var _canvas_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js");
/* harmony import */ var _tex_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tex_util */ "./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



function callAndCheck(gl, func) {
    const returnValue = func();
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('DEBUG')) {
        checkWebGLError(gl);
    }
    return returnValue;
}
function checkWebGLError(gl) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
    }
}
// https://en.wikipedia.org/wiki/Half-precision_floating-point_format
const MIN_FLOAT16 = 5.96e-8;
const MAX_FLOAT16 = 65504;
function canBeRepresented(num) {
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||
        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {
        return true;
    }
    return false;
}
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return `Unknown error code ${status}`;
    }
}
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
}
function createVertexShader(gl, vertexShaderSource) {
    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));
    callAndCheck(gl, () => gl.compileShader(vertexShader));
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
function createFragmentShader(gl, fragmentShaderSource) {
    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));
    callAndCheck(gl, () => gl.compileShader(fragmentShader));
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
const lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
        console.log(shaderSource);
        return;
    }
    const lineNumber = +lineNumberRegexResult[1];
    const shaderLines = shaderSource.split('\n');
    const pad = shaderLines.length.toString().length + 2;
    const linesWithLineNumbers = shaderLines.map((line, lineNumber) => _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.rightPad((lineNumber + 1).toString(), pad) + line);
    let maxLineLength = 0;
    for (let i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log(`%c ${_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');
}
function linkProgram(gl, program) {
    callAndCheck(gl, () => gl.linkProgram(program));
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
function validateProgram(gl, program) {
    callAndCheck(gl, () => gl.validateProgram(program));
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
function createStaticVertexBuffer(gl, data) {
    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));
    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));
    return buffer;
}
function createStaticIndexBuffer(gl, data) {
    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');
    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));
    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));
    return buffer;
}
function getNumChannels() {
    if ((0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
function createTexture(gl) {
    return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');
}
function validateTextureSize(width, height) {
    const maxTextureSize = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_MAX_TEXTURE_SIZE');
    if ((width <= 0) || (height <= 0)) {
        const requested = `[${width}x${height}]`;
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        const requested = `[${width}x${height}]`;
        const max = `[${maxTextureSize}x${maxTextureSize}]`;
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
function createFramebuffer(gl) {
    return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');
}
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    const loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
        // The GPU compiler decided to strip out this attribute because it's unused,
        // thus no need to bind.
        return false;
    }
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));
    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));
    return true;
}
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
}
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
}
function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
}
function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));
    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));
}
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));
    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));
}
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
}
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));
}
function validateFramebuffer(gl) {
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return `unknown error ${status}`;
    }
}
function throwIfNull(gl, returnTOrNull, failureMessage) {
    const tOrNull = callAndCheck(gl, () => returnTOrNull());
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    const glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
        throw new Error(`textureUnit must be in ${textureUnitRange}.`);
    }
}
function getBatchDim(shape, dimsToSkip = 2) {
    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
}
function getRowsCols(shape) {
    if (shape.length === 0) {
        throw Error('Cannot get rows and columns of an empty shape array.');
    }
    return [
        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]
    ];
}
function getShapeAs3D(shape) {
    let shapeAs3D = [1, 1, 1];
    const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);
    if (!isScalar) {
        shapeAs3D =
            [getBatchDim(shape), ...getRowsCols(shape)];
    }
    return shapeAs3D;
}
function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
    let maxTexSize = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().getNumber('WEBGL_MAX_TEXTURE_SIZE');
    if (isPacked) {
        maxTexSize = maxTexSize * 2;
        // This logic ensures we accurately count the number of packed texels needed
        // to accommodate the tensor. We can only pack values in the same texel if
        // they are from adjacent pairs of rows/cols within the same batch. So if a
        // tensor has 3 rows, we pretend it has 4 rows in order to account for the
        // fact that the texels containing the third row are half empty.
        logShape = logShape.map((d, i) => i >= logShape.length - 2 ?
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.nearestLargerEven(logShape[i]) :
            logShape[i]);
        // Packed texture height is at least 2 (the channel height of a single
        // texel).
        if (logShape.length === 1) {
            logShape = [2, logShape[0]];
        }
    }
    // If logical shape is 2, we don't squeeze, since we want to match physical.
    if (logShape.length !== 2) {
        const squeezeResult = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    let size = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [1, size];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&
        logShape[2] <= maxTexSize) {
        return [logShape[0] * logShape[1], logShape[2]];
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 &&
        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&
        logShape[3] <= maxTexSize) {
        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        if (isPacked) {
            // For packed textures size equals the number of channels required to
            // accommodate the texture data. However in order to squarify such that
            // inner dimensions stay even, we rewrite size to equal the number of
            // texels. Then in the return statement we rehydrate the squarified
            // dimensions to channel units.
            const batchDim = getBatchDim(logShape);
            let rows = 2, cols = 2;
            if (logShape.length) {
                [rows, cols] = getRowsCols(logShape);
            }
            size = batchDim * (rows / 2) * (cols / 2);
            return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeToSquarishShape(size).map(d => d * 2);
        }
        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.sizeToSquarishShape(size);
    }
}
function isEven(n) {
    return n % 2 === 0;
}
/**
 * This determines whether reshaping a packed texture requires rearranging
 * the data within the texture, assuming 2x2 packing.
 */
function isReshapeFree(shape1, shape2) {
    shape1 = shape1.slice(-2);
    shape2 = shape2.slice(-2);
    if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(shape1, shape2)) {
        return true;
    }
    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.
        return true;
    }
    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||
        shape2[1] === 0) {
        return true;
    }
    if (shape1.length !== shape2.length) { // One of the shapes is a vector.
        const shape1Cols = shape1.slice(-1)[0];
        const shape2Cols = shape2.slice(-1)[0];
        if (shape1Cols === shape2Cols) {
            return true;
        }
        if (isEven(shape1Cols) && isEven(shape2Cols) &&
            (shape1[0] === 1 || shape2[0] === 1)) {
            return true;
        }
    }
    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
}
// We cache webgl params because the environment gets reset between
// unit tests and we don't want to constantly query the WebGLContext for
// MAX_TEXTURE_SIZE.
let MAX_TEXTURE_SIZE;
let MAX_TEXTURES_IN_SHADER;
function getWebGLMaxTextureSize(webGLVersion) {
    if (MAX_TEXTURE_SIZE == null) {
        const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(webGLVersion);
        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    }
    return MAX_TEXTURE_SIZE;
}
function resetMaxTextureSize() {
    MAX_TEXTURE_SIZE = null;
}
function resetMaxTexturesInShader() {
    MAX_TEXTURES_IN_SHADER = null;
}
function getMaxTexturesInShader(webGLVersion) {
    if (MAX_TEXTURES_IN_SHADER == null) {
        const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(webGLVersion);
        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    }
    // We cap at 16 to avoid spurious runtime "memory exhausted" error.
    return Math.min(16, MAX_TEXTURES_IN_SHADER);
}
function getWebGLDisjointQueryTimerVersion(webGLVersion) {
    if (webGLVersion === 0) {
        return 0;
    }
    let queryTimerVersion;
    const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(webGLVersion);
    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&
        webGLVersion === 2) {
        queryTimerVersion = 2;
    }
    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {
        queryTimerVersion = 1;
    }
    else {
        queryTimerVersion = 0;
    }
    return queryTimerVersion;
}
function hasExtension(gl, extensionName) {
    const ext = gl.getExtension(extensionName);
    return ext != null;
}
function isWebGLVersionEnabled(webGLVersion) {
    try {
        const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(webGLVersion);
        if (gl != null) {
            return true;
        }
    }
    catch (e) {
        console.log('Error when getting WebGL context: ', e);
        return false;
    }
    return false;
}
function isCapableOfRenderingToFloatTexture(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(webGLVersion);
    if (webGLVersion === 1) {
        if (!hasExtension(gl, 'OES_texture_float')) {
            return false;
        }
    }
    else {
        if (!hasExtension(gl, 'EXT_color_buffer_float')) {
            return false;
        }
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
}
/**
 * Check if we can download values from a float/half-float texture.
 *
 * Note that for performance reasons we use binding a texture to a framebuffer
 * as a proxy for ability to download float values later using readPixels. The
 * texture params of this texture will not match those in readPixels exactly
 * but if we are unable to bind some kind of float texture to the frameBuffer
 * then we definitely will not be able to read float values from it.
 */
function isDownloadFloatTextureEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(webGLVersion);
    if (webGLVersion === 1) {
        if (!hasExtension(gl, 'OES_texture_float')) {
            return false;
        }
        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {
            return false;
        }
    }
    else {
        if (hasExtension(gl, 'EXT_color_buffer_float')) {
            return createFloatTextureAndBindToFramebuffer(gl);
        }
        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';
        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {
            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
        }
        return false;
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
}
function createFloatTextureAndBindToFramebuffer(gl) {
    const texConfig = (0,_tex_util__WEBPACK_IMPORTED_MODULE_2__.getTextureConfig)(gl);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
}
function createHalfFloatTextureAndBindToFramebuffer(
// tslint:disable-next-line:no-any
gl, textureHalfFloatExtension) {
    const texConfig = (0,_tex_util__WEBPACK_IMPORTED_MODULE_2__.getTextureConfig)(gl, textureHalfFloatExtension);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
}
function isWebGLFenceEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
        return false;
    }
    const gl = (0,_canvas_util__WEBPACK_IMPORTED_MODULE_1__.getWebGLContext)(webGLVersion);
    // tslint:disable-next-line:no-any
    const isEnabled = gl.fenceSync != null;
    return isEnabled;
}
function assertNotComplex(tensor, opName) {
    if (!Array.isArray(tensor)) {
        tensor = [tensor];
    }
    tensor.forEach(t => {
        if (t != null) {
            _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +
                'in the WebGL backend.');
        }
    });
}
//# sourceMappingURL=webgl_util.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_tensorflow_tfjs-backend-webgl_dist_index_js.bundle.js.map